#!/bin/bash
# E2E Flow v2.0 - Complete Implementation
set -euo pipefail

# Config
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
CONFIG_FILE="${CONFIG_FILE:-$PROJECT_ROOT/config/e2e-config.json}"
OUTPUT_DIR="${OUTPUT_DIR:-$PROJECT_ROOT/tmp/e2e-execution}"
STATE_FILE="$OUTPUT_DIR/execution-state.json"
AUDIT_LOG_FILE="$OUTPUT_DIR/audit-log.jsonl"

# Defaults
DRY_RUN=false
SELECTED_REPO=""        # Back-compat: accepts repo id OR owner/name
SELECTED_REPO_ID=""
SELECTED_REPO_FULL=""
SELECTED_PLAN=""
SELECTED_PLAN_FILE=""
PARENT_ISSUE_NUMBER=""
CHILDREN_FILE=""
INCLUDE_PARENT_IN_BODY=true
ENABLE_PROJECT_SYNC=false
PROJECT_SPEC=""         # format: ownerOrOrg/number (e.g. Axodus/23)
PROJECT_ID=""
PROJECT_OWNER=""
PROJECT_NUMBER=""
METADATA_FILE=""
METADATA_REQUIRED=true
METADATA_JSON="{}"
ENFORCE_LABEL_ALLOWLIST=false
TIMING_AFTER_PAI=0
TIMING_AFTER_CHILDREN=0
TIMING_AFTER_LINK=0
ENFORCE_PAI_CONTENT_MATCH=false
PLAN_HASH=""
CURRENT_STAGE=1
INTERACTIVE=true
RUN_SINGLE_STAGE=false
STAGE_NAMES=("SETUP" "PREPARE" "CREATE_PAI" "CREATE_CHILDREN" "LINK_HIERARCHY" "SYNC_PROJECTV2" "PROGRESS_TRACKING" "REPORTING")

# Sub-issues linking behavior
REPLACE_PARENT=false

# Colors
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; BLUE='\033[0;34m'
MAGENTA='\033[0;35m'; CYAN='\033[0;36m'; NC='\033[0m'

# Logging
log_stage() { echo ""; echo -e "${MAGENTA}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"; echo -e "${MAGENTA}  STAGE $1: $2${NC}"; echo -e "${MAGENTA}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"; echo ""; }
log_info() { echo -e "${BLUE}â„¹${NC} $1"; }
log_success() { echo -e "${GREEN}âœ“${NC} $1"; }
log_error() { echo -e "${RED}âœ—${NC} $1" >&2; }
log_warning() { echo -e "${YELLOW}âš ${NC} $1"; }
log_prompt() { echo -e "${CYAN}â¯${NC} $1"; }

# Audit logging (JSONL)
audit_log() {
    local action="$1"
    local payload_json="${2:-{}}"
    mkdir -p "$OUTPUT_DIR"

    # Safer: only attempt to treat payload as JSON when jq accepts it; otherwise encode it as a string.
    local ts
    ts=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
    local payload
    if printf '%s' "$payload_json" | jq -e . >/dev/null 2>&1; then
        payload=$(printf '%s' "$payload_json")
    else
        # Wrap arbitrary text as JSON string
        payload=$(printf '%s' "$payload_json" | jq -Rs '.')
    fi

    printf '%s\n' "{\"ts\":\"$ts\",\"action\":\"$action\",\"stage\":${CURRENT_STAGE:-0},\"repo\":\"${SELECTED_REPO_FULL:-}\",\"payload\":$payload}" >> "$AUDIT_LOG_FILE" 2>/dev/null || true
}

# Check for existing issue by title and marker
check_existing_issue() {
    local repo_full="$1"
    local title="$2"
    local marker="${3:-Generated by E2E Flow v2.0}"

    # Strategy 1: GraphQL with explicit body field, DESC order + tail = oldest match
    local query="query {
      repository(owner: \"$(echo "$repo_full" | cut -d'/' -f1)\", name: \"$(echo "$repo_full" | cut -d'/' -f2)\") {
        issues(first: 100, states: OPEN, orderBy: {field: CREATED_AT, direction: DESC}) {
          nodes {
            number
            title
            body
          }
        }
      }
    }"

    local result
    result=$(gh api graphql -f query="$query" 2>/dev/null || echo '{}')

    local matched
    matched=$(echo "$result" | jq --arg title "$title" --arg marker "$marker" -r '.data.repository.issues.nodes[]? | select(.title == $title and ((.body // "") | contains($marker))) | .number' 2>/dev/null | tail -n1)

    if [[ -n "$matched" && "$matched" != "null" && "$matched" != "" ]]; then
        echo "$matched"
        return 0
    fi

    # Strategy 2: Search by marker (may have index delay)
    local existing
    existing=$(gh search issues -R "$repo_full" --match body --json number,title,state "$marker" --limit 100 2>/dev/null || echo '[]')

    matched=$(echo "$existing" | jq --arg title "$title" -r '.[] | select(.title == $title and .state == "OPEN") | .number' 2>/dev/null | head -n1)

    if [[ -n "$matched" && "$matched" != "null" && "$matched" != "" ]]; then
        echo "$matched"
        return 0
    fi

    # Not found
    return 1
}

parse_repo_input() {
    local input="$1"
    if [[ "$input" == *"/"* ]]; then
        SELECTED_REPO_FULL="$input"
        SELECTED_REPO_ID=""
    else
        SELECTED_REPO_ID="$input"
        SELECTED_REPO_FULL=""
    fi
}

resolve_repo_full() {
    if [[ -n "$SELECTED_REPO_FULL" ]]; then
        return 0
    fi

    if [[ -n "$SELECTED_REPO_ID" ]]; then
        local repo_config
        repo_config=$(jq --arg id "$SELECTED_REPO_ID" '.repositories[] | select(.id == $id)' "$CONFIG_FILE" 2>/dev/null || true)
        [[ -n "$repo_config" ]] && SELECTED_REPO_FULL="$(echo "$repo_config" | jq -r '.fullName')"
    fi

    if [[ -z "$SELECTED_REPO_FULL" ]]; then
        # Auto-detect from current directory (gh will infer repo from git remote)
        SELECTED_REPO_FULL=$(gh repo view --json nameWithOwner --jq '.nameWithOwner' 2>/dev/null || true)
    fi

    [[ -z "$SELECTED_REPO_FULL" ]] && {
        log_error "Unable to resolve target repo. Provide --repo owner/name or run inside a git repo with a GitHub remote."
        return 1
    }
}

resolve_metadata_file() {
    if [[ -n "$METADATA_FILE" ]]; then
        [[ -f "$METADATA_FILE" ]] && return 0
        log_error "Metadata file not found: $METADATA_FILE"
        return 1
    fi

    local candidate_repo_dir="${SELECTED_REPO_FULL//\//-}"
    local candidates=(
        "$PROJECT_ROOT/tmp/metadata.json"
        "$PROJECT_ROOT/tmp/${candidate_repo_dir}/metadata.json"
        "$PROJECT_ROOT/tmp/${SELECTED_REPO_ID}/metadata.json"
    )

    for c in "${candidates[@]}"; do
        if [[ -n "$c" && -f "$c" ]]; then
            METADATA_FILE="$c"
            return 0
        fi
    done

    if [[ "$METADATA_REQUIRED" == "true" ]]; then
        log_error "Metadata file not found. Provide --metadata-file or generate via sync-helper."
        return 1
    fi

    log_warning "Metadata file not found. Continuing without metadata validations."
    return 0
}

load_metadata() {
    if [[ -z "$METADATA_FILE" ]]; then
        METADATA_JSON="{}"
        return 0
    fi

    METADATA_JSON=$(jq -c '.' "$METADATA_FILE" 2>/dev/null || echo '{}')

    ENFORCE_LABEL_ALLOWLIST=$(echo "$METADATA_JSON" | jq -r '.validation.enforceLabelAllowlist // false')
    TIMING_AFTER_PAI=$(echo "$METADATA_JSON" | jq -r '.timing.afterPaiSeconds // 0')
    TIMING_AFTER_CHILDREN=$(echo "$METADATA_JSON" | jq -r '.timing.afterChildrenSeconds // 0')
    TIMING_AFTER_LINK=$(echo "$METADATA_JSON" | jq -r '.timing.afterLinkSeconds // 0')
    ENFORCE_PAI_CONTENT_MATCH=$(echo "$METADATA_JSON" | jq -r '.validation.enforcePaiContentMatch // false')

    local allowlist_count
    allowlist_count=$(echo "$METADATA_JSON" | jq -r '.labels.allowed | length' 2>/dev/null || echo 0)
    if [[ "$ENFORCE_LABEL_ALLOWLIST" == "true" && "$allowlist_count" -eq 0 ]]; then
        log_error "Label allowlist enforcement enabled but labels.allowed is empty in metadata."
        return 1
    fi
    return 0
}

compute_plan_hash() {
    local plan_file="$1"
    PLAN_HASH=$(node -e "const fs=require('fs');const crypto=require('crypto');const data=fs.readFileSync('${plan_file}');console.log(crypto.createHash('sha1').update(data).digest('hex'));" 2>/dev/null || echo "")
    if [[ -z "$PLAN_HASH" ]]; then
        log_error "Failed to compute plan hash"
        return 1
    fi
    return 0
}

validate_labels_allowlist() {
    local hierarchy_file="$1"
    if [[ "$ENFORCE_LABEL_ALLOWLIST" != "true" ]]; then
        return 0
    fi

    node -e "
    const fs = require('fs');
    const items = JSON.parse(fs.readFileSync('$hierarchy_file', 'utf8')).items || [];
    const metadata = JSON.parse(fs.readFileSync('$METADATA_FILE', 'utf8'));
    const allowed = new Set((metadata.labels && metadata.labels.allowed || []).map(l => l.toLowerCase()));
    const tagRe = /\[(label|labels):([^\]]+)\]/gi;
    const invalid = new Set();
    for (const item of items) {
      const text = item.title || '';
      let m;
      while ((m = tagRe.exec(text)) !== null) {
        const labels = m[2].split(',').map(v => v.trim()).filter(Boolean);
        for (const label of labels) {
          if (!allowed.has(label.toLowerCase())) invalid.add(label);
        }
      }
    }
    if (invalid.size) {
      console.error('Invalid labels found:', Array.from(invalid).join(', '));
      process.exit(2);
    }
    "
    if [[ $? -ne 0 ]]; then
        log_error "Label allowlist validation failed."
        return 1
    fi

    log_success "Label allowlist validation passed"
    return 0
}

parse_project_spec() {
    local spec="$1"
    PROJECT_OWNER="${spec%/*}"
    PROJECT_NUMBER="${spec#*/}"
    [[ -z "$PROJECT_OWNER" || -z "$PROJECT_NUMBER" || "$PROJECT_NUMBER" == "$spec" ]] && return 1
    [[ ! "$PROJECT_NUMBER" =~ ^[0-9]+$ ]] && return 1
    return 0
}

resolve_project_id() {
    # If explicitly set, use it.
    if [[ -n "$PROJECT_ID" ]]; then
        echo "$PROJECT_ID"
        return 0
    fi

    # CLI spec: owner/number
    if [[ -n "$PROJECT_SPEC" ]]; then
        parse_project_spec "$PROJECT_SPEC" || {
            log_error "Invalid --project value. Expected <ownerOrOrg>/<number> (e.g. Axodus/23)."
            return 1
        }

        # Try org project first, then user project.
        local id
        id=$(gh api graphql \
            -f query='query($login:String!,$number:Int!){organization(login:$login){projectV2(number:$number){id}}}' \
            -f login="$PROJECT_OWNER" -F number="$PROJECT_NUMBER" --jq '.data.organization.projectV2.id' 2>/dev/null || true)
        if [[ -z "$id" || "$id" == "null" ]]; then
            id=$(gh api graphql \
                -f query='query($login:String!,$number:Int!){user(login:$login){projectV2(number:$number){id}}}' \
                -f login="$PROJECT_OWNER" -F number="$PROJECT_NUMBER" --jq '.data.user.projectV2.id' 2>/dev/null || true)
        fi

        [[ -z "$id" || "$id" == "null" ]] && { log_error "Failed to resolve ProjectV2 id for $PROJECT_SPEC"; return 1; }
        PROJECT_ID="$id"
        echo "$PROJECT_ID"
        return 0
    fi

    # Config fallback (only if a repo id was selected)
    if [[ -n "$SELECTED_REPO_ID" ]]; then
        local repo_config
        repo_config=$(jq --arg id "$SELECTED_REPO_ID" '.repositories[] | select(.id == $id)' "$CONFIG_FILE" 2>/dev/null || true)
        local cfg_id
        cfg_id=$(echo "$repo_config" | jq -r '.project.id // empty' 2>/dev/null || true)
        if [[ -n "$cfg_id" ]]; then
            PROJECT_ID="$cfg_id"
            echo "$PROJECT_ID"
            return 0
        fi
    fi

    log_error "ProjectV2 not configured. Provide --project <ownerOrOrg>/<number> or --project-id <nodeId>."
    return 1
}

# State management
save_state() {
    local stage=$1
    local data_str=$2
    mkdir -p "$OUTPUT_DIR"
    
    # Escape JSON properly
    local escaped_data=$(echo "$data_str" | jq -c '.')
    
    if [[ -f "$STATE_FILE" ]]; then
        jq --arg stage "$stage" --argjson data "$escaped_data" \
           '.stages[$stage] = $data | .lastStage = ($stage | tonumber) | .timestamp = now' \
           "$STATE_FILE" > "$STATE_FILE.tmp" && mv "$STATE_FILE.tmp" "$STATE_FILE"
    else
        jq -n --arg stage "$stage" --argjson data "$escaped_data" \
           '{stages: {($stage): $data}, lastStage: ($stage | tonumber), timestamp: now, version: "2.0"}' \
           > "$STATE_FILE"
    fi
}

get_stage_data() {
    local stage=$1
    [[ -f "$STATE_FILE" ]] && jq -r ".stages[\"$stage\"] // {}" "$STATE_FILE" 2>/dev/null || echo "{}"
}

get_last_completed_stage() {
    [[ -f "$STATE_FILE" ]] && jq -r '.lastStage // 0' "$STATE_FILE" || echo "0"
}

# STAGE 1
stage_setup() {
    log_stage "1" "SETUP - Configuration & Environment Validation"
    mkdir -p "$OUTPUT_DIR"
    
    [[ ! -f "$CONFIG_FILE" ]] && { log_error "Config not found: $CONFIG_FILE"; return 1; }
    log_success "Config found"
    
    jq empty "$CONFIG_FILE" 2>/dev/null || { log_error "Invalid JSON"; return 1; }
    log_success "Valid JSON"
    
    command -v gh &> /dev/null || { log_error "gh CLI not found"; return 1; }
    log_success "gh CLI found"
    
    gh auth status &>/dev/null || { log_error "Not authenticated"; return 1; }
    log_success "Authenticated"
    
    command -v jq &> /dev/null || { log_error "jq not found"; return 1; }
    log_success "jq found"
    
    local org
    org=$(jq -r '.github.organization // empty' "$CONFIG_FILE" 2>/dev/null || true)
    [[ -z "$org" ]] && org="${SELECTED_REPO_FULL%%/*}"
    [[ -z "$org" || "$org" == "$SELECTED_REPO_FULL" ]] && org="(auto)"
    log_info "Organization: $org"
    
    save_state "1" '{"completed": true, "org": "'$org'"}'
    log_success "STAGE 1 complete"
    return 0
}

# STAGE 2
stage_prepare() {
    log_stage "2" "PREPARE - Parse Plans and Build Hierarchy"
    
    local setup_data=$(get_stage_data "1")
    [[ $(echo "$setup_data" | jq -r '.completed // false') != "true" ]] && { log_error "STAGE 1 not completed"; return 1; }
    
    resolve_repo_full || return 1

    local repo_full_name="$SELECTED_REPO_FULL"
    local repo_name="${repo_full_name#*/}"
    local docs_path=""
    local repo_config=""

    if [[ -n "$SELECTED_REPO_ID" ]]; then
        repo_config=$(jq --arg id "$SELECTED_REPO_ID" '.repositories[] | select(.id == $id)' "$CONFIG_FILE" 2>/dev/null || true)
        docs_path=$(echo "$repo_config" | jq -r '.docsPath // "./docs/plans"' 2>/dev/null || true)
    fi
    
    log_info "Repository: $repo_full_name"
    log_info "Plan: $SELECTED_PLAN"
    
    local plan_file=""
    if [[ -n "$SELECTED_PLAN_FILE" ]]; then
        plan_file="$SELECTED_PLAN_FILE"
    else
        [[ -z "$docs_path" ]] && {
            log_error "Plan file resolution requires either --plan-file <path> or a configured repo id via --repo <id>."
            return 1
        }
        plan_file="$PROJECT_ROOT/../$repo_name/$docs_path/$SELECTED_PLAN"
    fi

    [[ ! -f "$plan_file" ]] && { log_error "Plan not found: $plan_file"; return 1; }
    log_success "Plan found"

    resolve_metadata_file || return 1
    load_metadata || return 1
    compute_plan_hash "$plan_file" || return 1
    
    local hierarchy_file="$OUTPUT_DIR/hierarchy.json"
    log_info "Parsing..."
    
    node -e "
    const fs = require('fs');
    const content = fs.readFileSync('$plan_file', 'utf-8');
    const lines = content.split('\\n');
    const items = [];
    let idCounter = 1;
    
    lines.forEach((line, idx) => {
        const match = line.match(/^(\s*)- \[ \] (.+)/);
        if (match) {
            const indent = match[1].length;
            const title = match[2].trim();
            const level = Math.floor(indent / 2);
            items.push({
                id: idCounter++,
                title: title,
                level: level,
                line: idx + 1
            });
        }
    });
    
    const output = {
        source: '$SELECTED_PLAN',
        repository: '$repo_full_name',
        totalItems: items.length,
        items: items,
        metadata: { parsedAt: new Date().toISOString() }
    };
    
    fs.writeFileSync('$hierarchy_file', JSON.stringify(output, null, 2));
    console.log(JSON.stringify({success: true, itemCount: items.length}));
    " || return 1
    
    local item_count=$(jq -r '.totalItems' "$hierarchy_file")
    log_success "Parsed $item_count items"

    validate_labels_allowlist "$hierarchy_file" || return 1
    
    save_state "2" '{"completed": true, "hierarchyFile": "'$hierarchy_file'", "itemCount": '$item_count', "repository": "'$repo_full_name'", "planFile": "'$plan_file'", "planHash": "'$PLAN_HASH'", "metadataFile": "'$METADATA_FILE'"}'
    log_success "STAGE 2 complete"
    return 0
}

# STAGE 3
stage_create_pai() {
    log_stage "3" "CREATE PAI - Generate Parent Issue (Epic)"
    
    local prep_data=$(get_stage_data "2")
    [[ $(echo "$prep_data" | jq -r '.completed // false') != "true" ]] && { log_error "STAGE 2 not completed"; return 1; }
    
    local repo_full=$(echo "$prep_data" | jq -r '.repository')
    local item_count=$(echo "$prep_data" | jq -r '.itemCount')
    
    log_info "Repository: $repo_full"
    log_info "Sub-items: $item_count"
    
    local labels=""
    local assignee=""
    if [[ -n "$SELECTED_REPO_ID" ]]; then
        local repo_config
        repo_config=$(jq --arg id "$SELECTED_REPO_ID" '.repositories[] | select(.id == $id)' "$CONFIG_FILE" 2>/dev/null || true)
        labels=$(echo "$repo_config" | jq -r '.metadata.defaultLabels | join(",")' 2>/dev/null || true)
        assignee=$(echo "$repo_config" | jq -r '.metadata.defaultAssignee // empty' 2>/dev/null || true)
    fi
    
    local pai_title="[EPIC] Implementation: $SELECTED_PLAN"
    local plan_hash
    plan_hash=$(echo "$prep_data" | jq -r '.planHash // empty')
    local pai_body="# Implementation Plan

**Source:** \`$SELECTED_PLAN\`  
**Total Tasks:** $item_count  
**Generated:** $(date +'%Y-%m-%d %H:%M:%S')

${plan_hash:+**Plan Hash:** $plan_hash}

---

_Generated by E2E Flow v2.0_"
    
    log_info "Creating PAI..."
    
    local pai_number
    if [[ -n "$PARENT_ISSUE_NUMBER" ]]; then
        # Use existing parent
        if [[ "$DRY_RUN" == "true" ]]; then
            log_warning "[DRY-RUN] Would use existing PAI #$PARENT_ISSUE_NUMBER"
            pai_number="$PARENT_ISSUE_NUMBER"
        else
            gh issue view "$PARENT_ISSUE_NUMBER" --repo "$repo_full" --json number --jq '.number' >/dev/null 2>&1 || {
                log_error "Parent issue #$PARENT_ISSUE_NUMBER not found in $repo_full"
                return 1
            }
            pai_number="$PARENT_ISSUE_NUMBER"
            log_success "Using existing PAI: #$pai_number"
        fi

        if [[ "$DRY_RUN" != "true" && "$TIMING_AFTER_PAI" -gt 0 ]]; then
            log_info "Waiting ${TIMING_AFTER_PAI}s for indexing..."
            sleep "$TIMING_AFTER_PAI"
        fi

        save_state "3" '{"completed": true, "paiNumber": '$pai_number', "repository": "'$repo_full'", "created": false}'
        log_success "STAGE 3 complete - PAI #$pai_number"
        return 0
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        log_warning "[DRY-RUN] Would create PAI"
        pai_number=""
    else
        local create_output=$(gh issue create \
            --repo "$repo_full" \
            --title "$pai_title" \
            --body "$pai_body" \
            ${labels:+--label "$labels"} \
            ${assignee:+--assignee "$assignee"} \
            2>&1)
        
        [[ $? -ne 0 ]] && { log_error "Failed to create PAI: $create_output"; return 1; }
        
        # Extract issue number from URL - multiple methods for robustness
        pai_number=$(echo "$create_output" | grep -oP 'issues/\K\d+' | head -n1)
        
        # Fallback: try JSON output
        if [[ -z "$pai_number" ]]; then
            pai_number=$(gh issue view --repo "$repo_full" --json number --jq '.number' "$(echo "$create_output" | grep -oP 'https://[^\s]+')" 2>/dev/null)
        fi
        
        # Final validation
        if [[ -z "$pai_number" || "$pai_number" == "null" ]]; then
            log_error "Failed to extract PAI issue number from: $create_output"
            return 1
        fi
        
        log_success "PAI created: #$pai_number"
        log_info "URL: $(echo "$create_output" | grep -oP 'https://[^\s]+')"

        audit_log "issue_create" '{"kind":"parent","number":'$pai_number',"url":"'$(echo "$create_output" | grep -oP 'https://[^\s]+' | head -n1)'"}'

        if [[ "$DRY_RUN" != "true" && "$TIMING_AFTER_PAI" -gt 0 ]]; then
            log_info "Waiting ${TIMING_AFTER_PAI}s for indexing..."
            sleep "$TIMING_AFTER_PAI"
        fi
    fi
    
    if [[ -z "$pai_number" ]]; then
        save_state "3" '{"completed": true, "paiNumber": null, "repository": "'$repo_full'", "simulated": true}'
        log_success "STAGE 3 complete (DRY-RUN simulated)"
    else
        save_state "3" '{"completed": true, "paiNumber": '$pai_number', "repository": "'$repo_full'", "created": true}'
        log_success "STAGE 3 complete - PAI #$pai_number"
    fi
    return 0
}

# STAGE 4
stage_create_children() {
    log_stage "4" "CREATE CHILDREN - Generate Sub-Issues"
    
    local pai_data=$(get_stage_data "3")
    [[ $(echo "$pai_data" | jq -r '.completed // false') != "true" ]] && { log_error "STAGE 3 not completed"; return 1; }
    
    local pai_number
    pai_number=$(echo "$pai_data" | jq -r '.paiNumber // empty')
    local repo_full=$(echo "$pai_data" | jq -r '.repository')
    
    local prep_data=$(get_stage_data "2")
    local hierarchy_file=$(echo "$prep_data" | jq -r '.hierarchyFile')
    local item_count=$(echo "$prep_data" | jq -r '.itemCount')
    
    [[ -z "$pai_number" && "$DRY_RUN" != "true" ]] && { log_error "PAI number missing. Run STAGE 3 or provide --parent-number."; return 1; }
    log_info "PAI: #${pai_number:-N/A}"
    log_info "Creating $item_count sub-issues..."
    
    local items=$(jq -c '.items[]' "$hierarchy_file")
    local counter=1
    
    echo "$items" | while IFS= read -r item; do
        local item_id=$(echo "$item" | jq -r '.id')
        local item_title=$(echo "$item" | jq -r '.title')
        
        log_info "[$counter/$item_count] $item_title"
        
        local issue_body=""
        if [[ "$INCLUDE_PARENT_IN_BODY" == "true" && -n "$pai_number" ]]; then
            issue_body="**Parent:** #$pai_number

---

$item_title

---

_Item #$item_id - Generated by E2E Flow v2.0_"
        else
            issue_body="$item_title

---

_Item #$item_id - Generated by E2E Flow v2.0_"
        fi
        
        local issue_number
        if [[ "$DRY_RUN" == "true" ]]; then
            issue_number=""
        else
            # CRITICAL: Check for existing issue before creating
            local existing_number
            existing_number=$(check_existing_issue "$repo_full" "$item_title")

            if [[ -n "$existing_number" ]]; then
                issue_number="$existing_number"
                log_info "Reusing existing issue #$issue_number"
                audit_log "issue_reuse" '{"kind":"child","number":'$issue_number',"title":'"$(echo "$item_title" | jq -Rs '.')"'}'
            else
                local create_output=$(gh issue create \
                    --repo "$repo_full" \
                    --title "$item_title" \
                    --body "$issue_body" \
                    2>&1)
                
                # Extract issue number - more robust
                issue_number=$(echo "$create_output" | grep -oP 'issues/\K\d+' | head -n1)
                
                if [[ -z "$issue_number" ]]; then
                    log_warning "Failed to extract issue number for: $item_title"
                    continue
                fi
                
                log_success "Created #$issue_number"

                audit_log "issue_create" '{"kind":"child","number":'$issue_number',"title":'"$(echo "$item_title" | jq -Rs '.')"',"url":"'$(echo "$create_output" | grep -oP 'https://[^\s]+' | head -n1)'"}'
            fi
        fi
        
        echo "{\"id\": $item_id, \"number\": ${issue_number:-null}, \"title\": \"$(echo "$item_title" | sed 's/"/\\"/g')\"}" >> "$OUTPUT_DIR/created-issues.jsonl"
        
        counter=$((counter + 1))
        sleep 0.5
    done
    
    jq -s '.' "$OUTPUT_DIR/created-issues.jsonl" > "$OUTPUT_DIR/created-issues.json"
    rm -f "$OUTPUT_DIR/created-issues.jsonl"
    
    local created_count=$(jq 'length' "$OUTPUT_DIR/created-issues.json")
    log_success "Created $created_count sub-issues"

    if [[ "$DRY_RUN" != "true" && "$TIMING_AFTER_CHILDREN" -gt 0 ]]; then
        log_info "Waiting ${TIMING_AFTER_CHILDREN}s for indexing..."
        sleep "$TIMING_AFTER_CHILDREN"
    fi
    
    save_state "4" '{"completed": true, "createdCount": '$created_count', "issuesFile": "'$OUTPUT_DIR'/created-issues.json"}'
    log_success "STAGE 4 complete"
    return 0
}

# STAGE 5
stage_link_hierarchy() {
    log_stage "5" "LINK HIERARCHY - Create Relationships"
    
    local pai_data
    pai_data=$(get_stage_data "3")

    local repo_full
    repo_full=$(echo "$pai_data" | jq -r '.repository // empty')
    if [[ -z "$repo_full" ]]; then
        resolve_repo_full || return 1
        repo_full="$SELECTED_REPO_FULL"
    fi

    local pai_number
    pai_number=$(echo "$pai_data" | jq -r '.paiNumber // empty')
    [[ -n "$PARENT_ISSUE_NUMBER" ]] && pai_number="$PARENT_ISSUE_NUMBER"
    [[ -z "$pai_number" ]] && { log_error "PAI number missing. Provide --parent-number or complete STAGE 3."; return 1; }

    local issues_file=""
    if [[ -n "$CHILDREN_FILE" ]]; then
        issues_file="$CHILDREN_FILE"
    else
        local children_data
        children_data=$(get_stage_data "4")
        [[ $(echo "$children_data" | jq -r '.completed // false') != "true" ]] && { log_error "STAGE 4 not completed. Provide --children-file to run Stage 5 standalone."; return 1; }
        issues_file=$(echo "$children_data" | jq -r '.issuesFile')
    fi
    
    log_info "Linking sub-issues to PAI #$pai_number via GraphQL addSubIssue..."

    local owner="${repo_full%/*}"
    local repo="${repo_full#*/}"

    local link_count=0
    local skip_count=0
    local fail_count=0

    if [[ "$DRY_RUN" != "true" ]]; then
        local pai_id
        pai_id=$(gh api graphql -f query='query($owner:String!,$repo:String!,$number:Int!){repository(owner:$owner,name:$repo){issue(number:$number){id}}}' \
            -f owner="$owner" -f repo="$repo" -F number="$pai_number" --jq '.data.repository.issue.id' 2>/dev/null)

        [[ -z "$pai_id" || "$pai_id" == "null" ]] && { log_error "Failed to resolve PAI node id for #$pai_number"; return 1; }

        while IFS= read -r issue; do
            local issue_number
            issue_number=$(echo "$issue" | jq -r '.number')

            log_info "Linking #$issue_number as sub-issue..."

            local child_json
            child_json=$(gh api graphql -f query='query($owner:String!,$repo:String!,$number:Int!){repository(owner:$owner,name:$repo){issue(number:$number){id parent{number}}}}' \
                -f owner="$owner" -f repo="$repo" -F number="$issue_number" --jq '.data.repository.issue' 2>/dev/null)

            local child_id
            child_id=$(echo "$child_json" | jq -r '.id')

            local current_parent
            current_parent=$(echo "$child_json" | jq -r '.parent.number // empty')

            if [[ -z "$child_id" || "$child_id" == "null" ]]; then
                log_error "Failed to resolve node id for #$issue_number"
                fail_count=$((fail_count + 1))
                continue
            fi

            if [[ -n "$current_parent" && "$current_parent" == "$pai_number" ]]; then
                log_info "Already linked (#$issue_number parent is #$pai_number)"
                skip_count=$((skip_count + 1))
                continue
            fi

            if [[ -n "$current_parent" && "$current_parent" != "$pai_number" && "$REPLACE_PARENT" != "true" ]]; then
                log_warning "Skipping (#$issue_number already has parent #$current_parent). Set REPLACE_PARENT=true to override."
                fail_count=$((fail_count + 1))
                continue
            fi

            local replace_parent_value
            replace_parent_value=$([[ "$REPLACE_PARENT" == "true" ]] && echo true || echo false)

            local resp
            resp=$(gh api graphql \
                -f query='mutation($issueId:ID!,$subIssueId:ID!,$replaceParent:Boolean){addSubIssue(input:{issueId:$issueId,subIssueId:$subIssueId,replaceParent:$replaceParent}){issue{number} subIssue{number}}}' \
                -f issueId="$pai_id" \
                -f subIssueId="$child_id" \
                -F replaceParent="$replace_parent_value" \
                2>&1)

            if echo "$resp" | jq -e '.data.addSubIssue.subIssue.number' >/dev/null 2>&1; then
                log_success "Linked #$issue_number"
                link_count=$((link_count + 1))

                audit_log "subissue_link" '{"parent":'$pai_number',"child":'$issue_number',"replaceParent":'$replace_parent_value'}'
            else
                local msg
                msg=$(echo "$resp" | jq -r '.errors[0].message // empty' 2>/dev/null)
                if [[ -n "$msg" ]] && echo "$msg" | grep -qi 'already'; then
                    log_info "Already linked (#$issue_number)"
                    skip_count=$((skip_count + 1))
                else
                    log_error "Failed to link #$issue_number: ${msg:-$resp}"
                    fail_count=$((fail_count + 1))
                fi
            fi

            sleep 0.3
        done < <(jq -c '.[]' "$issues_file")
    else
        while IFS= read -r issue; do
            local issue_number
            issue_number=$(echo "$issue" | jq -r '.number')
            log_warning "[DRY-RUN] Would link #$issue_number as sub-issue of #$pai_number"
        done < <(jq -c '.[]' "$issues_file")
    fi

    log_success "Sub-issue linking complete (linked=$link_count, skipped=$skip_count, failed=$fail_count)"

    if [[ "$DRY_RUN" != "true" && "$TIMING_AFTER_LINK" -gt 0 ]]; then
        log_info "Waiting ${TIMING_AFTER_LINK}s for indexing..."
        sleep "$TIMING_AFTER_LINK"
    fi

    save_state "5" '{"completed": true, "linkedCount": '$link_count', "skippedCount": '$skip_count', "failedCount": '$fail_count'}'
    log_success "STAGE 5 complete"
    return 0
}

# STAGE 6
stage_sync_projectv2() {
    log_stage "6" "SYNC PROJECTV2 - Metadata"

    if [[ "$ENABLE_PROJECT_SYNC" != "true" ]]; then
        log_warning "ProjectV2 sync disabled. Enable with --project <ownerOrOrg>/<number> and --enable-project-sync."
        save_state "6" '{"completed": true, "enabled": false, "note": "Skipped"}'
        log_success "STAGE 6 complete"
        return 0
    fi

    resolve_repo_full || return 1

    local project_id
    project_id=$(resolve_project_id) || return 1

    local issues_file=""
    if [[ -n "$CHILDREN_FILE" ]]; then
        issues_file="$CHILDREN_FILE"
    else
        local children_data
        children_data=$(get_stage_data "4")
        [[ $(echo "$children_data" | jq -r '.completed // false') != "true" ]] && { log_error "STAGE 4 not completed. Provide --children-file for Stage 6 standalone."; return 1; }
        issues_file=$(echo "$children_data" | jq -r '.issuesFile')
    fi

    local owner="${SELECTED_REPO_FULL%/*}"
    local repo="${SELECTED_REPO_FULL#*/}"
    local added=0
    local skipped=0
    local failed=0

    log_info "Adding issues to ProjectV2 ($project_id)..."

    while IFS= read -r issue; do
        local issue_number
        issue_number=$(echo "$issue" | jq -r '.number')
        [[ -z "$issue_number" || "$issue_number" == "null" ]] && { skipped=$((skipped + 1)); continue; }

        local content_id
        content_id=$(gh api graphql \
            -f query='query($owner:String!,$repo:String!,$number:Int!){repository(owner:$owner,name:$repo){issue(number:$number){id}}}' \
            -f owner="$owner" -f repo="$repo" -F number="$issue_number" --jq '.data.repository.issue.id' 2>/dev/null || true)

        if [[ -z "$content_id" || "$content_id" == "null" ]]; then
            log_error "Failed to resolve issue node id for #$issue_number"
            failed=$((failed + 1))
            continue
        fi

        local resp
        resp=$(gh api graphql \
            -f query='mutation($projectId:ID!,$contentId:ID!){addProjectV2ItemById(input:{projectId:$projectId,contentId:$contentId}){item{id}}}' \
            -f projectId="$project_id" -f contentId="$content_id" 2>&1)

        if echo "$resp" | jq -e '.data.addProjectV2ItemById.item.id' >/dev/null 2>&1; then
            log_success "Added #$issue_number"
            added=$((added + 1))
            audit_log "project_add_item" '{"projectId":"'$project_id'","issue":'$issue_number'}'
        else
            local msg
            msg=$(echo "$resp" | jq -r '.errors[0].message // empty' 2>/dev/null)
            if [[ -n "$msg" ]] && echo "$msg" | grep -qi 'already'; then
                log_info "Already in project (#$issue_number)"
                skipped=$((skipped + 1))
            else
                log_error "Failed to add #$issue_number to project: ${msg:-$resp}"
                failed=$((failed + 1))
            fi
        fi

        sleep 0.2
    done < <(jq -c '.[]' "$issues_file")

    log_success "ProjectV2 sync complete (added=$added, skipped=$skipped, failed=$failed)"
    save_state "6" '{"completed": true, "enabled": true, "projectId": "'$project_id'", "added": '$added', "skipped": '$skipped', "failed": '$failed'}'
    log_success "STAGE 6 complete"
    return 0
}

# STAGE 7
stage_progress_tracking() {
    log_stage "7" "PROGRESS TRACKING - Checklist"
    
    local children_data=$(get_stage_data "4")
    [[ $(echo "$children_data" | jq -r '.completed // false') != "true" ]] && { log_error "STAGE 4 not completed"; return 1; }
    
    local pai_data=$(get_stage_data "3")
    local pai_number=$(echo "$pai_data" | jq -r '.paiNumber')
    local repo_full=$(echo "$pai_data" | jq -r '.repository')
    local issues_file=$(echo "$children_data" | jq -r '.issuesFile')
    local total_count=$(jq 'length' "$issues_file")

    local prep_data
    prep_data=$(get_stage_data "2")
    local plan_hash
    plan_hash=$(echo "$prep_data" | jq -r '.planHash // empty')
    
    local simulated
    simulated=$(echo "$pai_data" | jq -r '.simulated // false')
    [[ "$simulated" == "true" ]] && { log_warning "DRY-RUN simulated run. Skipping PAI body updates."; }

    log_info "Generating checklist..."
    
    local checklist_file="$OUTPUT_DIR/progress-tracking.md"
    
    cat > "$checklist_file" << EOF
## Progress Tracking

**Total:** $total_count  
**Completed:** 0 / $total_count (0%)

---

EOF
    
    jq -r '.[] | "- [ ] [#\(.number)](https://github.com/'$repo_full'/issues/\(.number)) \(.title)"' "$issues_file" >> "$checklist_file"
    
    log_success "Checklist generated"
    
    if [[ "$DRY_RUN" != "true" && "$simulated" != "true" ]]; then
        log_info "Updating PAI..."
        local current_body=$(gh issue view "$pai_number" --repo "$repo_full" --json body --jq '.body')
        echo "$current_body

---

$(cat "$checklist_file")" | gh issue edit "$pai_number" --repo "$repo_full" --body-file - &>/dev/null
        log_success "PAI updated"

        if [[ "$ENFORCE_PAI_CONTENT_MATCH" == "true" ]]; then
            if [[ -z "$plan_hash" ]]; then
                log_error "Plan hash missing; cannot verify PAI content."
                return 1
            fi
            local updated_body
            updated_body=$(gh issue view "$pai_number" --repo "$repo_full" --json body --jq '.body')
            echo "$updated_body" | grep -Fq "$plan_hash" || {
                log_error "PAI content validation failed (plan hash not found)."
                return 1
            }
            log_success "PAI content validation passed"
        fi
    fi
    
    save_state "7" '{"completed": true, "checklistFile": "'$checklist_file'"}'
    log_success "STAGE 7 complete"
    return 0
}

# STAGE 8
stage_reporting() {
    log_stage "8" "REPORTING - Audit Trail"
    
    local pai_data=$(get_stage_data "3")
    local children_data=$(get_stage_data "4")
    
    local pai_number=$(echo "$pai_data" | jq -r '.paiNumber // empty')
    local repo_full=$(echo "$pai_data" | jq -r '.repository // empty')
    local created_count=$(echo "$children_data" | jq -r '.createdCount')
    
    log_info "Generating report..."
    
    local report_file="$OUTPUT_DIR/e2e-execution-report.md"
    
    cat > "$report_file" << EOF
# E2E Flow Execution Report

**Generated:** $(date +'%Y-%m-%d %H:%M:%S')  
**Repository:** $repo_full  
**Plan:** ${SELECTED_PLAN_FILE:-$SELECTED_PLAN}

---

## Summary

- âœ… PAI: #$pai_number
- âœ… Sub-Issues: $created_count
- âœ… Linked
- âš ï¸  ProjectV2: Manual sync

---

**URL:** https://github.com/$repo_full/issues/$pai_number
EOF
    
    log_success "Report: $report_file"
    
    echo ""
    log_stage "âœ¨" "COMPLETE"
    echo ""
    log_success "PAI: #$pai_number"
    log_success "Sub-Issues: $created_count"
    echo ""
    log_info "https://github.com/$repo_full/issues/$pai_number"
    echo ""
    
    save_state "8" '{"completed": true, "reportFile": "'$report_file'"}'
    log_success "Done! ðŸŽ‰"
    return 0
}

# Navigation
show_navigation_menu() {
    local current=$1
    local stage_name=${STAGE_NAMES[$current-1]:-"UNKNOWN"}
    echo ""
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}  Stage $current: $stage_name${NC}"
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo "  [c] Continue  [r] Re-run  [s] State  [q] Quit"
    [[ $current -gt 1 ]] && echo "  [b] Back"
    echo ""
    read -p "Choice: " choice
    echo "$choice"
}

run_stage() {
    case $1 in
        1) stage_setup ;;
        2) stage_prepare ;;
        3) stage_create_pai ;;
        4) stage_create_children ;;
        5) stage_link_hierarchy ;;
        6) stage_sync_projectv2 ;;
        7) stage_progress_tracking ;;
        8) stage_reporting ;;
        *) log_error "Invalid stage"; return 1 ;;
    esac
}

show_current_state() {
    log_info "State:"
    for i in {1..8}; do
        local completed=$(get_stage_data "$i" | jq -r '.completed // false')
        local status="âŒ"
        [[ "$completed" == "true" ]] && status="âœ…"
        echo "  $status Stage $i (${STAGE_NAMES[$i-1]})"
    done
    echo ""
}

# Main
main() {
    echo -e "${MAGENTA}"
    cat << 'EOF'
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   E2E FLOW - ISSUE HIERARCHY GENERATOR                    â•‘
â•‘                              Version 2.0                                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo -e "${NC}"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
                        --repo) SELECTED_REPO="$2"; parse_repo_input "$2"; shift 2 ;;
                        --repo-id) SELECTED_REPO_ID="$2"; SELECTED_REPO_FULL=""; shift 2 ;;
                        --plan) SELECTED_PLAN="$2"; shift 2 ;;
                        --plan-file) SELECTED_PLAN_FILE="$2"; shift 2 ;;
                        --parent-number) PARENT_ISSUE_NUMBER="$2"; shift 2 ;;
                        --children-file) CHILDREN_FILE="$2"; shift 2 ;;
                        --replace-parent) REPLACE_PARENT=true; shift ;;
                        --include-parent-in-body) INCLUDE_PARENT_IN_BODY=true; shift ;;
                        --no-include-parent-in-body) INCLUDE_PARENT_IN_BODY=false; shift ;;
                        --project) PROJECT_SPEC="$2"; shift 2 ;;
                        --project-id) PROJECT_ID="$2"; shift 2 ;;
                        --enable-project-sync) ENABLE_PROJECT_SYNC=true; shift ;;
                        --metadata-file) METADATA_FILE="$2"; shift 2 ;;
                        --allow-missing-metadata) METADATA_REQUIRED=false; shift ;;
            --config) CONFIG_FILE="$2"; shift 2 ;;
            --dry-run) DRY_RUN=true; shift ;;
            --stage) CURRENT_STAGE="$2"; RUN_SINGLE_STAGE=true; shift 2 ;;
            --resume) CURRENT_STAGE=$(($(get_last_completed_stage) + 1)); shift ;;
            --non-interactive) INTERACTIVE=false; shift ;;
                        --help)
                                cat << EOF
Usage: $0 [options]

Targets:
    --repo <owner/name>            Target repository (recommended)
    --repo <id> | --repo-id <id>   Config repository id (back-compat)

Inputs:
    --plan <filename>              Plan filename resolved via config docsPath (interactive mode)
    --plan-file <path>             Absolute/relative path to plan file (portable)
    --parent-number <n>            Use existing parent issue instead of creating one
    --children-file <path>         JSON array file: [{"number":123}, ...] (enables standalone Stage 5/6)
    --metadata-file <path>         Path to metadata.json produced by sync-helper
    --allow-missing-metadata        Continue without metadata validations

Sub-issues:
    --replace-parent               Replace existing parent when linking sub-issues

ProjectV2:
    --project <ownerOrOrg>/<n>     Target ProjectV2 by owner and number (e.g. Axodus/23)
    --project-id <nodeId>          Target ProjectV2 by node id
    --enable-project-sync          Enable Stage 6 to add issues to ProjectV2

Execution:
    --stage <n>                    Run a single stage (non-interactive recommended)
    --resume                       Resume from last completed stage
    --dry-run                      No GitHub writes
    --non-interactive              Run without navigation prompts
EOF
                                exit 0
                                ;;
            *) log_error "Unknown: $1"; exit 1 ;;
        esac
    done
    
    [[ -z "$SELECTED_REPO" && -z "$SELECTED_REPO_ID" && -z "$SELECTED_REPO_FULL" ]] && {
        log_prompt "Repository:"
        jq -r '.repositories[] | "  [\(.id)] \(.fullName)"' "$CONFIG_FILE"
        read -p "ID: " SELECTED_REPO
        parse_repo_input "$SELECTED_REPO"
    }

    resolve_repo_full || exit 1
    
    [[ -z "$SELECTED_PLAN" && -z "$SELECTED_PLAN_FILE" ]] && {
        log_prompt "Plan:"
        echo "  [1] PLAN.md  [2] SPRINT.md  [3] Custom"
        read -p "Choice: " plan_choice
        case $plan_choice in
            1) SELECTED_PLAN="PLAN.md" ;;
            2) SELECTED_PLAN="SPRINT.md" ;;
            3) read -p "Filename: " SELECTED_PLAN ;;
            *) SELECTED_PLAN="SPRINT.md" ;;
        esac
    }
    
    log_info "Repo: $SELECTED_REPO_FULL"
    [[ -n "$SELECTED_PLAN_FILE" ]] && log_info "Plan file: $SELECTED_PLAN_FILE" || log_info "Plan: $SELECTED_PLAN"
    [[ -n "$PARENT_ISSUE_NUMBER" ]] && log_info "Parent: #$PARENT_ISSUE_NUMBER"
    [[ -n "$CHILDREN_FILE" ]] && log_info "Children file: $CHILDREN_FILE"
    [[ -n "$METADATA_FILE" ]] && log_info "Metadata file: $METADATA_FILE"
    [[ "$DRY_RUN" == "true" ]] && log_warning "DRY-RUN MODE"
    
    if [[ "$INTERACTIVE" == "true" ]]; then
        while [[ $CURRENT_STAGE -le 8 ]]; do
            run_stage $CURRENT_STAGE && {
                [[ $CURRENT_STAGE -eq 8 ]] && break
                choice=$(show_navigation_menu $CURRENT_STAGE)
                case $choice in
                    c|C|"") CURRENT_STAGE=$((CURRENT_STAGE + 1)) ;;
                    b|B) [[ $CURRENT_STAGE -gt 1 ]] && CURRENT_STAGE=$((CURRENT_STAGE - 1)) ;;
                    r|R) : ;;
                    s|S) show_current_state ;;
                    q|Q) exit 0 ;;
                    *) CURRENT_STAGE=$((CURRENT_STAGE + 1)) ;;
                esac
            } || {
                log_error "Stage failed"
                read -p "Retry? [y/N]: " retry
                [[ "$retry" =~ ^[Yy]$ ]] || exit 1
            }
        done
    else
        if [[ "$RUN_SINGLE_STAGE" == "true" ]]; then
            run_stage $CURRENT_STAGE || exit 1
        else
            for stage in $(seq $CURRENT_STAGE 8); do
                run_stage $stage || exit 1
            done
        fi
    fi
    
    log_success "E2E Flow complete! ðŸŽ‰"
}

main "$@"
