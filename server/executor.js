#!/usr/bin/env node
/* eslint-env node */
/* global require, console, process */
// Server-side executor (engine):
// - Reads engine-input.json generated by client/prepare.js
// - Creates/updates issues in mzfshark/* repos (idempotent via stableId)
// - Optionally attaches issues to ProjectV2 and updates estimate field

const fs = require('fs');
const path = require('path');
const { execFileSync } = require('child_process');

function readJson(p) { return JSON.parse(fs.readFileSync(p, 'utf8')); } // nosemgrep
function writeJson(p, obj) { fs.mkdirSync(path.dirname(p), { recursive: true }); fs.writeFileSync(p, JSON.stringify(obj, null, 2)); } // nosemgrep

function ghApi(args) {
	try {
		const out = execFileSync('gh', ['api', ...args], { encoding: 'utf8' });
		return JSON.parse(out);
	} catch (e) {
		if (e.stdout) {
			try { return JSON.parse(e.stdout.toString()); } catch (_) {}
		}
		throw e;
	}
}

function ghExec(args) {
	return execFileSync('gh', ['api', ...args], { encoding: 'utf8' });
}

function sleepMs(ms) {
	if (!ms || ms <= 0) return;
	// Avoid async refactor; Block the event loop briefly for rate-limit backoff.
	// This is acceptable for a CLI tool.
	Atomics.wait(new Int32Array(new SharedArrayBuffer(4)), 0, 0, ms);
}

function repoIsAllowed(repo) {
	// Allow mzfshark/* and Axodus/* repos
	return repo && (repo.startsWith('mzfshark/') || repo.startsWith('Axodus/'));
}

function normalizeLabels(labels, extra = []) {
	const combined = [...(Array.isArray(labels) ? labels : []), ...extra];
	return Array.from(new Set(combined.map((l) => String(l).trim()).filter(Boolean)));
}

// --- Title helpers (repo prefix + #TYPE-NNN pattern) ---
function getRepoName(fullRepo) {
	if (!fullRepo) return '';
	const parts = String(fullRepo).split('/');
	return parts.length === 2 ? parts[1] : String(fullRepo);
}

function findExplicitId(originalText) {
	if (!originalText) return null;
	const t = String(originalText).trim();
	// Matches TYPE-NNN or TYPE_NNN at the start (2+ digits on the number)
	const m = t.match(/^([A-Za-z]+)[-_](\d{2,})\b/);
	if (!m) return null;
	const type = m[1].toUpperCase();
	const num = m[2];
	return `${type}-${num}`;
}

function stripLeadingId(originalText) {
	if (!originalText) return '';
	// Remove the leading TYPE-NNN / TYPE_NNN and trailing separators like ":", "-", or spaces
	return String(originalText).trim().replace(/^([A-Za-z]+)[-_](\d{2,})\b[:\-\s]*/, '').trim();
}

function stripInlineShortcodes(originalText) {
	if (!originalText) return '';
	// Remove inline metadata shortcodes like: [priority:high] [estimate:2h] [labels:foo,bar]
	// Keep bracketed human prefixes like "[Backend]" intact by only stripping tags that contain ":".
	return String(originalText)
		.replace(/\[[A-Za-z][A-Za-z0-9_-]*:[^\]]+\]/g, '')
		.replace(/\s{2,}/g, ' ')
		.trim();
}

function buildIssueTitle(fullRepo, originalText) {
	const repo = getRepoName(fullRepo);
	const explicitId = findExplicitId(originalText);
	const rest = stripInlineShortcodes(stripLeadingId(originalText));
	const prefix = explicitId ? `[${repo} | #${explicitId}]` : `[${repo}]`;
	const combined = rest ? `${prefix} ${rest}` : `${prefix}`;
	return combined.trim();
}

function extractStableIdFromBody(body) {
	if (!body) return null;
	const m = String(body).match(/\bStableId\s*:\s*([0-9a-f]{16,64})\b/i);
	return m ? m[1] : null;
}

const stableIdIndexCache = {};

function loadStableIdIndex(repo) {
	if (stableIdIndexCache[repo]) return stableIdIndexCache[repo];
	const index = {};
	let page = 1;
	let hasMore = true;
	while (hasMore) {
		let items;
		try {
			// Avoid Search API (prone to secondary rate limits). List issues by label instead.
			items = ghApi([
				`repos/${repo}/issues`,
				'-X',
				'GET',
				'-f',
				'state=all',
				'-f',
				'labels=sync-md',
				'-f',
				'per_page=100',
				'-f',
				`page=${page}`,
			]);
		} catch (e) {
			// Fall back to empty index; callers may still use Search as last resort.
			console.warn('[WARN] could not pre-load issues for stableId index:', e.message.substring(0, 120));
			break;
		}
		if (!Array.isArray(items) || items.length === 0) break;
		for (const issue of items) {
			// Skip PRs returned by the issues endpoint.
			if (issue && issue.pull_request) continue;
			const stableId = extractStableIdFromBody(issue.body);
			if (!stableId) continue;
			index[stableId] = issue;
		}
		if (items.length < 100) {
			hasMore = false;
			break;
		}
		page += 1;
	}
	stableIdIndexCache[repo] = index;
	return index;
}

function findIssueByStableId(repo, stableId) {
	const idx = loadStableIdIndex(repo);
	if (idx && idx[stableId]) {
		const hit = idx[stableId];
		console.log('[DEBUG] Found existing issue (index):', hit.number, 'for', stableId.substring(0, 10));
		return hit;
	}

	// Last resort: Search API. This may hit secondary rate limits; backoff and retry once.
	const q = `repo:${repo} StableId:${stableId}`;
	for (let attempt = 1; attempt <= 2; attempt++) {
		try {
			const res = ghApi(['search/issues', '-X', 'GET', '-f', `q=${q}`]);
			if (res && res.total_count && res.items && res.items.length) {
				console.log('[DEBUG] Found existing issue (search):', res.items[0].number, 'for', stableId.substring(0, 10));
				return res.items[0];
			}
			return null;
		} catch (e) {
			const msg = String(e.message || '');
			if (msg.includes('rate limit') || msg.includes('secondary rate limit') || msg.includes('HTTP 403')) {
				console.warn('[WARN] Search rate-limited; backing off before retry.');
				sleepMs(1500 * attempt);
				continue;
			}
			if (!msg.includes('HTTP 404')) {
				console.warn('[WARN] search issues failed:', msg.substring(0, 120));
			}
			return null;
		}
	}
	return null;
}

function createIssue(repo, title, body, labels) {
	const args = [`repos/${repo}/issues`, '-f', `title=${title}`, '-f', `body=${body}`];
	for (const l of labels || []) args.push('-f', `labels[]=${l}`);
	try {
		const out = ghApi(args);
		return out;
	} catch (e) {
		if (e.message && e.message.includes('rate limit')) {
			throw new Error('RATE_LIMIT: ' + e.message.substring(0, 100));
		}
		throw e;
	}
}

function updateIssue(repo, number, title, body, labels) {
	const args = [`repos/${repo}/issues/${number}`, '-X', 'PATCH', '-f', `title=${title}`, '-f', `body=${body}`];        
	for (const l of labels || []) args.push('-f', `labels[]=${l}`);
	const out = ghApi(args);
	return out;
}

function graphql(query, variables) {
	// NOTE: `gh api graphql` does not reliably support passing variables as `variables=@file`.
	// Instead, pass variables individually using `-F name=value`.
	// This helper only supports flat primitives (string/number/boolean). For complex inputs,
	// use inline GraphQL mutations.
	const args = ['api', 'graphql', '-f', `query=${query}`];
	if (variables && typeof variables === 'object') {
		for (const [key, value] of Object.entries(variables)) {
			const t = typeof value;
			if (value == null || (t !== 'string' && t !== 'number' && t !== 'boolean')) {
				throw new Error(`graphql(): unsupported variable type for ${key} (expected primitive)`);
			}
			args.push('-F', `${key}=${value}`);
		}
	}
	const out = execFileSync('gh', args, { encoding: 'utf8' });
	return JSON.parse(out);
}

const ownerTypeCache = {};

function getOwnerType(login) {
	if (!login) return null;
	if (ownerTypeCache[login]) return ownerTypeCache[login];
	try {
		// REST is the simplest way to distinguish User vs Organization without GraphQL errors.
		const data = ghApi([`users/${login}`]);
		const t = data && data.type ? String(data.type) : null;
		ownerTypeCache[login] = t;
		return t;
	} catch (e) {
		return null;
	}
}

function getViewerLogin() {
	try {
		const res = execFileSync('gh', ['api', 'graphql', '-f', 'query={ viewer { login } }'], { encoding: 'utf8' });
		const data = JSON.parse(res);
		return data && data.data && data.data.viewer && data.data.viewer.login ? data.data.viewer.login : null;
	} catch (e) {
		return null;
	}
}

function resolveProjectNodeIdFromViewer(number) {
	const q = `query($number:Int!){ viewer{ projectV2(number:$number){ id } } }`;
	const res = execFileSync('gh', ['api', 'graphql', '-f', `query=${q}`, '-F', `number=${number}`], { encoding: 'utf8' });
	const data = JSON.parse(res);
	return data.data.viewer.projectV2.id;
}

function resolveProjectNodeIdForUser(login, number) {
	const q = `query($login:String!,$number:Int!){ user(login:$login){ projectV2(number:$number){ id } } }`;
	const res = execFileSync('gh', ['api', 'graphql', '-f', `query=${q}`, '-F', `login=${login}`, '-F', `number=${number}`], { encoding: 'utf8' });
	const data = JSON.parse(res);
	return data.data.user.projectV2.id;
}

function resolveProjectNodeIdForOrg(login, number) {
	const q = `query($login:String!,$number:Int!){ organization(login:$login){ projectV2(number:$number){ id } } }`;
	const res = execFileSync('gh', ['api', 'graphql', '-f', `query=${q}`, '-F', `login=${login}`, '-F', `number=${number}`], { encoding: 'utf8' });
	const data = JSON.parse(res);
	return data.data.organization.projectV2.id;
}

function parseProjectMirrorPath(pathStr) {
	// Formats supported:
	//  - user/<login>/projects/<number>
	//  - org/<login>/projects/<number>
	//  - viewer/projects/<number>
	if (!pathStr || typeof pathStr !== 'string') return null;
	const parts = pathStr.split('/').map(s => s.trim()).filter(Boolean);
	if (parts.length === 3 && parts[0] === 'viewer' && parts[1] === 'projects') {
		return { scope: 'viewer', number: parseInt(parts[2], 10) };
	}
	if (parts.length === 4 && (parts[0] === 'user' || parts[0] === 'org') && parts[2] === 'projects') {
		return { scope: parts[0], login: parts[1], number: parseInt(parts[3], 10) };
	}
	return null;
}

function ensureProjectItem(projectNodeId, issueNodeId) {
	if (!projectNodeId || typeof projectNodeId !== 'string' || !projectNodeId.startsWith('PVT_')) {
		console.error('Invalid projectNodeId for addProjectV2ItemById:', projectNodeId);
		return null;
	}
	if (!issueNodeId || typeof issueNodeId !== 'string' || !issueNodeId.startsWith('I_')) {
		console.error('Invalid issueNodeId for addProjectV2ItemById:', issueNodeId);
		return null;
	}
	try {
		const inline = `mutation{ addProjectV2ItemById(input:{projectId:\"${projectNodeId}\",contentId:\"${issueNodeId}\"}){ item{ id } } }`;
		const out = execFileSync('gh', ['api', 'graphql', '-f', `query=${inline}`], { encoding: 'utf8' });
		const data = JSON.parse(out);
		if (data && data.data && data.data.addProjectV2ItemById && data.data.addProjectV2ItemById.item) {
			return data.data.addProjectV2ItemById.item.id;
		}
		console.error('addProjectV2ItemById: unexpected response', JSON.stringify(data));
		return null;
	} catch (e) {
		console.error('addProjectV2ItemById failed:', e.message);
		return null;
	}
}

function escapeGraphQLString(value) {
	return String(value)
		.replace(/\\/g, '\\\\')
		.replace(/"/g, '\\"')
		.replace(/\r/g, '\\r')
		.replace(/\n/g, '\\n');
}

function formatProjectFieldValueInput(valueObj) {
	if (!valueObj || typeof valueObj !== 'object') return null;
	if (Object.prototype.hasOwnProperty.call(valueObj, 'number')) {
		return `{number:${valueObj.number}}`;
	}
	if (Object.prototype.hasOwnProperty.call(valueObj, 'date')) {
		return `{date:"${escapeGraphQLString(valueObj.date)}"}`;
	}
	if (Object.prototype.hasOwnProperty.call(valueObj, 'text')) {
		return `{text:"${escapeGraphQLString(valueObj.text)}"}`;
	}
	if (Object.prototype.hasOwnProperty.call(valueObj, 'singleSelectOptionId')) {
		return `{singleSelectOptionId:"${escapeGraphQLString(valueObj.singleSelectOptionId)}"}`;
	}
	if (Object.prototype.hasOwnProperty.call(valueObj, 'iterationId')) {
		return `{iterationId:"${escapeGraphQLString(valueObj.iterationId)}"}`;
	}
	return null;
}

function updateProjectEstimate(projectNodeId, itemId, fieldId, hours) {
	if (!projectNodeId || typeof projectNodeId !== 'string' || !projectNodeId.startsWith('PVT_')) {
		console.error('Invalid projectNodeId for updateProjectEstimate:', projectNodeId);
		return false;
	}
	if (!itemId || typeof itemId !== 'string') {
		console.error('Invalid itemId for updateProjectEstimate:', itemId);
		return false;
	}
	// The GraphQL API expects a global node ID for fieldId (not a numeric UI id).
	if (fieldId && /^[0-9]+$/.test(String(fieldId))) {
		console.error('estimateFieldId appears numeric. ProjectV2 GraphQL requires a global node id for fieldId. Skipping estimate update. Provided fieldId:', fieldId);
		return false;
	}
	try {
		const inline = `mutation{ updateProjectV2ItemFieldValue(input:{projectId:\"${projectNodeId}\",itemId:\"${itemId}\",fieldId:\"${fieldId}\",value:{number:${hours}}}){ projectV2Item{ id } } }`;
		const out = execFileSync('gh', ['api', 'graphql', '-f', `query=${inline}`], { encoding: 'utf8' });
		const data = JSON.parse(out);
		if (data && data.data && data.data.updateProjectV2ItemFieldValue) return true;
		console.error('updateProjectEstimate: unexpected response', JSON.stringify(data));
		return false;
	} catch (e) {
		console.error('updateProjectEstimate failed:', e.message);
		return false;
	}
}

function findSingleSelectOptionId(fieldNodeId, optionName) {
	if (!fieldNodeId || typeof fieldNodeId !== 'string') return null;
	try {
		// NOTE: ProjectV2 single select options are returned as a plain list (not a connection).
		const q = `query($id:ID!){ node(id:$id){ __typename ... on ProjectV2SingleSelectField{ options{ id name } } } }`;
		const res = graphql(q, { id: fieldNodeId });
		const options = res && res.data && res.data.node && Array.isArray(res.data.node.options) ? res.data.node.options : [];
		for (const n of options) {
			if (String(n.name || '').toLowerCase() === String(optionName || '').toLowerCase()) return n.id;
		}
		return null;
	} catch (e) {
		console.error('findSingleSelectOptionId failed for', fieldNodeId, e.message);
		return null;
	}
}

function updateProjectField(projectNodeId, itemId, fieldId, valueObj) {
	if (!fieldId) return false;
	if (/^[0-9]+$/.test(String(fieldId))) {
		console.warn('Project field id appears numeric. GraphQL requires global node id. Skipping field update for', fieldId);
		return false;
	}
	const valueInput = formatProjectFieldValueInput(valueObj);
	if (!valueInput) {
		console.warn('Unsupported ProjectV2 field value shape. Skipping field update for', fieldId);
		return false;
	}
	try {
		const inline = `mutation{ updateProjectV2ItemFieldValue(input:{projectId:\"${projectNodeId}\",itemId:\"${itemId}\",fieldId:\"${fieldId}\",value:${valueInput}}){ projectV2Item{ id } } }`;
		const out = execFileSync('gh', ['api', 'graphql', '-f', `query=${inline}`], { encoding: 'utf8' });
		const data = JSON.parse(out);
		if (data && data.data && data.data.updateProjectV2ItemFieldValue) return true;
		console.error('updateProjectField: unexpected response', JSON.stringify(data));
		return false;
	} catch (e) {
		console.error('updateProjectField failed:', e.message);
		return false;
	}
}

// Cache for project fields
const projectFieldsCache = {};

function loadProjectFields(projectNodeId) {
	if (projectFieldsCache[projectNodeId]) return projectFieldsCache[projectNodeId];
	try {
		const q = `query($id:ID!){ node(id:$id){ __typename ... on ProjectV2{ fields(first:100){ nodes{ ... on ProjectV2Field { id databaseId name dataType } ... on ProjectV2IterationField { id databaseId name dataType } ... on ProjectV2SingleSelectField { id databaseId name dataType } __typename } } } } }`;
		const res = graphql(q, { id: projectNodeId });
		const nodes = res && res.data && res.data.node && res.data.node.fields && res.data.node.fields.nodes ? res.data.node.fields.nodes : [];
		projectFieldsCache[projectNodeId] = nodes;
		return nodes;
	} catch (e) {
		console.error('loadProjectFields failed for', projectNodeId, e.message);
		projectFieldsCache[projectNodeId] = [];
		return [];
	}
}

function loadProjectFieldsForOrg(ownerLogin, projectNumber) {
	try {
		const q = `query($owner:String!,$number:Int!){ organization(login:$owner){ projectV2(number:$number){ fields(first:100){ nodes{ ... on ProjectV2Field { id name dataType } ... on ProjectV2IterationField { id name dataType } ... on ProjectV2SingleSelectField { id name dataType } __typename } } } } }`;
		const res = graphql(q, { owner: ownerLogin, number: projectNumber });
		const nodes = res && res.data && res.data.organization && res.data.organization.projectV2 && res.data.organization.projectV2.fields && res.data.organization.projectV2.fields.nodes ? res.data.organization.projectV2.fields.nodes : [];
		return nodes;
	} catch (e) {
		console.error('loadProjectFieldsForOrg failed for', ownerLogin, projectNumber, e.message);
		return [];
	}
}

function loadProjectFieldsForUser(ownerLogin, projectNumber) {
	try {
		const q = `query($login:String!,$number:Int!){ user(login:$login){ projectV2(number:$number){ fields(first:100){ nodes{ ... on ProjectV2Field { id name dataType } ... on ProjectV2IterationField { id name dataType } ... on ProjectV2SingleSelectField { id name dataType } __typename } } } } }`;
		const res = graphql(q, { login: ownerLogin, number: projectNumber });
		const nodes = res && res.data && res.data.user && res.data.user.projectV2 && res.data.user.projectV2.fields && res.data.user.projectV2.fields.nodes ? res.data.user.projectV2.fields.nodes : [];
		return nodes;
	} catch (e) {
		console.error('loadProjectFieldsForUser failed for', ownerLogin, projectNumber, e.message);
		return [];
	}
}

function loadProjectFieldsForOwner(ownerLogin, projectNumber) {
	const t = getOwnerType(ownerLogin);
	if (t === 'Organization') return loadProjectFieldsForOrg(ownerLogin, projectNumber);
	if (t === 'User') return loadProjectFieldsForUser(ownerLogin, projectNumber);
	// Unknown type: try user first (common), then org.
	const u = loadProjectFieldsForUser(ownerLogin, projectNumber);
	if (u && u.length) return u;
	return loadProjectFieldsForOrg(ownerLogin, projectNumber);
}

function resolveProjectFieldNodeIdByProject(ownerLogin, projectNumber, candidate) {
	if (!ownerLogin || !projectNumber || !candidate) return null;
	const fields = loadProjectFieldsForOwner(ownerLogin, projectNumber);
	if (/^[0-9]+$/.test(String(candidate))) {
		const num = parseInt(candidate, 10);
		for (const f of fields) {
			if (f.databaseId == num || String(f.databaseId) === String(num)) return f.id;
		}
	}
	const cname = String(candidate).toLowerCase();
	for (const f of fields) {
		if ((f.name || '').toLowerCase().includes(cname)) return f.id;
	}
	return null;
}

function canResolveByNodeId(projectNodeId) {
	return !!(projectNodeId && typeof projectNodeId === 'string' && projectNodeId.startsWith('PVT_'));
}

function resolveProjectFieldNodeId(projectNodeId, candidate) {
	if (!projectNodeId || !candidate) return null;
	// if candidate already looks like a global id, return it
	if (String(candidate).startsWith('PFV_') || String(candidate).startsWith('PVT_') || String(candidate).startsWith('PVF_') || String(candidate).startsWith('PVT')) return candidate;
	const fields = loadProjectFields(projectNodeId);
	// numeric databaseId
	if (/^[0-9]+$/.test(String(candidate))) {
		const num = parseInt(candidate, 10);
		for (const f of fields) {
			if (f.databaseId == num) return f.id;
		}
	}
	// match by name (case-insensitive contains)
	const cname = String(candidate).toLowerCase();
	for (const f of fields) {
		if ((f.name || '').toLowerCase().includes(cname)) return f.id;
	}
	return null;
}

async function main() {
	const args = process.argv.slice(2);
	const dryRun = args.includes('--dry-run') || args.includes('--dryrun');
	const configIndex = args.indexOf('--config');
	const inputIndex = args.indexOf('--input');
	
	let inputPath;
	let outputPath;
	let mirrorProjectPath = null; // e.g., 'user/mzfshark/projects/15'
	let mirrorEstimateFieldId = null;
	
	// Support both --config (new per-repo format) and --input (old format)
	if (configIndex >= 0 && args[configIndex + 1]) {
		// Load config to get input/output paths
		const configPath = args[configIndex + 1];
		if (!fs.existsSync(configPath)) { // nosemgrep
			console.error('Config file not found:', configPath);
			process.exit(2);
		}
		const cfg = readJson(configPath);
		inputPath = cfg.outputs?.engineInputPath || './tmp/engine-input.json';
		outputPath = cfg.outputs?.engineOutputPath || './tmp/engine-output.json';
		// Optional mirror project configuration in config file
		if (cfg.projectMirror && cfg.projectMirror.path) {
			mirrorProjectPath = cfg.projectMirror.path;
		}
		if (cfg.projectMirror && cfg.projectMirror.estimateFieldId) {
		mirrorEstimateFieldId = cfg.projectMirror.estimateFieldId;
		}
	}

	// Load engine input JSON (support --input flag)
	if (inputIndex >= 0 && args[inputIndex + 1]) {
		inputPath = args[inputIndex + 1];
	}
	if (!inputPath) inputPath = './tmp/engine-input.json';
	if (!fs.existsSync(inputPath)) { // nosemgrep
		console.error('Engine input file not found:', inputPath);
		process.exit(2);
	}
	let engine;
	try {
		engine = readJson(inputPath);
	} catch (e) {
		console.error('Failed to read engine input:', e.message);
		process.exit(2);
	}

	// Derived runtime variables
	const owner = engine.owner || engine.org || getViewerLogin() || 'mzfshark';
	const defaultAssignee = engine.defaults && engine.defaults.assignee ? engine.defaults.assignee : null;
	if (!outputPath) outputPath = './tmp/engine-output.json';
	const output = { generatedAt: new Date().toISOString(), results: [] };


function findProjectItemIdForIssue(projectNodeId, issueNodeId) {
	if (!projectNodeId || !issueNodeId) return null;
	try {
		// Initial page
		const q0 = `query($projectId:ID!){ node(id:$projectId){ __typename ... on ProjectV2{ items(first:100){ nodes{ id content{ __typename ... on Issue{ id } ... on PullRequest{ id } } } pageInfo{ hasNextPage endCursor } } } } }`;
		let res = graphql(q0, { projectId: projectNodeId });
		let nodes = res && res.data && res.data.node && res.data.node.items && res.data.node.items.nodes ? res.data.node.items.nodes : [];
		for (const n of nodes) {
			if (n && n.content && n.content.id === issueNodeId) return n.id;
		}
		let pageInfo = res && res.data && res.data.node && res.data.node.items && res.data.node.items.pageInfo ? res.data.node.items.pageInfo : null;
		while (pageInfo && pageInfo.hasNextPage) {
			const qn = `query($projectId:ID!,$after:String){ node(id:$projectId){ __typename ... on ProjectV2{ items(first:100, after:$after){ nodes{ id content{ __typename ... on Issue{ id } ... on PullRequest{ id } } } pageInfo{ hasNextPage endCursor } } } } }`;
			res = graphql(qn, { projectId: projectNodeId, after: pageInfo.endCursor });
			nodes = res && res.data && res.data.node && res.data.node.items && res.data.node.items.nodes ? res.data.node.items.nodes : [];
			for (const n of nodes) {
				if (n && n.content && n.content.id === issueNodeId) return n.id;
			}
			pageInfo = res && res.data && res.data.node && res.data.node.items && res.data.node.items.pageInfo ? res.data.node.items.pageInfo : null;
		}
		return null;
	} catch (e) {
		console.warn('findProjectItemIdForIssue failed:', e.message);
		return null;
	}
}
	// Resolve main project node id when possible.
	// Prefer a pre-resolved node id from engine-input.json to avoid extra API calls and failures.
	let viewerProjectNodeId = null;
	const projectCfg = engine.project || {};
	if (projectCfg && (projectCfg.projectNodeId || projectCfg.nodeId)) {
		viewerProjectNodeId = projectCfg.projectNodeId || projectCfg.nodeId;
	} else if (projectCfg && projectCfg.number) {
		try {
			viewerProjectNodeId = resolveProjectNodeIdFromViewer(projectCfg.number);
		} catch (e) {
			// If it's an org project, the viewer lookup fails; try organization(login) next.
			try {
				viewerProjectNodeId = resolveProjectNodeIdForOrg(owner, projectCfg.number);
			} catch (e2) {
				console.warn('Could not resolve viewer project node id:', e.message.split('\n')[0]);
			}
		}
	}

	// Resolve mirror project node id if provided via engine or config
	let mirrorProjectNodeId = null;
	// Prefer explicit engine.project.mirrorPath if present
	if (engine.project && engine.project.mirrorPath && !mirrorProjectPath) {
		mirrorProjectPath = engine.project.mirrorPath;
	}
	if (mirrorProjectPath) {
		try {
			const parsed = parseProjectMirrorPath(mirrorProjectPath);
			if (!parsed) {
				console.warn('Mirror project path unparsable:', mirrorProjectPath);
			} else if (parsed.scope === 'viewer') {
				mirrorProjectNodeId = resolveProjectNodeIdFromViewer(parsed.number);
			} else if (parsed.scope === 'user') {
				mirrorProjectNodeId = resolveProjectNodeIdForUser(parsed.login, parsed.number);
			} else if (parsed.scope === 'org') {
				mirrorProjectNodeId = resolveProjectNodeIdForOrg(parsed.login, parsed.number);
			}
		} catch (e) {
			console.warn('Could not resolve mirror project node id:', e.message.split('\n')[0]);
		}
	}

	for (const t of engine.targets || []) {
		// Handle both formats: "repo" and "owner/repo"
		const fullRepo = t.repo.includes('/') ? t.repo : `${owner}/${t.repo}`;
		console.log('\nProcessing target:', fullRepo);
		if (!repoIsAllowed(fullRepo)) {
			console.warn('Skipping target (repo not allowed):', fullRepo);
			output.results.push({ repo: fullRepo, skipped: true, reason: 'repo not allowed' });
			continue;
		}

		const repoResult = { repo: fullRepo, tasks: [] };
		const projectCfg = engine.project || {};
		// Prefer pre-resolved viewerProjectNodeId. Accept multiple possible keys for a pre-populated node id
		// (some configs use `projectNodeId` while others use `nodeId`).
		let projectNodeId = viewerProjectNodeId || (engine.project && (engine.project.nodeId || engine.project.projectNodeId || engine.project.project_node_id || engine.project.project_id));
		if (!projectNodeId && engine.project && engine.project.projectNodeId) {
			console.warn('Using legacy engine.project.projectNodeId key for project node id');
			projectNodeId = engine.project.projectNodeId;
		}

		// Build a stableId index once per repo to avoid Search API rate limits.
		loadStableIdIndex(fullRepo);

		for (const task of t.tasks || []) {
			try {
				let rawTitle = buildIssueTitle(fullRepo, task.text);
				const title = rawTitle.length > 120 ? rawTitle.slice(0, 117) + '...' : rawTitle;
				const body = `Source: ${task.file}#L${task.line}\n\nStableId: ${task.stableId}\n\n${task.text}`;
								// Normalize labels and include priority
								const labels = normalizeLabels(task.labels, ['sync-md']);
								if (task.priority) labels.push(task.priority);

								// Normalize labels: ensure a `type:` label exists
				if (!labels.some(l => /^type:/i.test(l))) {
					const text = (task.text || '').toLowerCase();
					if (text.includes('bug') || text.includes('error')) labels.push('type:bug');
					else if (text.includes('feature')) labels.push('type:feature');
					else labels.push('type:task');
				}

				let issue = findIssueByStableId(fullRepo, task.stableId);
				let created = false;
				let wouldCreate = false;
				let wouldUpdate = false;
				if (issue) {
					if (dryRun) {
						console.log('[DRY-RUN] Would update issue', issue.number, 'for', task.stableId.substring(0, 10));
						wouldUpdate = true;
					} else {
						console.log('Updating issue', issue.number, 'for', task.stableId.substring(0, 10));
						const upd = updateIssue(fullRepo, issue.number, title, body, labels.concat([]));
						issue = upd;
					}
				} else {
					if (dryRun) {
						console.log('[DRY-RUN] Would create issue for', task.stableId.substring(0, 10));
						wouldCreate = true;
						const taskResult = { stableId: task.stableId, issueNumber: null, issueNodeId: null, created: false, wouldCreate: true };
						repoResult.tasks.push(taskResult);
						continue;
					}
					console.log('Creating issue for', task.stableId.substring(0, 10));
					// assign to default assignee if available
					const assignees = defaultAssignee ? [defaultAssignee] : [];
					const createdIssue = (function(){
						try {
							const args = [`repos/${fullRepo}/issues`, '-f', `title=${title}`, '-f', `body=${body}`];
							for (const l of labels || []) args.push('-f', `labels[]=${l}`);
							for (const a of assignees) args.push('-f', `assignees[]=${a}`);
							return ghApi(args);
						} catch (e) { throw e; }
					})();
					if (!createdIssue || !createdIssue.number) {
						throw new Error('Failed to create issue: no issue number returned');
					}
					issue = createdIssue;
					created = true;
				}

				const issueNumber = issue.number;
				const issueNodeId = issue.node_id || issue.nodeId || null;

				const taskResult = { stableId: task.stableId, issueNumber, issueNodeId, created, wouldCreate, wouldUpdate };

				if (!dryRun && t.enableProjectSync && projectNodeId && issueNodeId) {
					try {
						const projectItemId = ensureProjectItem(projectNodeId, issueNodeId);
						taskResult.projectItemId = projectItemId;
						// Resolve configured fields (accept numeric ids or names) and set defaults
						const cfgFields = (engine.project && engine.project.fieldIds) || {};
						const estimateFieldCandidate = cfgFields.estimateHoursFieldId || cfgFields.estimateFieldId || null;
						const startFieldCandidate = cfgFields.startDateFieldId || cfgFields.startFieldId || null;
						const endFieldCandidate = cfgFields.endDateFieldId || cfgFields.endFieldId || null;
						const statusFieldCandidate = cfgFields.statusFieldId || null;
						const priorityFieldCandidate = cfgFields.priorityFieldId || null;

						// Prefer resolving via projectNodeId (node query). Fallback to owner/projectNumber only when node id is missing.
						const projectNumber = (engine.project && engine.project.number) || null;
						const estimateFieldNodeId = canResolveByNodeId(projectNodeId)
							? resolveProjectFieldNodeId(projectNodeId, estimateFieldCandidate)
							: (projectNumber ? resolveProjectFieldNodeIdByProject(owner, projectNumber, estimateFieldCandidate) : null);
						if (estimateFieldNodeId && task.estimateHours != null) {
							updateProjectField(projectNodeId, projectItemId, estimateFieldNodeId, { number: task.estimateHours });
						}

						// Dates: default start=today, end=+7 days when not provided
						const today = new Date();
						const yyyy = today.getUTCFullYear();
						const mm = String(today.getUTCMonth()+1).padStart(2,'0');
						const dd = String(today.getUTCDate()).padStart(2,'0');
						const startDateStr = (task.startDate && task.startDate !== 'TBD') ? task.startDate : `${yyyy}-${mm}-${dd}`;
						const end = new Date(today.getTime()); end.setUTCDate(end.getUTCDate()+7);
						const eyyyy = end.getUTCFullYear(); const emm = String(end.getUTCMonth()+1).padStart(2,'0'); const edd = String(end.getUTCDate()).padStart(2,'0');
						const endDateStr = (task.endDate && task.endDate !== 'TBD') ? task.endDate : `${eyyyy}-${emm}-${edd}`;
												const startFieldNodeId = canResolveByNodeId(projectNodeId)
													? resolveProjectFieldNodeId(projectNodeId, startFieldCandidate)
													: (projectNumber ? resolveProjectFieldNodeIdByProject(owner, projectNumber, startFieldCandidate) : null);
												if (startFieldNodeId) updateProjectField(projectNodeId, projectItemId, startFieldNodeId, { date: startDateStr });
												const endFieldNodeId = canResolveByNodeId(projectNodeId)
													? resolveProjectFieldNodeId(projectNodeId, endFieldCandidate)
													: (projectNumber ? resolveProjectFieldNodeIdByProject(owner, projectNumber, endFieldCandidate) : null);
												if (endFieldNodeId) updateProjectField(projectNodeId, projectItemId, endFieldNodeId, { date: endDateStr });

										// Status / Priority: single-select fields — map by option name
												const statusFieldNodeId = canResolveByNodeId(projectNodeId)
													? resolveProjectFieldNodeId(projectNodeId, statusFieldCandidate || 'Status')
													: (projectNumber ? resolveProjectFieldNodeIdByProject(owner, projectNumber, statusFieldCandidate || 'Status') : null);
												const priorityFieldNodeId = canResolveByNodeId(projectNodeId)
													? resolveProjectFieldNodeId(projectNodeId, priorityFieldCandidate || 'Priority')
													: (projectNumber ? resolveProjectFieldNodeIdByProject(owner, projectNumber, priorityFieldCandidate || 'Priority') : null);
						if (statusFieldNodeId) {
							const desired = (task.status || engine.defaults && engine.defaults.defaultStatus || 'Backlog');
							const optId = findSingleSelectOptionId(statusFieldNodeId, desired);
							if (optId) updateProjectField(projectNodeId, projectItemId, statusFieldNodeId, { singleSelectOptionId: optId });
						}
						if (priorityFieldNodeId) {
							const desiredPr = (task.priority || engine.defaults && engine.defaults.defaultPriority || 'low');
							const optId = findSingleSelectOptionId(priorityFieldNodeId, desiredPr);
							if (optId) updateProjectField(projectNodeId, projectItemId, priorityFieldNodeId, { singleSelectOptionId: optId });
						}
					} catch (e) {
						console.error('Project attach/update failed for', task.stableId, e.message);
					}
				}

				// Mirror into secondary project if configured
				if (!dryRun && issueNodeId && mirrorProjectNodeId) {
					try {
						const mirrorItemId = ensureProjectItem(mirrorProjectNodeId, issueNodeId);
						taskResult.mirrorProjectItemId = mirrorItemId;
						if (mirrorEstimateFieldId && task.estimateHours != null) {
							updateProjectEstimate(mirrorProjectNodeId, mirrorItemId, mirrorEstimateFieldId, task.estimateHours);
						}
					} catch (e) {
						console.error('Mirror project attach/update failed for', task.stableId, e.message);
					}
				}

				repoResult.tasks.push(taskResult);
			} catch (e) {
				const isRateLimit = e.message && e.message.includes('RATE_LIMIT');
				console.error(isRateLimit ? '[RATE_LIMIT]' : '[ERROR]', 'Failed to process task', task.stableId.substring(0, 10), e.message.substring(0, 80));
				repoResult.tasks.push({ stableId: task.stableId, error: e.message, rateLimit: isRateLimit });
				if (isRateLimit) {
					console.warn('\n⚠️  Rate limit hit. Stopping execution. Remaining tasks:', (t.tasks.length + t.subtasks.length) - repoResult.tasks.length);
					break;
				}
			}
		}

		for (const s of t.subtasks || []) {
			try {
				const parentIssue = repoResult.tasks.find(x => x.stableId === s.parentStableId);
				const parentNumber = parentIssue && parentIssue.issueNumber;
				let subRawTitle = buildIssueTitle(fullRepo, s.text);
				const title = subRawTitle.length > 120 ? subRawTitle.slice(0, 117) + '...' : subRawTitle;
				let body = `Source: ${s.file}#L${s.line}\n\nStableId: ${s.stableId}\n\n${s.text}`;
				if (parentNumber) body = `Parent: #${parentNumber}\n\n` + body;
				const labels = normalizeLabels(s.labels, ['subtask', 'sync-md']);
				if (s.priority) labels.push(s.priority);
				// Ensure subtask label + default type
				const subLabels = normalizeLabels(s.labels, ['subtask', 'sync-md']);
				if (!subLabels.some(l => /^type:/i.test(l))) {
					const stxt = (s.text || '').toLowerCase();
					if (stxt.includes('bug') || stxt.includes('error')) subLabels.push('type:bug');
					else if (stxt.includes('feature')) subLabels.push('type:feature');
					else subLabels.push('type:task');
				}
				let issue = findIssueByStableId(fullRepo, s.stableId);
				let created = false;
				let wouldCreate = false;
				let wouldUpdate = false;
				if (issue) {
					if (dryRun) {
						console.log('[DRY-RUN] Would update subtask', issue.number, 'for', s.stableId.substring(0, 10));
						wouldUpdate = true;
					} else {
						const upd = updateIssue(fullRepo, issue.number, title, body, subLabels.concat([]));
						issue = upd;
					}
				} else {
					if (dryRun) {
						console.log('[DRY-RUN] Would create subtask for', s.stableId.substring(0, 10));
						wouldCreate = true;
						const subResult = { stableId: s.stableId, issueNumber: null, issueNodeId: null, created: false, wouldCreate: true, parentStableId: s.parentStableId };
						repoResult.tasks.push(subResult);
						continue;
					}
					const assignees = defaultAssignee ? [defaultAssignee] : [];
					const createdIssue = (function(){
						try {
							const args = [`repos/${fullRepo}/issues`, '-f', `title=${title}`, '-f', `body=${body}`];
							for (const l of subLabels || []) args.push('-f', `labels[]=${l}`);
							for (const a of assignees) args.push('-f', `assignees[]=${a}`);
							return ghApi(args);
						} catch (e) { throw e; }
					})();
					if (!createdIssue || !createdIssue.number) {
						throw new Error('Failed to create subtask: no issue number returned');
					}
					issue = createdIssue;
					created = true;
				}
				const subIssueNodeId = issue.node_id || null;

				const subResult = { stableId: s.stableId, issueNumber: issue.number, issueNodeId: subIssueNodeId, created, wouldCreate, wouldUpdate, parentStableId: s.parentStableId };

				// Attach subtasks to the main project as well (not only top-level tasks).
				if (!dryRun && t.enableProjectSync && projectNodeId && subIssueNodeId) {
					try {
						const projectItemId = ensureProjectItem(projectNodeId, subIssueNodeId);
						subResult.projectItemId = projectItemId;

						const cfgFields = (engine.project && engine.project.fieldIds) || {};
						const estimateFieldCandidate = cfgFields.estimateHoursFieldId || cfgFields.estimateFieldId || null;
						const startFieldCandidate = cfgFields.startDateFieldId || cfgFields.startFieldId || null;
						const endFieldCandidate = cfgFields.endDateFieldId || cfgFields.endFieldId || null;
						const statusFieldCandidate = cfgFields.statusFieldId || null;
						const priorityFieldCandidate = cfgFields.priorityFieldId || null;
						const projectNumber = (engine.project && engine.project.number) || null;

						const estimateFieldNodeId = canResolveByNodeId(projectNodeId)
							? resolveProjectFieldNodeId(projectNodeId, estimateFieldCandidate)
							: (projectNumber ? resolveProjectFieldNodeIdByProject(owner, projectNumber, estimateFieldCandidate) : null);
						if (estimateFieldNodeId && s.estimateHours != null) {
							updateProjectField(projectNodeId, projectItemId, estimateFieldNodeId, { number: s.estimateHours });
						}

						const today = new Date();
						const yyyy = today.getUTCFullYear();
						const mm = String(today.getUTCMonth() + 1).padStart(2, '0');
						const dd = String(today.getUTCDate()).padStart(2, '0');
						const startDateStr = (s.startDate && s.startDate !== 'TBD') ? s.startDate : `${yyyy}-${mm}-${dd}`;
						const end = new Date(today.getTime());
						end.setUTCDate(end.getUTCDate() + 7);
						const eyyyy = end.getUTCFullYear();
						const emm = String(end.getUTCMonth() + 1).padStart(2, '0');
						const edd = String(end.getUTCDate()).padStart(2, '0');
						const endDateStr = (s.endDate && s.endDate !== 'TBD') ? s.endDate : `${eyyyy}-${emm}-${edd}`;

						const startFieldNodeId = canResolveByNodeId(projectNodeId)
							? resolveProjectFieldNodeId(projectNodeId, startFieldCandidate)
							: (projectNumber ? resolveProjectFieldNodeIdByProject(owner, projectNumber, startFieldCandidate) : null);
						if (startFieldNodeId) updateProjectField(projectNodeId, projectItemId, startFieldNodeId, { date: startDateStr });
						const endFieldNodeId = canResolveByNodeId(projectNodeId)
							? resolveProjectFieldNodeId(projectNodeId, endFieldCandidate)
							: (projectNumber ? resolveProjectFieldNodeIdByProject(owner, projectNumber, endFieldCandidate) : null);
						if (endFieldNodeId) updateProjectField(projectNodeId, projectItemId, endFieldNodeId, { date: endDateStr });

						const statusFieldNodeId = canResolveByNodeId(projectNodeId)
							? resolveProjectFieldNodeId(projectNodeId, statusFieldCandidate || 'Status')
							: (projectNumber ? resolveProjectFieldNodeIdByProject(owner, projectNumber, statusFieldCandidate || 'Status') : null);
						const priorityFieldNodeId = canResolveByNodeId(projectNodeId)
							? resolveProjectFieldNodeId(projectNodeId, priorityFieldCandidate || 'Priority')
							: (projectNumber ? resolveProjectFieldNodeIdByProject(owner, projectNumber, priorityFieldCandidate || 'Priority') : null);
						if (statusFieldNodeId) {
							const desired = (s.status || (engine.defaults && engine.defaults.defaultStatus) || 'Backlog');
							const optId = findSingleSelectOptionId(statusFieldNodeId, desired);
							if (optId) updateProjectField(projectNodeId, projectItemId, statusFieldNodeId, { singleSelectOptionId: optId });
						}
						if (priorityFieldNodeId) {
							const desiredPr = (s.priority || (engine.defaults && engine.defaults.defaultPriority) || 'low');
							const optId = findSingleSelectOptionId(priorityFieldNodeId, desiredPr);
							if (optId) updateProjectField(projectNodeId, projectItemId, priorityFieldNodeId, { singleSelectOptionId: optId });
						}
					} catch (e) {
						console.error('Project attach/update failed for subtask', s.stableId, e.message);
					}
				}

				// Mirror subtasks as well
				if (!dryRun && subIssueNodeId && mirrorProjectNodeId) {
					try {
						const mirrorItemId = ensureProjectItem(mirrorProjectNodeId, subIssueNodeId);
						subResult.mirrorProjectItemId = mirrorItemId;
						if (mirrorEstimateFieldId && s.estimateHours != null) {
							updateProjectEstimate(mirrorProjectNodeId, mirrorItemId, mirrorEstimateFieldId, s.estimateHours);
						}
					} catch (e) {
						console.error('Mirror project attach/update failed for subtask', s.stableId, e.message);
					}
				}

				repoResult.tasks.push(subResult);
			} catch (e) {
				const isRateLimit = e.message && e.message.includes('RATE_LIMIT');
				console.error(isRateLimit ? '[RATE_LIMIT]' : '[ERROR]', 'Failed to process subtask', s.stableId.substring(0, 10), e.message.substring(0, 80));
				repoResult.tasks.push({ stableId: s.stableId, error: e.message, parentStableId: s.parentStableId, rateLimit: isRateLimit });
				if (isRateLimit) {
					console.warn('\n⚠️  Rate limit hit on subtasks. Stopping.');
					break;
				}
			}
		}

		output.results.push(repoResult);
	}

	writeJson(outputPath, output);
	console.log('\n✓ Execution complete');
	console.log('Output written to:', outputPath);
}

main();
