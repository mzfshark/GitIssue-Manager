#!/usr/bin/env node
// Server-side executor (engine):
// - Reads engine-input.json generated by client/prepare.js
// - Creates/updates issues in mzfshark/* repos (idempotent via stableId)
// - Optionally attaches issues to ProjectV2 and updates estimate field

const fs = require('fs');
const path = require('path');
const { execFileSync } = require('child_process');

function readJson(p) { return JSON.parse(fs.readFileSync(p, 'utf8')); }
function writeJson(p, obj) { fs.mkdirSync(path.dirname(p), { recursive: true }); fs.writeFileSync(p, JSON.stringify(obj, null, 2)); }

function ghApi(args) {
	try {
		const out = execFileSync('gh', ['api', ...args], { encoding: 'utf8' });
		return JSON.parse(out);
	} catch (e) {
		if (e.stdout) {
			try { return JSON.parse(e.stdout.toString()); } catch (_) {}
		}
		throw e;
	}
}

function ghExec(args) {
	return execFileSync('gh', ['api', ...args], { encoding: 'utf8' });
}

function repoIsAllowed(repo) {
	// Allow mzfshark/* and Axodus/* repos
	return repo && (repo.startsWith('mzfshark/') || repo.startsWith('Axodus/'));
}

function normalizeLabels(labels, extra = []) {
	const combined = [...(Array.isArray(labels) ? labels : []), ...extra];
	return Array.from(new Set(combined.map((l) => String(l).trim()).filter(Boolean)));
}

// --- Title helpers (repo prefix + #TYPE-NNN pattern) ---
function getRepoName(fullRepo) {
	if (!fullRepo) return '';
	const parts = String(fullRepo).split('/');
	return parts.length === 2 ? parts[1] : String(fullRepo);
}

function findExplicitId(originalText) {
	if (!originalText) return null;
	const t = String(originalText).trim();
	// Matches TYPE-NNN or TYPE_NNN at the start (2+ digits on the number)
	const m = t.match(/^([A-Za-z]+)[-_](\d{2,})\b/);
	if (!m) return null;
	const type = m[1].toUpperCase();
	const num = m[2];
	return `${type}-${num}`;
}

function stripLeadingId(originalText) {
	if (!originalText) return '';
	// Remove the leading TYPE-NNN / TYPE_NNN and trailing separators like ":", "-", or spaces
	return String(originalText).trim().replace(/^([A-Za-z]+)[-_](\d{2,})\b[:\-\s]*/, '').trim();
}

function buildIssueTitle(fullRepo, originalText) {
	const repo = getRepoName(fullRepo);
	const explicitId = findExplicitId(originalText);
	const rest = stripLeadingId(originalText);
	const prefix = explicitId ? `[${repo} | #${explicitId}]` : `[${repo}]`;
	const combined = rest ? `${prefix} ${rest}` : `${prefix}`;
	return combined.trim();
}

function findIssueByStableId(repo, stableId) {
	const q = `repo:${repo} StableId:${stableId}`;
	try {
		const res = ghApi(['search/issues', '-f', `q=${q}`]);
		if (res && res.total_count && res.items && res.items.length) {
			console.log('[DEBUG] Found existing issue:', res.items[0].number, 'for', stableId.substring(0, 10));
			return res.items[0];
		}
		return null;
	} catch (e) {
		// 404 or search errors just mean no issue found
		if (!e.message.includes('HTTP 404')) {
			console.warn('[WARN] search issues failed:', e.message.substring(0, 80));
		}
		return null;
	}
}

function createIssue(repo, title, body, labels) {
	const args = [`repos/${repo}/issues`, '-f', `title=${title}`, '-f', `body=${body}`];
	for (const l of labels || []) args.push('-f', `labels[]=${l}`);
	try {
		const out = ghApi(args);
		return out;
	} catch (e) {
		if (e.message && e.message.includes('rate limit')) {
			throw new Error('RATE_LIMIT: ' + e.message.substring(0, 100));
		}
		throw e;
	}
}

function updateIssue(repo, number, title, body, labels) {
	const args = [`repos/${repo}/issues/${number}`, '-X', 'PATCH', '-f', `title=${title}`, '-f', `body=${body}`];        
	for (const l of labels || []) args.push('-f', `labels[]=${l}`);
	const out = ghApi(args);
	return out;
}

function graphql(query, variables) {
	// Write variables to a temp file and pass it as @file to gh to avoid shell-quoting issues
	const os = require('os');
	const tmpdir = os.tmpdir();
	const fname = path.join(tmpdir, `gitissue-graphql-vars-${Date.now()}-${Math.floor(Math.random()*10000)}.json`);
	fs.writeFileSync(fname, JSON.stringify(variables));
	try {
		const out = execFileSync('gh', ['api', 'graphql', '-f', `query=${query}`, '-f', `variables=@${fname}`], { encoding: 'utf8' });
		return JSON.parse(out);
	} finally {
		try { fs.unlinkSync(fname); } catch (e) { /* ignore cleanup errors */ }
	}
}

function getViewerLogin() {
	try {
		const res = execFileSync('gh', ['api', 'graphql', '-f', 'query={ viewer { login } }'], { encoding: 'utf8' });
		const data = JSON.parse(res);
		return data && data.data && data.data.viewer && data.data.viewer.login ? data.data.viewer.login : null;
	} catch (e) {
		return null;
	}
}

function resolveProjectNodeIdFromViewer(number) {
	const q = `query($number:Int!){ viewer{ projectV2(number:$number){ id } } }`;
	const res = execFileSync('gh', ['api', 'graphql', '-f', `query=${q}`, '-F', `number=${number}`], { encoding: 'utf8' });
	const data = JSON.parse(res);
	return data.data.viewer.projectV2.id;
}

function resolveProjectNodeIdForUser(login, number) {
	const q = `query($login:String!,$number:Int!){ user(login:$login){ projectV2(number:$number){ id } } }`;
	const res = execFileSync('gh', ['api', 'graphql', '-f', `query=${q}`, '-F', `login=${login}`, '-F', `number=${number}`], { encoding: 'utf8' });
	const data = JSON.parse(res);
	return data.data.user.projectV2.id;
}

function resolveProjectNodeIdForOrg(login, number) {
	const q = `query($login:String!,$number:Int!){ organization(login:$login){ projectV2(number:$number){ id } } }`;
	const res = execFileSync('gh', ['api', 'graphql', '-f', `query=${q}`, '-F', `login=${login}`, '-F', `number=${number}`], { encoding: 'utf8' });
	const data = JSON.parse(res);
	return data.data.organization.projectV2.id;
}

function parseProjectMirrorPath(pathStr) {
	// Formats supported:
	//  - user/<login>/projects/<number>
	//  - org/<login>/projects/<number>
	//  - viewer/projects/<number>
	if (!pathStr || typeof pathStr !== 'string') return null;
	const parts = pathStr.split('/').map(s => s.trim()).filter(Boolean);
	if (parts.length === 3 && parts[0] === 'viewer' && parts[1] === 'projects') {
		return { scope: 'viewer', number: parseInt(parts[2], 10) };
	}
	if (parts.length === 4 && (parts[0] === 'user' || parts[0] === 'org') && parts[2] === 'projects') {
		return { scope: parts[0], login: parts[1], number: parseInt(parts[3], 10) };
	}
	return null;
}

function ensureProjectItem(projectNodeId, issueNodeId) {
	const mutation = `mutation($input:AddProjectV2ItemByIdInput!){ addProjectV2ItemById(input:$input){ item{ id } } }`;
	const variables = { input: { projectId: projectNodeId, contentId: issueNodeId } };
	if (!projectNodeId || typeof projectNodeId !== 'string' || !projectNodeId.startsWith('PVT_')) {
		console.error('Invalid projectNodeId for addProjectV2ItemById:', projectNodeId);
		return null;
	}
	if (!issueNodeId || typeof issueNodeId !== 'string' || !issueNodeId.startsWith('I_')) {
		console.error('Invalid issueNodeId for addProjectV2ItemById:', issueNodeId);
		return null;
	}
	try {
		const res = graphql(mutation, variables);
		if (res && res.data && res.data.addProjectV2ItemById && res.data.addProjectV2ItemById.item) {
			return res.data.addProjectV2ItemById.item.id;
		}
		console.error('addProjectV2ItemById: unexpected response', JSON.stringify(res));
		return null;
	} catch (e) {
		console.error('addProjectV2ItemById failed (variables path):', e.message);
		// Fallback: construct inline mutation with escaped IDs (works in practice)
		try {
			const inline = `mutation{ addProjectV2ItemById(input:{projectId:\"${projectNodeId}\",contentId:\"${issueNodeId}\"}){ item{ id } } }`;
			const out = execFileSync('gh', ['api', 'graphql', '-f', `query=${inline}`], { encoding: 'utf8' });
			const data = JSON.parse(out);
			if (data && data.data && data.data.addProjectV2ItemById && data.data.addProjectV2ItemById.item) {
				return data.data.addProjectV2ItemById.item.id;
			}
			console.error('addProjectV2ItemById fallback: unexpected response', JSON.stringify(data));
			return null;
		} catch (ee) {
			console.error('addProjectV2ItemById fallback failed:', ee.message);
			return null;
		}
	}
}

function updateProjectEstimate(projectNodeId, itemId, fieldId, hours) {
	const mutation = `mutation($input:UpdateProjectV2ItemFieldValueInput!){ updateProjectV2ItemFieldValue(input:$input){ projectV2Item{ id } } }`;
	const variables = { input: { projectId: projectNodeId, itemId, fieldId, value: { number: hours } } };
	if (!projectNodeId || typeof projectNodeId !== 'string' || !projectNodeId.startsWith('PVT_')) {
		console.error('Invalid projectNodeId for updateProjectEstimate:', projectNodeId);
		return false;
	}
	if (!itemId || typeof itemId !== 'string') {
		console.error('Invalid itemId for updateProjectEstimate:', itemId);
		return false;
	}
	// The GraphQL API expects a global node ID for fieldId (not a numeric UI id).
	if (fieldId && /^[0-9]+$/.test(String(fieldId))) {
		console.error('estimateFieldId appears numeric. ProjectV2 GraphQL requires a global node id for fieldId. Skipping estimate update. Provided fieldId:', fieldId);
		return false;
	}
	try {
		graphql(mutation, variables);
		return true;
	} catch (e) {
		console.error('updateProjectEstimate failed (variables path):', e.message);
		// Fallback: inline mutation
		try {
			const inline = `mutation{ updateProjectV2ItemFieldValue(input:{projectId:\"${projectNodeId}\",itemId:\"${itemId}\",fieldId:\"${fieldId}\",value:{number:${hours}}}){ projectV2Item{ id } } }`;
			const out = execFileSync('gh', ['api', 'graphql', '-f', `query=${inline}`], { encoding: 'utf8' });
			const data = JSON.parse(out);
			if (data && data.data && data.data.updateProjectV2ItemFieldValue) return true;
			console.error('updateProjectEstimate fallback: unexpected response', JSON.stringify(data));
			return false;
		} catch (ee) {
			console.error('updateProjectEstimate fallback failed:', ee.message);
			return false;
		}
	}
}

function findSingleSelectOptionId(fieldNodeId, optionName) {
	if (!fieldNodeId || typeof fieldNodeId !== 'string') return null;
	try {
		const q = `query($id:ID!){ node(id:$id){ __typename ... on ProjectV2SingleSelectField{ options(first:100){ nodes{ id name } } } } }`;
		const res = graphql(q, { id: fieldNodeId });
		const nodes = res && res.data && res.data.node && res.data.node.options && res.data.node.options.nodes ? res.data.node.options.nodes : [];
		for (const n of nodes) {
			if (String(n.name || '').toLowerCase() === String(optionName || '').toLowerCase()) return n.id;
		}
		return null;
	} catch (e) {
		console.error('findSingleSelectOptionId failed for', fieldNodeId, e.message);
		return null;
	}
}

function updateProjectField(projectNodeId, itemId, fieldId, valueObj) {
	if (!fieldId) return false;
	if (/^[0-9]+$/.test(String(fieldId))) {
		console.warn('Project field id appears numeric. GraphQL requires global node id. Skipping field update for', fieldId);
		return false;
	}
	const mutation = `mutation($input:UpdateProjectV2ItemFieldValueInput!){ updateProjectV2ItemFieldValue(input:$input){ projectV2Item{ id } } }`;
	const variables = { input: { projectId: projectNodeId, itemId, fieldId, value: valueObj } };
	try {
		graphql(mutation, variables);
		return true;
	} catch (e) {
		console.error('updateProjectField failed (variables path):', e.message);
		try {
			const inline = `mutation{ updateProjectV2ItemFieldValue(input:{projectId:\"${projectNodeId}\",itemId:\"${itemId}\",fieldId:\"${fieldId}\",value:${JSON.stringify(valueObj)}}){ projectV2Item{ id } } }`;
			const out = execFileSync('gh', ['api', 'graphql', '-f', `query=${inline}`], { encoding: 'utf8' });
			const data = JSON.parse(out);
			if (data && data.data && data.data.updateProjectV2ItemFieldValue) return true;
			return false;
		} catch (ee) {
			console.error('updateProjectField fallback failed:', ee.message);
			return false;
		}
	}
}

// Cache for project fields
const projectFieldsCache = {};

function loadProjectFields(projectNodeId) {
	if (projectFieldsCache[projectNodeId]) return projectFieldsCache[projectNodeId];
	try {
		const q = `query($id:ID!){ node(id:$id){ __typename ... on ProjectV2{ fields(first:100){ nodes{ ... on ProjectV2Field { id databaseId name dataType } ... on ProjectV2IterationField { id databaseId name dataType } ... on ProjectV2SingleSelectField { id databaseId name dataType } __typename } } } } }`;
		const res = graphql(q, { id: projectNodeId });
		const nodes = res && res.data && res.data.node && res.data.node.fields && res.data.node.fields.nodes ? res.data.node.fields.nodes : [];
		projectFieldsCache[projectNodeId] = nodes;
		return nodes;
	} catch (e) {
		console.error('loadProjectFields failed for', projectNodeId, e.message);
		projectFieldsCache[projectNodeId] = [];
		return [];
	}
}

function loadProjectFieldsForOrg(ownerLogin, projectNumber) {
	try {
		const q = `query($owner:String!,$number:Int!){ organization(login:$owner){ projectV2(number:$number){ fields(first:100){ nodes{ ... on ProjectV2Field { id name dataType } ... on ProjectV2IterationField { id name dataType } ... on ProjectV2SingleSelectField { id name dataType } __typename } } } } }`;
		const res = graphql(q, { owner: ownerLogin, number: projectNumber });
		const nodes = res && res.data && res.data.organization && res.data.organization.projectV2 && res.data.organization.projectV2.fields && res.data.organization.projectV2.fields.nodes ? res.data.organization.projectV2.fields.nodes : [];
		return nodes;
	} catch (e) {
		console.error('loadProjectFieldsForOrg failed for', ownerLogin, projectNumber, e.message);
		return [];
	}
}

function resolveProjectFieldNodeIdByProject(ownerLogin, projectNumber, candidate) {
	if (!ownerLogin || !projectNumber || !candidate) return null;
	const fields = loadProjectFieldsForOrg(ownerLogin, projectNumber);
	if (/^[0-9]+$/.test(String(candidate))) {
		const num = parseInt(candidate, 10);
		for (const f of fields) {
			if (f.databaseId == num || String(f.databaseId) === String(num)) return f.id;
		}
	}
	const cname = String(candidate).toLowerCase();
	for (const f of fields) {
		if ((f.name || '').toLowerCase().includes(cname)) return f.id;
	}
	return null;
}

function resolveProjectFieldNodeId(projectNodeId, candidate) {
	if (!projectNodeId || !candidate) return null;
	// if candidate already looks like a global id, return it
	if (String(candidate).startsWith('PFV_') || String(candidate).startsWith('PVT_') || String(candidate).startsWith('PVF_') || String(candidate).startsWith('PVT')) return candidate;
	const fields = loadProjectFields(projectNodeId);
	// numeric databaseId
	if (/^[0-9]+$/.test(String(candidate))) {
		const num = parseInt(candidate, 10);
		for (const f of fields) {
			if (f.databaseId == num) return f.id;
		}
	}
	// match by name (case-insensitive contains)
	const cname = String(candidate).toLowerCase();
	for (const f of fields) {
		if ((f.name || '').toLowerCase().includes(cname)) return f.id;
	}
	return null;
}

async function main() {
	const args = process.argv.slice(2);
	const configIndex = args.indexOf('--config');
	const inputIndex = args.indexOf('--input');
	
	let inputPath;
	let outputPath;
	let mirrorProjectPath = null; // e.g., 'user/mzfshark/projects/15'
	let mirrorEstimateFieldId = null;
	
	// Support both --config (new per-repo format) and --input (old format)
	if (configIndex >= 0 && args[configIndex + 1]) {
		// Load config to get input/output paths
		const configPath = args[configIndex + 1];
		if (!fs.existsSync(configPath)) {
			console.error('Config file not found:', configPath);
			process.exit(2);
		}
		const cfg = readJson(configPath);
		inputPath = cfg.outputs?.engineInputPath || './tmp/engine-input.json';
		outputPath = cfg.outputs?.engineOutputPath || './tmp/engine-output.json';
		// Optional mirror project configuration in config file
		if (cfg.projectMirror && cfg.projectMirror.path) {
			mirrorProjectPath = cfg.projectMirror.path;
		}
		if (cfg.projectMirror && cfg.projectMirror.estimateFieldId) {
			mirrorEstimateFieldId = cfg.projectMirror.estimateFieldId;
		}
	} else {
		// Old format: explicit --input or default
		inputPath = (inputIndex >= 0 && args[inputIndex + 1]) ? args[inputIndex + 1] : './tmp/engine-input.json';
		outputPath = inputPath.replace('engine-input.json', 'engine-output.json');
	}

	if (!fs.existsSync(inputPath)) {
		console.error('Engine input not found:', inputPath);
		console.error('Run: npm run prepare');
		process.exit(2);
	}

	console.log('\nReading engine input:', inputPath);
	const engine = readJson(inputPath);
	const output = { ...engine, executedAt: new Date().toISOString(), results: [] };
	const owner = engine.owner || 'mzfshark';
	const defaultAssignee = getViewerLogin() || process.env.GITISSUE_DEFAULT_ASSIGNEE || 'mzfshark';

	// Resolve main viewer project node id if provided
	let viewerProjectNodeId = null;
	const projectCfg = engine.project || {};
	if (projectCfg && projectCfg.number) {
		try {
			viewerProjectNodeId = resolveProjectNodeIdFromViewer(projectCfg.number);
		} catch (e) {
			console.warn('Could not resolve viewer project node id:', e.message.split('\n')[0]);
		}
	}

	// Resolve mirror project node id if provided via engine or config
	let mirrorProjectNodeId = null;
	// Prefer explicit engine.project.mirrorPath if present
	if (engine.project && engine.project.mirrorPath && !mirrorProjectPath) {
		mirrorProjectPath = engine.project.mirrorPath;
	}
	if (mirrorProjectPath) {
		try {
			const parsed = parseProjectMirrorPath(mirrorProjectPath);
			if (!parsed) {
				console.warn('Mirror project path unparsable:', mirrorProjectPath);
			} else if (parsed.scope === 'viewer') {
				mirrorProjectNodeId = resolveProjectNodeIdFromViewer(parsed.number);
			} else if (parsed.scope === 'user') {
				mirrorProjectNodeId = resolveProjectNodeIdForUser(parsed.login, parsed.number);
			} else if (parsed.scope === 'org') {
				mirrorProjectNodeId = resolveProjectNodeIdForOrg(parsed.login, parsed.number);
			}
		} catch (e) {
			console.warn('Could not resolve mirror project node id:', e.message.split('\n')[0]);
		}
	}

	for (const t of engine.targets || []) {
		// Handle both formats: "repo" and "owner/repo"
		const fullRepo = t.repo.includes('/') ? t.repo : `${owner}/${t.repo}`;
		console.log('\nProcessing target:', fullRepo);
		if (!repoIsAllowed(fullRepo)) {
			console.warn('Skipping target (repo not allowed):', fullRepo);
			output.results.push({ repo: fullRepo, skipped: true, reason: 'repo not allowed' });
			continue;
		}

		const repoResult = { repo: fullRepo, tasks: [] };
		const projectCfg = engine.project || {};
		// Prefer pre-resolved viewerProjectNodeId. Accept multiple possible keys for a pre-populated node id
		// (some configs use `projectNodeId` while others use `nodeId`).
		let projectNodeId = viewerProjectNodeId || (engine.project && (engine.project.nodeId || engine.project.projectNodeId || engine.project.project_node_id || engine.project.project_id));
		if (!projectNodeId && engine.project && engine.project.projectNodeId) {
			console.warn('Using legacy engine.project.projectNodeId key for project node id');
			projectNodeId = engine.project.projectNodeId;
		}

		for (const task of t.tasks || []) {
			try {
				let rawTitle = buildIssueTitle(fullRepo, task.text);
				const title = rawTitle.length > 120 ? rawTitle.slice(0, 117) + '...' : rawTitle;
				const body = `Source: ${task.file}#L${task.line}\n\nStableId: ${task.stableId}\n\n${task.text}`;
								// Normalize labels and include priority
								const labels = normalizeLabels(task.labels, ['sync-md']);
								if (task.priority) labels.push(task.priority);

								// Normalize labels: ensure a `type:` label exists
				if (!labels.some(l => /^type:/i.test(l))) {
					const text = (task.text || '').toLowerCase();
					if (text.includes('bug') || text.includes('error')) labels.push('type:bug');
					else if (text.includes('feature')) labels.push('type:feature');
					else labels.push('type:task');
				}

				let issue = findIssueByStableId(fullRepo, task.stableId);
				let created = false;
				if (issue) {
					console.log('Updating issue', issue.number, 'for', task.stableId.substring(0, 10));
					const upd = updateIssue(fullRepo, issue.number, title, body, labels.concat([]));
					issue = upd;
				} else {
					console.log('Creating issue for', task.stableId.substring(0, 10));
					// assign to default assignee if available
					const assignees = defaultAssignee ? [defaultAssignee] : [];
					const createdIssue = (function(){
						try {
							const args = [`repos/${fullRepo}/issues`, '-f', `title=${title}`, '-f', `body=${body}`];
							for (const l of labels || []) args.push('-f', `labels[]=${l}`);
							for (const a of assignees) args.push('-f', `assignees[]=${a}`);
							return ghApi(args);
						} catch (e) { throw e; }
					})();
					if (!createdIssue || !createdIssue.number) {
						throw new Error('Failed to create issue: no issue number returned');
					}
					issue = createdIssue;
					created = true;
				}

				const issueNumber = issue.number;
				const issueNodeId = issue.node_id || issue.nodeId || null;

				const taskResult = { stableId: task.stableId, issueNumber, issueNodeId, created };

				if (t.enableProjectSync && projectNodeId && issueNodeId) {
					try {
						const projectItemId = ensureProjectItem(projectNodeId, issueNodeId);
						taskResult.projectItemId = projectItemId;
						// Resolve configured fields (accept numeric ids or names) and set defaults
						const cfgFields = (engine.project && engine.project.fieldIds) || {};
						const estimateFieldCandidate = cfgFields.estimateHoursFieldId || cfgFields.estimateFieldId || null;
						const startFieldCandidate = cfgFields.startDateFieldId || cfgFields.startFieldId || null;
						const endFieldCandidate = cfgFields.endDateFieldId || cfgFields.endFieldId || null;
						const statusFieldCandidate = cfgFields.statusFieldId || null;
						const priorityFieldCandidate = cfgFields.priorityFieldId || null;

						// Resolve using organization/project number when possible
						const projectNumber = (engine.project && engine.project.number) || null;
						const estimateFieldNodeId = projectNumber ? resolveProjectFieldNodeIdByProject(owner, projectNumber, estimateFieldCandidate) : resolveProjectFieldNodeId(projectNodeId, estimateFieldCandidate);
						if (estimateFieldNodeId && task.estimateHours != null) {
							updateProjectField(projectNodeId, projectItemId, estimateFieldNodeId, { number: task.estimateHours });
						}

						// Dates: default start=today, end=+7 days when not provided
						const today = new Date();
						const yyyy = today.getUTCFullYear();
						const mm = String(today.getUTCMonth()+1).padStart(2,'0');
						const dd = String(today.getUTCDate()).padStart(2,'0');
						const startDateStr = (task.startDate && task.startDate !== 'TBD') ? task.startDate : `${yyyy}-${mm}-${dd}`;
						const end = new Date(today.getTime()); end.setUTCDate(end.getUTCDate()+7);
						const eyyyy = end.getUTCFullYear(); const emm = String(end.getUTCMonth()+1).padStart(2,'0'); const edd = String(end.getUTCDate()).padStart(2,'0');
						const endDateStr = (task.endDate && task.endDate !== 'TBD') ? task.endDate : `${eyyyy}-${emm}-${edd}`;
												const startFieldNodeId = projectNumber ? resolveProjectFieldNodeIdByProject(owner, projectNumber, startFieldCandidate) : resolveProjectFieldNodeId(projectNodeId, startFieldCandidate);
												if (startFieldNodeId) updateProjectField(projectNodeId, projectItemId, startFieldNodeId, { date: startDateStr });
												const endFieldNodeId = projectNumber ? resolveProjectFieldNodeIdByProject(owner, projectNumber, endFieldCandidate) : resolveProjectFieldNodeId(projectNodeId, endFieldCandidate);
												if (endFieldNodeId) updateProjectField(projectNodeId, projectItemId, endFieldNodeId, { date: endDateStr });

						// Status / Priority: single-select fields — map by option name
												const statusFieldNodeId = projectNumber ? resolveProjectFieldNodeIdByProject(owner, projectNumber, statusFieldCandidate || 'Status') : resolveProjectFieldNodeId(projectNodeId, statusFieldCandidate || 'Status');
												const priorityFieldNodeId = projectNumber ? resolveProjectFieldNodeIdByProject(owner, projectNumber, priorityFieldCandidate || 'Priority') : resolveProjectFieldNodeId(projectNodeId, priorityFieldCandidate || 'Priority');
						if (statusFieldNodeId) {
							const desired = (task.status || engine.defaults && engine.defaults.defaultStatus || 'Backlog');
							const optId = findSingleSelectOptionId(statusFieldNodeId, desired);
							if (optId) updateProjectField(projectNodeId, projectItemId, statusFieldNodeId, { singleSelectOptionId: optId });
						}
						if (priorityFieldNodeId) {
							const desiredPr = (task.priority || engine.defaults && engine.defaults.defaultPriority || 'low');
							const optId = findSingleSelectOptionId(priorityFieldNodeId, desiredPr);
							if (optId) updateProjectField(projectNodeId, projectItemId, priorityFieldNodeId, { singleSelectOptionId: optId });
						}
					} catch (e) {
						console.error('Project attach/update failed for', task.stableId, e.message);
					}
				}

				// Mirror into secondary project if configured
				if (issueNodeId && mirrorProjectNodeId) {
					try {
						const mirrorItemId = ensureProjectItem(mirrorProjectNodeId, issueNodeId);
						taskResult.mirrorProjectItemId = mirrorItemId;
						if (mirrorEstimateFieldId && task.estimateHours != null) {
							updateProjectEstimate(mirrorProjectNodeId, mirrorItemId, mirrorEstimateFieldId, task.estimateHours);
						}
					} catch (e) {
						console.error('Mirror project attach/update failed for', task.stableId, e.message);
					}
				}

				repoResult.tasks.push(taskResult);
			} catch (e) {
				const isRateLimit = e.message && e.message.includes('RATE_LIMIT');
				console.error(isRateLimit ? '[RATE_LIMIT]' : '[ERROR]', 'Failed to process task', task.stableId.substring(0, 10), e.message.substring(0, 80));
				repoResult.tasks.push({ stableId: task.stableId, error: e.message, rateLimit: isRateLimit });
				if (isRateLimit) {
					console.warn('\n⚠️  Rate limit hit. Stopping execution. Remaining tasks:', (t.tasks.length + t.subtasks.length) - repoResult.tasks.length);
					break;
				}
			}
		}

		for (const s of t.subtasks || []) {
			try {
				const parentIssue = repoResult.tasks.find(x => x.stableId === s.parentStableId);
				const parentNumber = parentIssue && parentIssue.issueNumber;
				let subRawTitle = buildIssueTitle(fullRepo, s.text);
				const title = subRawTitle.length > 120 ? subRawTitle.slice(0, 117) + '...' : subRawTitle;
				let body = `Source: ${s.file}#L${s.line}\n\nStableId: ${s.stableId}\n\n${s.text}`;
				if (parentNumber) body = `Parent: #${parentNumber}\n\n` + body;
				const labels = normalizeLabels(s.labels, ['subtask', 'sync-md']);
				if (s.priority) labels.push(s.priority);
				// Ensure subtask label + default type
				const subLabels = normalizeLabels(s.labels, ['subtask', 'sync-md']);
				if (!subLabels.some(l => /^type:/i.test(l))) {
					const stxt = (s.text || '').toLowerCase();
					if (stxt.includes('bug') || stxt.includes('error')) subLabels.push('type:bug');
					else if (stxt.includes('feature')) subLabels.push('type:feature');
					else subLabels.push('type:task');
				}
				let issue = findIssueByStableId(fullRepo, s.stableId);
				let created = false;
				if (issue) {
					const upd = updateIssue(fullRepo, issue.number, title, body, subLabels.concat([]));
					issue = upd;
				} else {
					const assignees = defaultAssignee ? [defaultAssignee] : [];
					const createdIssue = (function(){
						try {
							const args = [`repos/${fullRepo}/issues`, '-f', `title=${title}`, '-f', `body=${body}`];
							for (const l of subLabels || []) args.push('-f', `labels[]=${l}`);
							for (const a of assignees) args.push('-f', `assignees[]=${a}`);
							return ghApi(args);
						} catch (e) { throw e; }
					})();
					if (!createdIssue || !createdIssue.number) {
						throw new Error('Failed to create subtask: no issue number returned');
					}
					issue = createdIssue;
					created = true;
				}
				const subIssueNodeId = issue.node_id || null;

				const subResult = { stableId: s.stableId, issueNumber: issue.number, issueNodeId: subIssueNodeId, created, parentStableId: s.parentStableId };

				// Mirror subtasks as well
				if (subIssueNodeId && mirrorProjectNodeId) {
					try {
						const mirrorItemId = ensureProjectItem(mirrorProjectNodeId, subIssueNodeId);
						subResult.mirrorProjectItemId = mirrorItemId;
						if (mirrorEstimateFieldId && s.estimateHours != null) {
							updateProjectEstimate(mirrorProjectNodeId, mirrorItemId, mirrorEstimateFieldId, s.estimateHours);
						}
					} catch (e) {
						console.error('Mirror project attach/update failed for subtask', s.stableId, e.message);
					}
				}

				repoResult.tasks.push(subResult);
			} catch (e) {
				const isRateLimit = e.message && e.message.includes('RATE_LIMIT');
				console.error(isRateLimit ? '[RATE_LIMIT]' : '[ERROR]', 'Failed to process subtask', s.stableId.substring(0, 10), e.message.substring(0, 80));
				repoResult.tasks.push({ stableId: s.stableId, error: e.message, parentStableId: s.parentStableId, rateLimit: isRateLimit });
				if (isRateLimit) {
					console.warn('\n⚠️  Rate limit hit on subtasks. Stopping.');
					break;
				}
			}
		}

		output.results.push(repoResult);
	}

	writeJson(outputPath, output);
	console.log('\n✓ Execution complete');
	console.log('Output written to:', outputPath);
}

main();
