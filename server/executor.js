#!/usr/bin/env node
// Server-side executor (engine):
// - Reads engine-input.json generated by client/prepare.js
// - Creates/updates issues in mzfshark/* repos (idempotent via stableId)
// - Optionally attaches issues to ProjectV2 and updates estimate field

const fs = require('fs');
const path = require('path');
const { execFileSync } = require('child_process');

function readJson(p) { return JSON.parse(fs.readFileSync(p, 'utf8')); }
function writeJson(p, obj) { fs.mkdirSync(path.dirname(p), { recursive: true }); fs.writeFileSync(p, JSON.stringify(obj, null, 2)); }

function ghApi(args) {
	try {
		const out = execFileSync('gh', ['api', ...args], { encoding: 'utf8' });
		return JSON.parse(out);
	} catch (e) {
		if (e.stdout) {
			try { return JSON.parse(e.stdout.toString()); } catch (_) {}
		}
		throw e;
	}
}

function ghExec(args) {
	return execFileSync('gh', ['api', ...args], { encoding: 'utf8' });
}

function repoIsAllowed(repo) {
	// Allow mzfshark/* and Axodus/* repos
	return repo && (repo.startsWith('mzfshark/') || repo.startsWith('Axodus/'));
}

function normalizeLabels(labels, extra = []) {
	const combined = [...(Array.isArray(labels) ? labels : []), ...extra];
	return Array.from(new Set(combined.map((l) => String(l).trim()).filter(Boolean)));
}

function findIssueByStableId(repo, stableId) {
	const q = `repo:${repo} StableId:${stableId}`;
	try {
		const res = ghApi(['search/issues', '-f', `q=${q}`]);
		if (res && res.total_count && res.items && res.items.length) {
			console.log('[DEBUG] Found existing issue:', res.items[0].number, 'for', stableId.substring(0, 10));
			return res.items[0];
		}
		return null;
	} catch (e) {
		// 404 or search errors just mean no issue found
		if (!e.message.includes('HTTP 404')) {
			console.warn('[WARN] search issues failed:', e.message.substring(0, 80));
		}
		return null;
	}
}

function createIssue(repo, title, body, labels) {
	const args = [`repos/${repo}/issues`, '-f', `title=${title}`, '-f', `body=${body}`];
	for (const l of labels || []) args.push('-f', `labels[]=${l}`);
	try {
		const out = ghApi(args);
		return out;
	} catch (e) {
		if (e.message && e.message.includes('rate limit')) {
			throw new Error('RATE_LIMIT: ' + e.message.substring(0, 100));
		}
		throw e;
	}
}

function updateIssue(repo, number, title, body, labels) {
	const args = [`repos/${repo}/issues/${number}`, '-X', 'PATCH', '-f', `title=${title}`, '-f', `body=${body}`];
	for (const l of labels || []) args.push('-f', `labels[]=${l}`);
	const out = ghApi(args);
	return out;
}

function graphql(query, variables) {
	// Write variables to a temp file and pass it as @file to gh to avoid shell-quoting issues
	const os = require('os');
	const tmpdir = os.tmpdir();
	const fname = path.join(tmpdir, `gitissue-graphql-vars-${Date.now()}-${Math.floor(Math.random()*10000)}.json`);
	fs.writeFileSync(fname, JSON.stringify(variables));
	try {
		const out = execFileSync('gh', ['api', 'graphql', '-f', `query=${query}`, '-f', `variables=@${fname}`], { encoding: 'utf8' });
		return JSON.parse(out);
	} finally {
		try { fs.unlinkSync(fname); } catch (e) { /* ignore cleanup errors */ }
	}
}

function resolveProjectNodeIdFromViewer(number) {
	const q = `query($number:Int!){ viewer{ projectV2(number:$number){ id } } }`;
	const res = execFileSync('gh', ['api', 'graphql', '-f', `query=${q}`, '-F', `number=${number}`], { encoding: 'utf8' });
	const data = JSON.parse(res);
	return data.data.viewer.projectV2.id;
}

function resolveProjectNodeIdForUser(login, number) {
	const q = `query($login:String!,$number:Int!){ user(login:$login){ projectV2(number:$number){ id } } }`;
	const res = execFileSync('gh', ['api', 'graphql', '-f', `query=${q}`, '-F', `login=${login}`, '-F', `number=${number}`], { encoding: 'utf8' });
	const data = JSON.parse(res);
	return data.data.user.projectV2.id;
}

function resolveProjectNodeIdForOrg(login, number) {
	const q = `query($login:String!,$number:Int!){ organization(login:$login){ projectV2(number:$number){ id } } }`;
	const res = execFileSync('gh', ['api', 'graphql', '-f', `query=${q}`, '-F', `login=${login}`, '-F', `number=${number}`], { encoding: 'utf8' });
	const data = JSON.parse(res);
	return data.data.organization.projectV2.id;
}

function parseProjectMirrorPath(pathStr) {
	// Formats supported:
	//  - user/<login>/projects/<number>
	//  - org/<login>/projects/<number>
	//  - viewer/projects/<number>
	if (!pathStr || typeof pathStr !== 'string') return null;
	const parts = pathStr.split('/').map(s => s.trim()).filter(Boolean);
	if (parts.length === 3 && parts[0] === 'viewer' && parts[1] === 'projects') {
		return { scope: 'viewer', number: parseInt(parts[2], 10) };
	}
	if (parts.length === 4 && (parts[0] === 'user' || parts[0] === 'org') && parts[2] === 'projects') {
		return { scope: parts[0], login: parts[1], number: parseInt(parts[3], 10) };
	}
	return null;
}

function ensureProjectItem(projectNodeId, issueNodeId) {
	const mutation = `mutation($input:AddProjectV2ItemByIdInput!){ addProjectV2ItemById(input:$input){ item{ id } } }`;
	const variables = { input: { projectId: projectNodeId, contentId: issueNodeId } };
	if (!projectNodeId || typeof projectNodeId !== 'string' || !projectNodeId.startsWith('PVT_')) {
		console.error('Invalid projectNodeId for addProjectV2ItemById:', projectNodeId);
		return null;
	}
	if (!issueNodeId || typeof issueNodeId !== 'string' || !issueNodeId.startsWith('I_')) {
		console.error('Invalid issueNodeId for addProjectV2ItemById:', issueNodeId);
		return null;
	}
	try {
		const res = graphql(mutation, variables);
		if (res && res.data && res.data.addProjectV2ItemById && res.data.addProjectV2ItemById.item) {
			return res.data.addProjectV2ItemById.item.id;
		}
		console.error('addProjectV2ItemById: unexpected response', JSON.stringify(res));
		return null;
	} catch (e) {
		console.error('addProjectV2ItemById failed (variables path):', e.message);
		// Fallback: construct inline mutation with escaped IDs (works in practice)
		try {
			const inline = `mutation{ addProjectV2ItemById(input:{projectId:\"${projectNodeId}\",contentId:\"${issueNodeId}\"}){ item{ id } } }`;
			const out = execFileSync('gh', ['api', 'graphql', '-f', `query=${inline}`], { encoding: 'utf8' });
			const data = JSON.parse(out);
			if (data && data.data && data.data.addProjectV2ItemById && data.data.addProjectV2ItemById.item) {
				return data.data.addProjectV2ItemById.item.id;
			}
			console.error('addProjectV2ItemById fallback: unexpected response', JSON.stringify(data));
			return null;
		} catch (ee) {
			console.error('addProjectV2ItemById fallback failed:', ee.message);
			return null;
		}
	}
}

function updateProjectEstimate(projectNodeId, itemId, fieldId, hours) {
	const mutation = `mutation($input:UpdateProjectV2ItemFieldValueInput!){ updateProjectV2ItemFieldValue(input:$input){ projectV2Item{ id } } }`;
	const variables = { input: { projectId: projectNodeId, itemId, fieldId, value: { number: hours } } };
	if (!projectNodeId || typeof projectNodeId !== 'string' || !projectNodeId.startsWith('PVT_')) {
		console.error('Invalid projectNodeId for updateProjectEstimate:', projectNodeId);
		return false;
	}
	if (!itemId || typeof itemId !== 'string') {
		console.error('Invalid itemId for updateProjectEstimate:', itemId);
		return false;
	}
	// The GraphQL API expects a global node ID for fieldId (not a numeric UI id).
	if (fieldId && /^[0-9]+$/.test(String(fieldId))) {
		console.error('estimateFieldId appears numeric. ProjectV2 GraphQL requires a global node id for fieldId. Skipping estimate update. Provided fieldId:', fieldId);
		return false;
	}
	try {
		graphql(mutation, variables);
		return true;
	} catch (e) {
		console.error('updateProjectEstimate failed (variables path):', e.message);
		// Fallback: inline mutation
		try {
			const inline = `mutation{ updateProjectV2ItemFieldValue(input:{projectId:\"${projectNodeId}\",itemId:\"${itemId}\",fieldId:\"${fieldId}\",value:{number:${hours}}}){ projectV2Item{ id } } }`;
			const out = execFileSync('gh', ['api', 'graphql', '-f', `query=${inline}`], { encoding: 'utf8' });
			const data = JSON.parse(out);
			if (data && data.data && data.data.updateProjectV2ItemFieldValue) return true;
			console.error('updateProjectEstimate fallback: unexpected response', JSON.stringify(data));
			return false;
		} catch (ee) {
			console.error('updateProjectEstimate fallback failed:', ee.message);
			return false;
		}
	}
}

async function main() {
	const args = process.argv.slice(2);
	const configIndex = args.indexOf('--config');
	const inputIndex = args.indexOf('--input');
	
	let inputPath;
	let outputPath;
	let mirrorProjectPath = null; // e.g., 'user/mzfshark/projects/15'
	let mirrorEstimateFieldId = null;
	
	// Support both --config (new per-repo format) and --input (old format)
	if (configIndex >= 0 && args[configIndex + 1]) {
		// Load config to get input/output paths
		const configPath = args[configIndex + 1];
		if (!fs.existsSync(configPath)) {
			console.error('Config file not found:', configPath);
			process.exit(2);
		}
		const cfg = readJson(configPath);
		inputPath = cfg.outputs?.engineInputPath || './tmp/engine-input.json';
		outputPath = cfg.outputs?.engineOutputPath || './tmp/engine-output.json';
		// Optional mirror project configuration in config file
		if (cfg.projectMirror && cfg.projectMirror.path) {
			mirrorProjectPath = cfg.projectMirror.path;
		}
		if (cfg.projectMirror && cfg.projectMirror.estimateFieldId) {
			mirrorEstimateFieldId = cfg.projectMirror.estimateFieldId;
		}
	} else {
		// Old format: explicit --input or default
		inputPath = (inputIndex >= 0 && args[inputIndex + 1]) ? args[inputIndex + 1] : './tmp/engine-input.json';
		outputPath = inputPath.replace('engine-input.json', 'engine-output.json');
	}

	if (!fs.existsSync(inputPath)) {
		console.error('Engine input not found:', inputPath);
		console.error('Run: npm run prepare');
		process.exit(2);
	}

	console.log('\nReading engine input:', inputPath);
	const engine = readJson(inputPath);
	const output = { ...engine, executedAt: new Date().toISOString(), results: [] };
	const owner = engine.owner || 'mzfshark';

	// Resolve main viewer project node id if provided
	let viewerProjectNodeId = null;
	const projectCfg = engine.project || {};
	if (projectCfg && projectCfg.number) {
		try {
			viewerProjectNodeId = resolveProjectNodeIdFromViewer(projectCfg.number);
		} catch (e) {
			console.warn('Could not resolve viewer project node id:', e.message.split('\n')[0]);
		}
	}

	// Resolve mirror project node id if provided via engine or config
	let mirrorProjectNodeId = null;
	// Prefer explicit engine.project.mirrorPath if present
	if (engine.project && engine.project.mirrorPath && !mirrorProjectPath) {
		mirrorProjectPath = engine.project.mirrorPath;
	}
	if (mirrorProjectPath) {
		try {
			const parsed = parseProjectMirrorPath(mirrorProjectPath);
			if (!parsed) {
				console.warn('Mirror project path unparsable:', mirrorProjectPath);
			} else if (parsed.scope === 'viewer') {
				mirrorProjectNodeId = resolveProjectNodeIdFromViewer(parsed.number);
			} else if (parsed.scope === 'user') {
				mirrorProjectNodeId = resolveProjectNodeIdForUser(parsed.login, parsed.number);
			} else if (parsed.scope === 'org') {
				mirrorProjectNodeId = resolveProjectNodeIdForOrg(parsed.login, parsed.number);
			}
		} catch (e) {
			console.warn('Could not resolve mirror project node id:', e.message.split('\n')[0]);
		}
	}

	for (const t of engine.targets || []) {
		// Handle both formats: "repo" and "owner/repo"
		const fullRepo = t.repo.includes('/') ? t.repo : `${owner}/${t.repo}`;
		console.log('\nProcessing target:', fullRepo);
		if (!repoIsAllowed(fullRepo)) {
			console.warn('Skipping target (repo not allowed):', fullRepo);
			output.results.push({ repo: fullRepo, skipped: true, reason: 'repo not allowed' });
			continue;
		}

		const repoResult = { repo: fullRepo, tasks: [] };
		const projectCfg = engine.project || {};
		// Prefer pre-resolved viewerProjectNodeId
		let projectNodeId = viewerProjectNodeId || (engine.project && engine.project.nodeId);

		for (const task of t.tasks || []) {
			try {
				const title = task.text.length > 120 ? task.text.slice(0, 117) + '...' : task.text;
				const body = `Source: ${task.file}#L${task.line}\n\nStableId: ${task.stableId}\n\n${task.text}`;
				const labels = normalizeLabels(task.labels, ['sync-md']);
				if (task.priority) labels.push(task.priority);

				let issue = findIssueByStableId(fullRepo, task.stableId);
				let created = false;
				if (issue) {
					console.log('Updating issue', issue.number, 'for', task.stableId.substring(0, 10));
					const upd = updateIssue(fullRepo, issue.number, title, body, labels);
					issue = upd;
				} else {
					console.log('Creating issue for', task.stableId.substring(0, 10));
					const createdIssue = createIssue(fullRepo, title, body, labels);
					if (!createdIssue || !createdIssue.number) {
						throw new Error('Failed to create issue: no issue number returned');
					}
					issue = createdIssue;
					created = true;
				}

				const issueNumber = issue.number;
				const issueNodeId = issue.node_id || issue.nodeId || null;

				const taskResult = { stableId: task.stableId, issueNumber, issueNodeId, created };

				if (t.enableProjectSync && projectNodeId && issueNodeId) {
					try {
						const projectItemId = ensureProjectItem(projectNodeId, issueNodeId);
						taskResult.projectItemId = projectItemId;
						const estimateFieldId = (engine.project && engine.project.fieldIds && engine.project.fieldIds.estimateHoursFieldId) || null;
						if (estimateFieldId && task.estimateHours != null) {
							updateProjectEstimate(projectNodeId, projectItemId, estimateFieldId, task.estimateHours);
						}
					} catch (e) {
						console.error('Project attach/update failed for', task.stableId, e.message);
					}
				}

				// Mirror into secondary project if configured
				if (issueNodeId && mirrorProjectNodeId) {
					try {
						const mirrorItemId = ensureProjectItem(mirrorProjectNodeId, issueNodeId);
						taskResult.mirrorProjectItemId = mirrorItemId;
						if (mirrorEstimateFieldId && task.estimateHours != null) {
							updateProjectEstimate(mirrorProjectNodeId, mirrorItemId, mirrorEstimateFieldId, task.estimateHours);
						}
					} catch (e) {
						console.error('Mirror project attach/update failed for', task.stableId, e.message);
					}
				}

				repoResult.tasks.push(taskResult);
			} catch (e) {
				const isRateLimit = e.message && e.message.includes('RATE_LIMIT');
				console.error(isRateLimit ? '[RATE_LIMIT]' : '[ERROR]', 'Failed to process task', task.stableId.substring(0, 10), e.message.substring(0, 80));
				repoResult.tasks.push({ stableId: task.stableId, error: e.message, rateLimit: isRateLimit });
				if (isRateLimit) {
					console.warn('\n⚠️  Rate limit hit. Stopping execution. Remaining tasks:', (t.tasks.length + t.subtasks.length) - repoResult.tasks.length);
					break;
				}
			}
		}

		for (const s of t.subtasks || []) {
			try {
				const parentIssue = repoResult.tasks.find(x => x.stableId === s.parentStableId);
				const parentNumber = parentIssue && parentIssue.issueNumber;
				const title = s.text.length > 120 ? s.text.slice(0, 117) + '...' : s.text;
				let body = `Source: ${s.file}#L${s.line}\n\nStableId: ${s.stableId}\n\n${s.text}`;
				if (parentNumber) body = `Parent: #${parentNumber}\n\n` + body;
				const labels = normalizeLabels(s.labels, ['subtask', 'sync-md']);
				if (s.priority) labels.push(s.priority);
				let issue = findIssueByStableId(fullRepo, s.stableId);
				let created = false;
				if (issue) {
					const upd = updateIssue(fullRepo, issue.number, title, body, labels);
					issue = upd;
				} else {
					const createdIssue = createIssue(fullRepo, title, body, labels);
					if (!createdIssue || !createdIssue.number) {
						throw new Error('Failed to create subtask: no issue number returned');
					}
					issue = createdIssue;
					created = true;
				}
				const subIssueNodeId = issue.node_id || null;

				const subResult = { stableId: s.stableId, issueNumber: issue.number, issueNodeId: subIssueNodeId, created, parentStableId: s.parentStableId };

				// Mirror subtasks as well
				if (subIssueNodeId && mirrorProjectNodeId) {
					try {
						const mirrorItemId = ensureProjectItem(mirrorProjectNodeId, subIssueNodeId);
						subResult.mirrorProjectItemId = mirrorItemId;
						if (mirrorEstimateFieldId && s.estimateHours != null) {
							updateProjectEstimate(mirrorProjectNodeId, mirrorItemId, mirrorEstimateFieldId, s.estimateHours);
						}
					} catch (e) {
						console.error('Mirror project attach/update failed for subtask', s.stableId, e.message);
					}
				}

				repoResult.tasks.push(subResult);
			} catch (e) {
				const isRateLimit = e.message && e.message.includes('RATE_LIMIT');
				console.error(isRateLimit ? '[RATE_LIMIT]' : '[ERROR]', 'Failed to process subtask', s.stableId.substring(0, 10), e.message.substring(0, 80));
				repoResult.tasks.push({ stableId: s.stableId, error: e.message, parentStableId: s.parentStableId, rateLimit: isRateLimit });
				if (isRateLimit) {
					console.warn('\n⚠️  Rate limit hit on subtasks. Stopping.');
					break;
				}
			}
		}

		output.results.push(repoResult);
	}

	writeJson(outputPath, output);
	console.log('\n✓ Execution complete');
	console.log('Output written to:', outputPath);
}

main();
