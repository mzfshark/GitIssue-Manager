#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
CONFIGS_DIR="$ROOT/sync-helper/configs"

usage() {
  cat <<EOF
Usage: gitissuer <command> [options]

Target selection (all commands):
  --repo <owner/name>   Run against a specific repo
  --select              Interactive prompt (supports multi-select: 1,3,5 and 'a' for all)
  --include-disabled     With --select, also show disabled repos in the prompt
  --all                 Run for all enabled repos in sync-helper/configs (gitissuer.enabled=true)

Commands:
  generate [updates] [--repo <path|owner/name>]        Generate ISSUE_UPDATES.md from git log (defaults to current repo)
  prepare [--repo <owner/name>] [--config <path>]      Generate engine-input.json (defaults to current repo)
  deploy [--repo <owner/name>] [--config <path>] --confirm
                                                       Execute GitHub writes (issues/project sync)
  registry:update [--repo <owner/name>] [--config <path>]
                                                       Update per-repo registry from engine input/output
  apply [--repo <owner/name>] [--config <path>] [--file <ISSUE_UPDATES.md>] [--dry-run|--confirm]
                                                       Apply bounded ISSUE_UPDATES actions using the registry
  e2e:run [--repo <owner/name>] [--config <path>] [--dry-run|--confirm] [--non-interactive]
                                                       Run E2E orchestrator (dry-run by default)
  enable [--repo <owner/name>]                          Enable gitissuer automation for repo config
  disable [--repo <owner/name>]                         Disable gitissuer automation for repo config

Examples:
  gitissuer generate
  gitissuer generate updates --repo /opt/aragon-app
  gitissuer prepare --repo Axodus/AragonOSX
  gitissuer deploy --repo Axodus/AragonOSX --confirm
  gitissuer registry:update --repo Axodus/AragonOSX
  gitissuer apply --repo Axodus/AragonOSX --dry-run
  gitissuer apply --repo Axodus/AragonOSX --confirm
  gitissuer enable --repo Axodus/AragonOSX
  gitissuer disable --repo Axodus/AragonOSX
EOF
}

ensure_dirs() {
  local repo_path="$1"
  mkdir -p "$repo_path/.gitissuer/updates"
}

read_last_generate() {
  local repo_path="$1"
  local state_file="$repo_path/.gitissuer/last-generate.json"
  if [[ -f "$state_file" ]]; then
    jq -r '.last_generate // "1970-01-01T00:00:00Z"' "$state_file"
  else
    echo "1970-01-01T00:00:00Z"
  fi
}

write_last_generate() {
  local repo_path="$1"
  local ts="$2"
  local state_file="$repo_path/.gitissuer/last-generate.json"
  printf '{"last_generate":"%s"}\n' "$ts" >"$state_file"
}

generate_for_repo() {
  local repo_path="$1"
  local repo_name
  repo_name="$(basename "$repo_path")"

  if [[ ! -d "$repo_path/.git" ]]; then
    echo "[WARN] Not a git repo: $repo_path"
    return 0
  fi

  ensure_dirs "$repo_path"

  local last_generate
  last_generate="$(read_last_generate "$repo_path")"

  local commits
  commits="$(git -C "$repo_path" --no-pager log --since="$last_generate" --pretty=format:'- %ad %h %s' --date=iso || true)"

  if [[ -z "$commits" ]]; then
    echo "[INFO] No commits since $last_generate in $repo_name"
    return 0
  fi

  local ts
  ts="$(date -u +%Y%m%dT%H%M%SZ)"

  local updates_file
  updates_file="$repo_path/.gitissuer/updates/${repo_name}_generated_${ts}.md"

  {
    echo "# ISSUE UPDATES"
    echo ""
    echo "Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
    echo ""
    echo "$commits"
  } >"$updates_file"

  cp "$updates_file" "$repo_path/ISSUE_UPDATES.md"

  write_last_generate "$repo_path" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

  echo "[OK] Generated $updates_file"
}

require_cmd() {
  local cmd="$1"
  if ! command -v "$cmd" >/dev/null 2>&1; then
    echo "[ERROR] Missing dependency: $cmd" >&2
    exit 1
  fi
}

list_known_repos() {
  require_cmd jq
  if [[ ! -d "$CONFIGS_DIR" ]]; then
    return 0
  fi

  local cfg
  shopt -s nullglob
  for cfg in "$CONFIGS_DIR"/*.json; do
    local repo
    repo="$(jq -r '.repo // empty' "$cfg" 2>/dev/null || true)"
    [[ -z "$repo" ]] && continue
    local enabled
    enabled="$(jq -r 'if .gitissuer.enabled == null then true else .gitissuer.enabled end' "$cfg" 2>/dev/null || echo true)"
    local local_path
    local_path="$(jq -r '.localPath // empty' "$cfg" 2>/dev/null || true)"
    printf '%s|%s|%s|%s\n' "$repo" "$cfg" "$enabled" "$local_path"
  done
}

list_enabled_repo_slugs() {
  # Output only repos where gitissuer.enabled == true
  list_known_repos | awk -F'|' '$3 == "true" { print $1 }'
}

prompt_select_repo_slugs() {
  # Usage: prompt_select_repo_slugs [--include-disabled]
  local include_disabled="false"
  if [[ "${1-}" == "--include-disabled" ]]; then
    include_disabled="true"
  fi

  mapfile -t entries < <(list_known_repos)
  if (( ${#entries[@]} == 0 )); then
    echo "[ERROR] No repos found in $CONFIGS_DIR" >&2
    echo "[HINT] Add configs under sync-helper/configs/*.json with a .repo field." >&2
    exit 2
  fi

  if [[ "$include_disabled" != "true" ]]; then
    local -a filtered=()
    local line
    for line in "${entries[@]}"; do
      IFS='|' read -r _repo _cfg enabled _local_path <<<"$line"
      if [[ "$enabled" == "true" ]]; then
        filtered+=("$line")
      fi
    done
    entries=("${filtered[@]}")

    if (( ${#entries[@]} == 0 )); then
      echo "[ERROR] No enabled repos found in $CONFIGS_DIR" >&2
      echo "[HINT] Use 'gitissuer enable --all' or 'gitissuer enable --select' to enable repos." >&2
      exit 2
    fi
  fi

  local current_repo=""
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    current_repo="$(infer_repo_full_from_cwd 2>/dev/null || true)"
  fi

  local current_enabled="true"
  if [[ -n "$current_repo" ]]; then
    current_enabled="$(is_repo_enabled_in_config "$current_repo")"
  fi

  echo "Select repos:" >&2
  local i=1
  local line
  for line in "${entries[@]}"; do
    IFS='|' read -r repo _cfg enabled local_path <<<"$line"
    local path_hint=""
    if [[ -n "$local_path" ]]; then
      path_hint="$local_path"
    else
      path_hint="(no localPath)"
    fi
    echo "  [$i] $repo (enabled=$enabled, path=$path_hint)" >&2
    ((i++))
  done
  echo "  [a] all" >&2
  if [[ -n "$current_repo" && ( "$include_disabled" == "true" || "$current_enabled" == "true" ) ]]; then
    echo "  [c] current ($current_repo)" >&2
  fi
  echo "  [q] quit" >&2

  local answer
  read -r -p "Selection (e.g. 1,3,5 or a): " answer
  answer="$(printf '%s' "$answer" | tr -d '[:space:]')"
  if [[ -z "$answer" ]]; then
    echo "[ERROR] Empty selection" >&2
    exit 2
  fi

  case "${answer,,}" in
    q)
      printf '%s\n' "__CANCEL__"
      return 0
      ;;
    a)
      local line
      for line in "${entries[@]}"; do
        IFS='|' read -r repo _cfg _enabled _local_path <<<"$line"
        printf '%s\n' "$repo"
      done
      return 0
      ;;
    c)
      if [[ -z "$current_repo" ]]; then
        echo "[ERROR] Not inside a git repo; cannot use 'c'" >&2
        exit 2
      fi
      printf '%s\n' "$current_repo"
      return 0
      ;;
  esac

  # Parse comma-separated indexes: 1,3,5
  local -a picks=()
  local token
  IFS=',' read -r -a picks <<<"$answer"
  local -a out=()
  for token in "${picks[@]}"; do
    if [[ ! "$token" =~ ^[0-9]+$ ]]; then
      echo "[ERROR] Invalid selection token: $token" >&2
      exit 2
    fi
    local idx=$((token - 1))
    if (( idx < 0 || idx >= ${#entries[@]} )); then
      echo "[ERROR] Selection out of range: $token" >&2
      exit 2
    fi
    IFS='|' read -r repo _cfg _enabled _local_path <<<"${entries[$idx]}"
    out+=("$repo")
  done

  # De-duplicate while preserving order
  local seen="|"
  local r
  for r in "${out[@]}"; do
    if [[ "$seen" != *"|$r|"* ]]; then
      printf '%s\n' "$r"
      seen+="$r|"
    fi
  done
}

infer_git_root_from_cwd() {
  require_cmd git
  git rev-parse --show-toplevel 2>/dev/null || true
}

infer_repo_full_from_git_remote() {
  local repo_root="$1"
  require_cmd git

  local remote_url
  remote_url="$(git -C "$repo_root" remote get-url origin 2>/dev/null || true)"
  if [[ -z "$remote_url" ]]; then
    return 1
  fi

  # Support git@github.com:owner/repo(.git) and https://github.com/owner/repo(.git)
  if [[ "$remote_url" =~ github\.com[:/]+([^/]+)/([^/]+)$ ]]; then
    local owner="${BASH_REMATCH[1]}"
    local repo_raw="${BASH_REMATCH[2]}"
    repo_raw="${repo_raw%.git}"
    printf '%s/%s' "$owner" "$repo_raw"
    return 0
  fi

  return 1
}

infer_repo_full_from_configs_by_path() {
  local repo_root="$1"
  require_cmd jq

  if [[ ! -d "$CONFIGS_DIR" ]]; then
    return 1
  fi

  local repo_root_real
  repo_root_real="$(cd "$repo_root" && pwd)"

  local cfg
  shopt -s nullglob
  for cfg in "$CONFIGS_DIR"/*.json; do
    local local_path
    local_path="$(jq -r '.localPath // empty' "$cfg" 2>/dev/null || true)"
    [[ -z "$local_path" ]] && continue

    local abs
    if [[ "$local_path" = /* ]]; then
      abs="$local_path"
    else
      abs="$ROOT/$local_path"
    fi

    if [[ -d "$abs" ]]; then
      local abs_real
      abs_real="$(cd "$abs" && pwd)"
      if [[ "$abs_real" == "$repo_root_real" ]]; then
        local r
        r="$(jq -r '.repo // empty' "$cfg" 2>/dev/null || true)"
        if [[ -n "$r" ]]; then
          printf '%s' "$r"
          return 0
        fi
      fi
    fi
  done

  return 1
}

infer_repo_full_from_cwd() {
  local repo_root
  repo_root="$(infer_git_root_from_cwd)"
  if [[ -z "$repo_root" ]]; then
    echo "[ERROR] Not inside a git repository and --repo was not provided." >&2
    exit 2
  fi

  local repo_full
  # Prefer sync-helper configs (source of truth) over git remotes.
  # This avoids mismatches when the local origin points to a fork.
  repo_full="$(infer_repo_full_from_configs_by_path "$repo_root" 2>/dev/null || true)"
  if [[ -n "$repo_full" ]]; then
    printf '%s' "$repo_full"
    return 0
  fi

  repo_full="$(infer_repo_full_from_git_remote "$repo_root" 2>/dev/null || true)"
  if [[ -n "$repo_full" ]]; then
    printf '%s' "$repo_full"
    return 0
  fi

  echo "[ERROR] Could not infer --repo from cwd. Ensure origin remote points to github.com or a matching sync-helper config exists." >&2
  exit 2
}

config_repo_path() {
  local config_path="$1"
  local local_path
  local_path="$(jq -r '.localPath // empty' "$config_path" 2>/dev/null || true)"
  if [[ -z "$local_path" ]]; then
    return 1
  fi
  if [[ "$local_path" = /* ]]; then
    printf '%s' "$local_path"
    return 0
  fi
  printf '%s' "$ROOT/$local_path"
}

resolve_repo_path_from_repo_arg() {
  local repo_arg="$1"

  # If it's already a local path, use as-is.
  if [[ -d "$repo_arg" ]]; then
    printf '%s' "$repo_arg"
    return 0
  fi

  # If it looks like owner/name, try to resolve via configs.
  if [[ "$repo_arg" == */* ]]; then
    local want_lc
    want_lc="$(printf '%s' "$repo_arg" | tr '[:upper:]' '[:lower:]')"
    local cfg
    shopt -s nullglob
    for cfg in "$CONFIGS_DIR"/*.json; do
      local r
      r="$(jq -r '.repo // empty' "$cfg" 2>/dev/null || true)"
      if [[ -n "$r" ]]; then
        local r_lc
        r_lc="$(printf '%s' "$r" | tr '[:upper:]' '[:lower:]')"
        if [[ "$r_lc" == "$want_lc" ]]; then
          local path
          path="$(config_repo_path "$cfg" || true)"
          if [[ -n "$path" ]]; then
            printf '%s' "$path"
            return 0
          fi
        fi
      fi
    done
  fi

  # Fall back to the raw argument so callers get a consistent error.
  printf '%s' "$repo_arg"
  return 0
}

resolve_config_path_from_repo_full() {
  local repo_full="$1"
  require_cmd jq

  if [[ ! -d "$CONFIGS_DIR" ]]; then
    echo "";
    return 1
  fi

  local want_lc
  want_lc="$(printf '%s' "$repo_full" | tr '[:upper:]' '[:lower:]')"

  local cfg
  shopt -s nullglob
  for cfg in "$CONFIGS_DIR"/*.json; do
    local r
    r="$(jq -r '.repo // empty' "$cfg" 2>/dev/null || true)"
    [[ -z "$r" ]] && continue
    local r_lc
    r_lc="$(printf '%s' "$r" | tr '[:upper:]' '[:lower:]')"
    if [[ "$r_lc" == "$want_lc" ]]; then
      printf '%s' "$cfg"
      return 0
    fi
  done

  echo "";
  return 1
}

is_repo_enabled_in_config() {
  local repo_full="$1"
  require_cmd jq

  local cfg
  cfg="$(resolve_config_path_from_repo_full "$repo_full" || true)"
  if [[ -z "$cfg" || ! -f "$cfg" ]]; then
    # If there's no config, default to enabled.
    echo "true"
    return 0
  fi

  jq -r 'if .gitissuer.enabled == null then true else .gitissuer.enabled end' "$cfg" 2>/dev/null || echo "true"
}

set_repo_enabled_flag() {
  local repo_full="$1"
  local enabled_value="$2" # true|false
  require_cmd jq

  local cfg
  cfg="$(resolve_config_path_from_repo_full "$repo_full" || true)"
  if [[ -z "$cfg" || ! -f "$cfg" ]]; then
    echo "[ERROR] Could not find config for repo: $repo_full" >&2
    echo "[HINT] Expected a file in $CONFIGS_DIR with .repo == '$repo_full'" >&2
    exit 2
  fi

  local tmp
  tmp="${cfg}.tmp-${$}"
  jq --argjson v "$enabled_value" '.gitissuer.enabled = $v' "$cfg" >"$tmp"
  mv "$tmp" "$cfg"
  echo "[OK] Updated $cfg: gitissuer.enabled=$enabled_value"
}

extract_repo_flag_or_infer() {
  local repo_full=""
  local want_select="false"
  local want_all="false"
  local include_disabled="false"
  local out_args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --repo)
        repo_full="$2"
        shift 2
        ;;
      --select)
        want_select="true"
        shift
        ;;
      --include-disabled)
        include_disabled="true"
        shift
        ;;
      --all)
        want_all="true"
        shift
        ;;
      *)
        out_args+=("$1")
        shift
        ;;
    esac
  done

  # Print targeting mode header:
  # line 1: mode (repo|select|all|infer)
  # line 2: repo_full (only for mode=repo)
  # line 3: include_disabled (true|false)
  if [[ -n "$repo_full" ]]; then
    printf '%s\n' "repo"
    printf '%s\n' "$repo_full"
  elif [[ "$want_all" == "true" ]]; then
    printf '%s\n' "all"
    printf '%s\n' ""
  elif [[ "$want_select" == "true" ]]; then
    printf '%s\n' "select"
    printf '%s\n' ""
  else
    printf '%s\n' "infer"
    printf '%s\n' ""
  fi

  printf '%s\n' "$include_disabled"

  if (( ${#out_args[@]} > 0 )); then
    printf '%s\n' "${out_args[@]}"
  fi
}

run_for_targets() {
  local subcmd="$1"
  shift

  mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
  local mode="${parsed[0]}"
  local repo_full="${parsed[1]}"
  local include_disabled="${parsed[2]}"
  local passthrough=("${parsed[@]:3}")

  local -a targets=()
  case "$mode" in
    repo)
      targets+=("$repo_full")
      ;;
    all)
      mapfile -t targets < <(list_enabled_repo_slugs)
      ;;
    select)
      if [[ "$include_disabled" == "true" ]]; then
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      else
        mapfile -t targets < <(prompt_select_repo_slugs)
      fi
      ;;
    infer)
      if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        targets+=("$(infer_repo_full_from_cwd)")
      else
        if [[ "$include_disabled" == "true" ]]; then
          mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
        else
          mapfile -t targets < <(prompt_select_repo_slugs)
        fi
      fi
      ;;
    *)
      echo "[ERROR] Unknown targeting mode: $mode" >&2
      exit 2
      ;;
  esac

  if (( ${#targets[@]} > 0 )) && [[ "${targets[0]}" == "__CANCEL__" ]]; then
    exit 0
  fi

  if (( ${#targets[@]} == 0 )); then
    echo "[ERROR] No target repos selected." >&2
    exit 2
  fi

  local rc=0
  local t
  for t in "${targets[@]}"; do
    local enabled
    enabled="$(is_repo_enabled_in_config "$t")"
    if [[ "$enabled" != "true" ]]; then
      echo "[INFO] Skipping disabled repo: $t" >&2
      continue
    fi
    echo "[INFO] Running $subcmd for $t" >&2
    /bin/bash "$ROOT/scripts/gitissuer.sh" "$subcmd" --repo "$t" "${passthrough[@]}" || rc=$?
  done

  exit $rc
}

cmd_prepare() {
  run_for_targets prepare "$@"
}

cmd_deploy() {
  run_for_targets deploy "$@"
}

cmd_registry_update() {
  run_for_targets registry:update "$@"
}

cmd_apply() {
  run_for_targets apply "$@"
}

cmd_e2e_run() {
  run_for_targets e2e:run "$@"
}

cmd_enable() {
  mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
  local mode="${parsed[0]}"
  local repo_full="${parsed[1]}"
  local include_disabled="${parsed[2]}"

  local -a targets=()
  case "$mode" in
    repo) targets+=("$repo_full") ;;
    all) mapfile -t targets < <(list_known_repos | cut -d'|' -f1) ;;
    select)
      if [[ "$include_disabled" == "true" ]]; then
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      else
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      fi
      ;;
    infer)
      if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        targets+=("$(infer_repo_full_from_cwd)")
      else
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      fi
      ;;
  esac

  if (( ${#targets[@]} > 0 )) && [[ "${targets[0]}" == "__CANCEL__" ]]; then
    exit 0
  fi

  local t
  for t in "${targets[@]}"; do
    set_repo_enabled_flag "$t" true
  done
}

cmd_disable() {
  mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
  local mode="${parsed[0]}"
  local repo_full="${parsed[1]}"
  local include_disabled="${parsed[2]}"

  local -a targets=()
  case "$mode" in
    repo) targets+=("$repo_full") ;;
    all) mapfile -t targets < <(list_known_repos | cut -d'|' -f1) ;;
    select)
      if [[ "$include_disabled" == "true" ]]; then
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      else
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      fi
      ;;
    infer)
      if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        targets+=("$(infer_repo_full_from_cwd)")
      else
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      fi
      ;;
  esac

  if (( ${#targets[@]} > 0 )) && [[ "${targets[0]}" == "__CANCEL__" ]]; then
    exit 0
  fi

  local t
  for t in "${targets[@]}"; do
    set_repo_enabled_flag "$t" false
  done
}

cmd_generate() {
  local repo_path=""
  local want_select="false"
  local want_all="false"
  local include_disabled="false"

  generate_for_repo_arg() {
    local arg="$1"

    # If user passed a repo slug (owner/name), enforce gitissuer.enabled when a config exists.
    if [[ ! -d "$arg" && "$arg" == */* ]]; then
      local enabled
      enabled="$(is_repo_enabled_in_config "$arg")"
      if [[ "$enabled" != "true" ]]; then
        echo "[INFO] Skipping generate because gitissuer.enabled=false for $arg"
        return 0
      fi
    fi

    local resolved
    resolved="$(resolve_repo_path_from_repo_arg "$arg")"
    if [[ ! -d "$resolved" ]]; then
      echo "[WARN] Could not resolve repo path for: $arg" >&2
      return 0
    fi

    generate_for_repo "$resolved"
  }

  while [[ $# -gt 0 ]]; do
    case "$1" in
      updates) shift ;; # optional keyword
      --repo) repo_path="$2"; shift 2 ;;
      --select) want_select="true"; shift ;;
      --include-disabled) include_disabled="true"; shift ;;
      --all) want_all="true"; shift ;;
      -h|--help) usage; exit 0 ;;
      *) echo "[ERROR] Unknown arg: $1"; usage; exit 1 ;;
    esac
  done

  if [[ -n "$repo_path" ]]; then
    generate_for_repo_arg "$repo_path"
    return 0
  fi

  if [[ "$want_all" == "true" ]]; then
    mapfile -t slugs < <(list_enabled_repo_slugs)
    local s
    for s in "${slugs[@]}"; do
      generate_for_repo_arg "$s"
    done
    return 0
  fi

  if [[ "$want_select" == "true" ]]; then
    if [[ "$include_disabled" == "true" ]]; then
      mapfile -t slugs < <(prompt_select_repo_slugs --include-disabled)
    else
      mapfile -t slugs < <(prompt_select_repo_slugs)
    fi
    if (( ${#slugs[@]} > 0 )) && [[ "${slugs[0]}" == "__CANCEL__" ]]; then
      return 0
    fi
    local s
    for s in "${slugs[@]}"; do
      generate_for_repo_arg "$s"
    done
    return 0
  fi

  # Default behavior: operate on the current repo when --repo is not provided.
  local repo_root
  repo_root="$(infer_git_root_from_cwd)"
  if [[ -z "$repo_root" ]]; then
    echo "[ERROR] Not inside a git repository and --repo was not provided." >&2
    exit 2
  fi

  # Respect gitissuer.enabled for the current repo when a config exists.
  local repo_full
  repo_full="$(infer_repo_full_from_cwd)"
  local enabled
  enabled="$(is_repo_enabled_in_config "$repo_full")"
  if [[ "$enabled" != "true" ]]; then
    echo "[INFO] Skipping generate because gitissuer.enabled=false for $repo_full"
    return 0
  fi

  generate_for_repo "$repo_root"
  return 0
}

main() {
  local cmd_raw="${1-}"
  shift || true

  # Normalize common command aliases (people tend to omit ':' or use '-'/'_').
  local cmd
  cmd="$(printf '%s' "$cmd_raw" | tr '[:upper:]' '[:lower:]')"
  case "$cmd" in
    registryupdate|registry-update|registry_update) cmd="registry:update" ;;
    e2erun|e2e-run|e2e_run) cmd="e2e:run" ;;
  esac

  case "$cmd" in
    generate) cmd_generate "$@" ;;
    prepare) cmd_prepare "$@" ;;
    deploy) cmd_deploy "$@" ;;
    registry:update) cmd_registry_update "$@" ;;
    apply) cmd_apply "$@" ;;
    e2e:run) cmd_e2e_run "$@" ;;
    enable|activate) cmd_enable "$@" ;;
    disable|deactivate) cmd_disable "$@" ;;
    "") usage; exit 1 ;;
    *) echo "[ERROR] Unknown command: $cmd"; usage; exit 1 ;;
  esac
}

main "$@"
