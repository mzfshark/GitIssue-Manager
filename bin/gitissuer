#!/usr/bin/env bash
set -euo pipefail

SCRIPT_SOURCE="${BASH_SOURCE[0]}"
SCRIPT_PATH=""

if command -v readlink >/dev/null 2>&1; then
  SCRIPT_PATH="$(readlink -f "$SCRIPT_SOURCE" 2>/dev/null || true)"
fi

if [[ -z "$SCRIPT_PATH" ]] && command -v python3 >/dev/null 2>&1; then
  SCRIPT_PATH="$(python3 -c 'import os,sys; print(os.path.realpath(sys.argv[1]))' "$SCRIPT_SOURCE" 2>/dev/null || true)"
fi

if [[ -z "$SCRIPT_PATH" ]]; then
  SCRIPT_PATH="$SCRIPT_SOURCE"
fi

SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
CONFIGS_DIR="$ROOT/sync-helper/configs"

usage() {
  cat <<'EOF'
Usage: gitissuer <command> [options]

Target selection (all commands):
  --repo <owner/name>     Run against a specific repo
  --select                Interactive prompt (supports multi-select: 1,3,5 and 'a' for all)
  --include-disabled      With --select, also show disabled repos in the prompt
  --all                   Run for all enabled repos in sync-helper/configs (gitissuer.enabled=true)

Commands (typical flow order):
  doctor                                                 Show what binary/config is being used and how targeting resolves
  install                                                Install this checkout as the global `gitissuer` via `npm link`
  uninstall                                              Remove global `gitissuer` installed via `npm link`
  config <list|create|set|edit|delete|show|path>         Manage per-repo configs in sync-helper/configs
  enable [--repo <owner/name>]                           Enable gitissuer automation for repo config
  disable [--repo <owner/name>]                          Disable gitissuer automation for repo config
  watch <enable|disable|list>                            Manage gitissuer.watch.enabled per repo (controls systemd watcher targets)
  parent <set|show|clear> [--repo <owner/name>]          Manage gitissuer.hierarchy.parentIssueNumber in repo config
  
List issues from GitHub (read-only)  
  issues list               [--repo <owner/name>]                    
                            [--state open|closed|all]
                            [--limit N]
                            [--show-parents] 
                            [--parents-only]
                            [--show-project]

Generate ISSUE_UPDATES.md from git log (defaults to current repo)
  generate                  [updates] [--repo <path|owner/name>]         

Generate engine-input.json (defaults to current repo)
  prepare                   [--repo <owner/name>]                        
                            [--config <path>] 
                            [--plan <file>|--plans <csv>] 
                            [--plans-dir <path>]

Inject canonical identity keys into Markdown plans (ULID)
  rekey                     [--repo <owner/name>]
                            [--config <path>] [--dry-run|--confirm]
                            [--plan <file>|--plans <csv>]
                            [--plans-dir <path>]
  
Convenience: prepare + deploy + registry:update  
  sync                      [--repo <owner/name>]                        
                            [--config <path>] [--dry-run|--confirm] 
                            [--plan <file>|--plans <csv>] 
                            [--plans-dir <path>]
                            [--link-hierarchy |--no-link-hierarchy]
                            [--parent-number <n>] 
                            [--replace-parent]

Execute GitHub writes (issues/project sync)
  deploy                    [--repo <owner/name>]
                            [--config <path>] --confirm
                            [--link-hierarchy |--no-link-hierarchy]
                            [--parent-number <n>] 
                            [--replace-parent]

Update per-repo registry from engine input/output
  registry:update           [--repo <owner/name>]                
                            [--config <path>]

Link parent-child hierarchy only (E2E stage 5)
  link-hierarchy            [--repo <owner/name>]                 
                            [--parent-number <n>] 
                            [--metadata-file <path>] 
                            [--engine-output-file <path>] 
                            [--dry-run|--confirm] 
                            [--replace-parent] 
                            [--non-interactive]

Apply bounded ISSUE_UPDATES actions using the registry
  apply                     [--repo <owner/name>]
                            [--config <path>]
                            [--file <ISSUE_UPDATES.md>]
                            [--dry-run|--confirm]

Run E2E orchestrator (dry-run by default)
  e2e:run                   [--repo <owner/name>]                       
                            [--config <path>] 
                            [--dry-run|--confirm] 
                            [--non-interactive]
                            [--plan <file>|--plan-file <path>]

List recently-updated issues in a repo (read-only)
  check update              [--repo <owner/name>]                   
                            [--limit N] 
                            [--since <ISO-8601>]  

Config subcommands:
  config list               [--include-disabled]
  config path|show|edit     [--repo <owner/name>] [--select] [--include-disabled]
  config create             [--repo <owner/name>] [--local-path <absPath>]
                            [--enable-project-sync|--disable-project-sync]
                            [--auto-deploy|--no-auto-deploy]
                            [--default-estimate-hours <n>] [--default-priority <str>] [--default-status <str>]
                            [--default-start-date <str>] [--default-end-date <str>] [--default-labels <csv>]
                            [--select]
  config set                [--repo <owner/name>] [--select] [--include-disabled]
                            [--set-repo <owner/name>] [--local-path <absPath>]
                            [--enabled|--disabled] [--watch-enabled|--watch-disabled]
                            [--enable-project-sync|--disable-project-sync]
                            [--auto-deploy|--no-auto-deploy]
                            [--parent-number <n>|--clear-parent]
                            [--default-estimate-hours <n>] [--default-priority <str>] [--default-status <str>]
                            [--default-start-date <str>] [--default-end-date <str>] [--default-labels <csv>]
                            [--force]
  config delete             [--repo <owner/name>] [--select] [--include-disabled] --confirm
  config dedupe             [--include-disabled] [--by repo|path|both]

Watch subcommands:
  watch list                [--include-disabled]
  watch enable|disable      [--repo <owner/name>] [--select] [--include-disabled]
                            [--all]

Parent subcommands:
  parent show               [--repo <owner/name>]
  parent set                [--repo <owner/name>] --number <n>
  parent clear              [--repo <owner/name>]

Issues subcommands:
  issues list               [--repo <owner/name>] [--select] [--include-disabled]
                            [--state open|closed|all]
                            [--limit N]
                            [--show-parents] [--parents-only]
                            [--show-project]
EOF
}

# Handle --fetch convenience: perform a dry-run before confirm when requested.
# Usage: keep backward-compat; this only triggers when 'sync' + '--confirm' + '--fetch' present.
for __a in "$@"; do
  if [[ "$__a" == --fetch* ]]; then
    # supports --fetch and --fetch=prompt|merge|accept-remote
    FETCH_RAW="$__a"
    break
  fi
done

if [[ -n "${FETCH_RAW-}" ]]; then
  # default mode: accept-remote
  FETCH_MODE="accept-remote"
  if [[ "$FETCH_RAW" == *=* ]]; then
    FETCH_MODE="${FETCH_RAW#*=}"
  fi

  has_sync=0; has_confirm=0
  for __a in "$@"; do
    if [[ "$__a" == "sync" ]]; then has_sync=1; fi
    if [[ "$__a" == "--confirm" ]]; then has_confirm=1; fi
  done

  if [[ $has_sync -eq 1 && $has_confirm -eq 1 ]]; then
    # Build arg list without the fetch arg
    newargs=()
    for __a in "$@"; do
      case "$__a" in
        --fetch* ) continue ;;
        * ) newargs+=("$__a") ;;
      esac
    done

    echo "[INFO] --fetch detected (mode=$FETCH_MODE): running dry-run first to refresh remote snapshot..." >&2
    # Replace --confirm with --dry-run for the preliminary run
    dryargs=()
    for __a in "${newargs[@]}"; do
      if [[ "$__a" == "--confirm" ]]; then
        dryargs+=("--dry-run")
      else
        dryargs+=("$__a")
      fi
    done

    if [[ -n "${SCRIPT_PATH-}" && -f "${SCRIPT_PATH}" ]]; then
      "${SCRIPT_PATH}" "${dryargs[@]}"

      # Interactive/prompt mode: show artifacts and ask before forcing
      if [[ "$FETCH_MODE" == "prompt" ]]; then
        echo "" >&2
        echo "Dry-run artifacts:" >&2
        echo " - engine-input: ./tmp/*/engine-input.json" >&2
        echo " - engine-output: ./tmp/*/engine-output.json" >&2
        echo " - github-state: ./tmp/*/github-state.json" >&2
        echo "" >&2
        if [[ -t 0 && -t 1 && "${GITISSUER_NONINTERACTIVE-}" != "1" ]]; then
          read -r -p "Proceed to apply changes and overwrite remote issues? [y/N]: " reply
          reply="$(printf '%s' "$reply" | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')"
          if [[ "$reply" == "y" || "$reply" == "yes" ]]; then
            echo "[INFO] User approved overwrite; proceeding with --force." >&2
            newargs+=("--force")
            exec "${SCRIPT_PATH}" "${newargs[@]}"
          else
            echo "[INFO] Aborting sync per user choice." >&2
            exit 0
          fi
        else
          echo "[ERROR] Non-interactive session; cannot prompt. Use --fetch=accept-remote or run interactively." >&2
          exit 1
        fi

      elif [[ "$FETCH_MODE" == "merge" ]]; then
        # Merge strategy: conservative - prefer remote non-empty fields, fill missing from local
        echo "[INFO] Merge mode: performing conservative merge (remote wins for non-empty fields)." >&2

        # Determine --repo value from newargs
        repo_full=""
        for __a in "${newargs[@]}"; do
          if [[ "${__a}" == "--repo" ]]; then
            # next arg is the repo
            : # handled in next iteration
          fi
        done
        # Simple parse: find the value after --repo
        for ((i=0;i<${#newargs[@]};i++)); do
          if [[ "${newargs[$i]}" == "--repo" ]]; then
            next=$((i+1))
            if (( next < ${#newargs[@]} )); then
              repo_full="${newargs[$next]}"
            fi
            break
          fi
        done

        if [[ -z "$repo_full" ]]; then
          echo "[WARN] Could not determine --repo from args; falling back to --force." >&2
          newargs+=("--force")
          exec "${SCRIPT_PATH}" "${newargs[@]}"
        fi

        # Compute tmp directory name: owner-repo pattern (replace / with -)
        repo_slug="${repo_full//\//-}"
        repo_tmp_dir="./tmp/${repo_slug}"
        engine_input_file="$repo_tmp_dir/engine-input.json"
        github_state_file="$repo_tmp_dir/github-state.json"

        if [[ ! -f "$engine_input_file" || ! -f "$github_state_file" ]]; then
          echo "[WARN] Required dry-run artifacts not found: $engine_input_file or $github_state_file" >&2
          echo "[WARN] Continuing with --force fallback." >&2
          newargs+=("--force")
          exec "${SCRIPT_PATH}" "${newargs[@]}"
        fi

        # Backup original engine-input
        cp -a "$engine_input_file" "${engine_input_file}.orig-$(date -u +%Y%m%dT%H%M%SZ)" || true

        # Use jq to merge: for each task/subtask, prefer remote non-empty title/body/labels
        if command -v jq >/dev/null 2>&1; then
          echo "[INFO] Merging github-state into engine-input via jq..." >&2
          tmp_out="${engine_input_file}.merged"
          jq --argfile gh "$github_state_file" '
            ( $gh.issues // [] ) as $issues
            | ($issues | map({ (.
                stableId): . }) ) | add as $index
            | (.targets[]?.tasks? // []) as $tlist
            | (.targets[]?.subtasks? // []) as $slist
            | ( . )
            | (.targets |= map(
                (.tasks |= (if . == null then . else map(
                  ( . as $it )
                  | ( $index[$it.stableId] // {} ) as $remote
                  | (if ($remote.title // "") | length > 0 then $it.text = $remote.title else $it end)
                  | (if ($remote.body // "") | length > 0 then $it.body = $remote.body else $it end)
                  | (if ($remote.labels // []) | length > 0 then $it.labels = $remote.labels else $it end)
                ) end)
              | .subtasks |= (if . == null then . else map(
                  ( . as $it )
                  | ( $index[$it.stableId] // {} ) as $remote
                  | (if ($remote.title // "") | length > 0 then $it.text = $remote.title else $it end)
                  | (if ($remote.body // "") | length > 0 then $it.body = $remote.body else $it end)
                  | (if ($remote.labels // []) | length > 0 then $it.labels = $remote.labels else $it end)
                ) end)
              ) )
          ' "$engine_input_file" >"$tmp_out" 2>/dev/null || true

          if [[ -f "$tmp_out" ]]; then
            mv "$tmp_out" "$engine_input_file"
            echo "[OK] Wrote merged engine-input: $engine_input_file" >&2
          else
            echo "[WARN] jq merge failed; falling back to --force." >&2
            newargs+=("--force")
            exec "${SCRIPT_PATH}" "${newargs[@]}"
          fi
        else
          echo "[ERROR] jq is required for merge mode but not found; install jq or use --fetch=accept-remote." >&2
          exit 2
        fi

        # Continue with normal confirm (no --force) to attempt to apply merged payload
        echo "[INFO] Running confirm with merged payload (no --force)." >&2
        exec "${SCRIPT_PATH}" "${newargs[@]}"

      else
        # accept-remote (default): auto-force
        echo "[INFO] Dry-run complete; proceeding with confirm using --force to accept remote changes..." >&2
        newargs+=("--force")
        exec "${SCRIPT_PATH}" "${newargs[@]}"
      fi

    else
      echo "[WARN] Could not determine script path to re-invoke; skipping --fetch behavior." >&2
    fi
  fi
fi

passthrough_has_flag() {
  local want="$1"
  shift || true
  local a
  for a in "$@"; do
    if [[ "$a" == "$want" ]]; then
      return 0
    fi
  done
  return 1
}

ensure_repo_local_config_for_current_repo() {
  # Zero-config fallback: when running inside a git repo with no sync-helper config,
  # generate a repo-local config under .gitissuer/ and use it for this invocation.
  # This keeps artifacts and state within the target repo ("clean repo" mode).
  require_cmd git
  require_cmd jq

  local repo_full="$1"
  local repo_root
  repo_root="$(infer_git_root_from_cwd)"
  if [[ -z "$repo_root" ]]; then
    return 1
  fi

  # Only safe when the current repo matches the inferred target.
  local current_full
  current_full="$(infer_repo_full_from_cwd 2>/dev/null || true)"
  if [[ -z "$current_full" || "$current_full" != "$repo_full" ]]; then
    return 1
  fi

  local cfg_path="$repo_root/.gitissuer/gitissuer.sync.json"
  if [[ -f "$cfg_path" ]]; then
    printf '%s' "$cfg_path"
    return 0
  fi

  mkdir -p "$repo_root/.gitissuer"

  cat >"$cfg_path" <<EOF
{
  "repo": "${repo_full}",
  "localPath": ".",
  "enableProjectSync": false,
  "gitissuer": {
    "enabled": true,
    "autoDeploy": false
  },
  "outputs": {
    "tasksPath": "./.gitissuer/tmp/tasks.json",
    "subtasksPath": "./.gitissuer/tmp/subtasks.json",
    "engineInputPath": "./.gitissuer/tmp/engine-input.json",
    "engineOutputPath": "./.gitissuer/tmp/engine-output.json",
    "metadataPath": "./.gitissuer/tmp/metadata.json"
  }
}
EOF

  echo "[INFO] Created repo-local config: $cfg_path" >&2
  printf '%s' "$cfg_path"
  return 0
}

ensure_dirs() {
  local repo_path="$1"
  mkdir -p "$repo_path/.gitissuer/updates"
}

read_last_generate() {
  local repo_path="$1"
  local state_file="$repo_path/.gitissuer/last-generate.json"
  if [[ -f "$state_file" ]]; then
    jq -r '.last_generate // "1970-01-01T00:00:00Z"' "$state_file"
  else
    echo "1970-01-01T00:00:00Z"
  fi
}

write_last_generate() {
  local repo_path="$1"
  local ts="$2"
  local state_file="$repo_path/.gitissuer/last-generate.json"
  printf '{"last_generate":"%s"}\n' "$ts" >"$state_file"
}

generate_for_repo() {
  local repo_path="$1"
  local repo_name
  repo_name="$(basename "$repo_path")"

  if [[ ! -d "$repo_path/.git" ]]; then
    echo "[WARN] Not a git repo: $repo_path"
    return 0
  fi

  ensure_dirs "$repo_path"

  local last_generate
  last_generate="$(read_last_generate "$repo_path")"

  local commits
  commits="$(git -C "$repo_path" --no-pager log --since="$last_generate" --pretty=format:'- %ad %h %s' --date=iso || true)"

  if [[ -z "$commits" ]]; then
    echo "[INFO] No commits since $last_generate in $repo_name"
    return 0
  fi

  local ts
  ts="$(date -u +%Y%m%dT%H%M%SZ)"

  local updates_file
  updates_file="$repo_path/.gitissuer/updates/${repo_name}_generated_${ts}.md"

  {
    echo "# ISSUE UPDATES"
    echo ""
    echo "Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
    echo ""
    echo "$commits"
  } >"$updates_file"

  cp "$updates_file" "$repo_path/ISSUE_UPDATES.md"

  write_last_generate "$repo_path" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

  echo "[OK] Generated $updates_file"
}

require_cmd() {
  local cmd="$1"
  if ! command -v "$cmd" >/dev/null 2>&1; then
    echo "[ERROR] Missing dependency: $cmd" >&2
    exit 1
  fi
}

is_interactive() {
  # Avoid blocking in non-interactive contexts (systemd, CI, pipes, etc.)
  if [[ "${GITISSUER_NONINTERACTIVE-}" == "1" ]]; then
    return 1
  fi
  [[ -t 0 && -t 1 ]]
}

handle_disabled_repo_or_exit() {
  # If repo is disabled, offer to enable it (interactive), or skip.
  # Returns 0 to continue, 1 to skip.
  local repo_full="$1"
  local action_desc="$2"

  echo "[WARN] Repo is disabled (gitissuer.enabled=false): $repo_full" >&2
  echo "[HINT] You can enable it with: gitissuer enable --repo $repo_full" >&2

  if ! is_interactive; then
    return 1
  fi

  local answer
  read -r -p "Repo is disabled. Choose: [c]ancel/[e]nable/[s]kip (default: cancel) for ${action_desc}: " answer
  answer="$(printf '%s' "$answer" | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')"

  case "$answer" in
    ""|c|cancel)
      echo "[INFO] Cancelled." >&2
      exit 0
      ;;
    e|enable|y|yes)
      set_repo_enabled_flag "$repo_full" true
      return 0
      ;;
    s|skip|n|no)
      echo "[INFO] Skipping disabled repo: $repo_full" >&2
      return 1
      ;;
    *)
      echo "[INFO] Cancelled." >&2
      exit 0
      ;;
  esac
}

list_known_repos() {
  require_cmd jq
  if [[ ! -d "$CONFIGS_DIR" ]]; then
    return 0
  fi

  local cfg
  shopt -s nullglob
  for cfg in "$CONFIGS_DIR"/*.json; do
    local repo
    repo="$(jq -r '.repo // empty' "$cfg" 2>/dev/null || true)"
    [[ -z "$repo" ]] && continue
    local enabled
    enabled="$(jq -r 'if .gitissuer.enabled == null then true else .gitissuer.enabled end' "$cfg" 2>/dev/null || echo true)"
    local local_path
    local_path="$(jq -r '.localPath // empty' "$cfg" 2>/dev/null || true)"
    printf '%s|%s|%s|%s\n' "$repo" "$cfg" "$enabled" "$local_path"
  done
}

list_enabled_repo_slugs() {
  # Output only repos where gitissuer.enabled == true
  list_known_repos | awk -F'|' '$3 == "true" { print $1 }'
}

config_filename_for_repo_full() {
  local repo_full="$1"
  local owner="${repo_full%%/*}"
  local name="${repo_full##*/}"
  printf '%s/%s-%s.json' "$CONFIGS_DIR" "$owner" "$name"
}

config_path_for_repo_full() {
  local repo_full="$1"
  local guessed
  guessed="$(config_filename_for_repo_full "$repo_full")"
  if [[ -f "$guessed" ]]; then
    printf '%s' "$guessed"
    return 0
  fi

  local cfg
  cfg="$(resolve_config_path_from_repo_full "$repo_full" || true)"
  if [[ -n "$cfg" && -f "$cfg" ]]; then
    printf '%s' "$cfg"
    return 0
  fi

  printf '%s' "$guessed"
  return 0
}

default_local_path_for_repo_full() {
  # If running inside the target repo, use an absolute localPath.
  local repo_root
  repo_root="$(infer_git_root_from_cwd)"
  if [[ -z "$repo_root" ]]; then
    echo ""
    return 0
  fi

  if command -v python3 >/dev/null 2>&1; then
    python3 - <<'PY'
import os
import sys
repo = os.environ.get('GITISSUER_REPO_ROOT')
if not repo:
  print('')
  sys.exit(0)
print(os.path.abspath(os.path.expanduser(repo)))
PY
    return 0
  fi

  echo "$repo_root"
}

abs_path() {
  local input="$1"
  if [[ -z "$input" ]]; then
    echo ""
    return 0
  fi
  if command -v python3 >/dev/null 2>&1; then
    python3 - "$input" <<'PY'
import os
import sys
p = sys.argv[1]
print(os.path.abspath(os.path.expanduser(p)))
PY
    return 0
  fi
  if command -v realpath >/dev/null 2>&1; then
    realpath "$input"
    return 0
  fi
  if command -v readlink >/dev/null 2>&1; then
    readlink -f "$input" 2>/dev/null || echo "$input"
    return 0
  fi
  echo "$input"
}

canonical_dir_or_abs() {
  local input="$1"
  if [[ -z "$input" ]]; then
    echo ""
    return 0
  fi
  local normalized
  normalized="$(abs_path "$input")"
  if [[ -d "$normalized" ]]; then
    (cd "$normalized" && pwd -P) 2>/dev/null || echo "$normalized"
    return 0
  fi
  echo "$normalized"
}

prompt_bool() {
  local prompt="$1"
  local default_value="$2" # true|false

  local suffix="[y/N]"
  if [[ "$default_value" == "true" ]]; then
    suffix="[Y/n]"
  fi

  local answer=""
  read -r -p "$prompt $suffix: " answer
  answer="$(printf '%s' "$answer" | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')"
  if [[ -z "$answer" ]]; then
    printf '%s' "$default_value"
    return 0
  fi
  case "$answer" in
    y|yes|true|1) printf '%s' "true" ;;
    n|no|false|0) printf '%s' "false" ;;
    *) printf '%s' "$default_value" ;;
  esac
}

prompt_string() {
  local prompt="$1"
  local default_value="$2"
  local answer=""
  if [[ -n "$default_value" ]]; then
    read -r -p "$prompt (default: $default_value): " answer
  else
    read -r -p "$prompt: " answer
  fi
  if [[ -z "$answer" ]]; then
    printf '%s' "$default_value"
  else
    printf '%s' "$answer"
  fi
}

today_yyyy_mm_dd() {
  if command -v date >/dev/null 2>&1; then
    date -u +%F 2>/dev/null || date +%F
    return 0
  fi
  if command -v python3 >/dev/null 2>&1; then
    python3 - <<'PY'
from datetime import datetime, timezone
print(datetime.now(timezone.utc).strftime('%Y-%m-%d'))
PY
    return 0
  fi
  echo "TBD"
}

create_or_update_config() {
  local repo_full="$1"
  local local_path="$2"
  local enabled_value="${3:-true}"
  local enable_project_sync="${4:-false}"
  local auto_deploy="${5:-false}"
  local default_estimate_hours="${6:-1}"
  local default_priority="${7:-NORMAL}"
  local default_status="${8:-Backlog}"
  local default_start_date="${9:-}"
  local default_end_date="${10:-TBD}"
  local default_labels_csv="${11:-plan}"

  require_cmd jq

  if [[ -z "$local_path" ]]; then
    echo "[ERROR] --local-path is required for config create" >&2
    exit 2
  fi

  local cfg_path
  cfg_path="$(config_path_for_repo_full "$repo_full")"

  local owner="${repo_full%%/*}"

  local tmp
  tmp="${cfg_path}.tmp-${$}"

  # Normalize localPath to absolute.
  local_path="$(abs_path "$local_path")"

  if [[ -z "$default_start_date" ]]; then
    default_start_date="$(today_yyyy_mm_dd)"
  fi

  local labels_json
  if command -v python3 >/dev/null 2>&1; then
    labels_json=$(LABELS_CSV="$default_labels_csv" python3 - <<'PY'
import json
import os
csv = os.environ.get('LABELS_CSV','')
labels = [x.strip() for x in csv.split(',') if x.strip()]
if not labels:
  labels = ['plan']
print(json.dumps(labels))
PY
    )
  else
    labels_json=$(printf '%s' "$default_labels_csv" | jq -R 'split(",") | map(gsub("^\\s+|\\s+$"; "")) | map(select(length>0)) | if length==0 then ["plan"] else . end')
  fi

  if [[ -f "$cfg_path" ]]; then
    # Preserve existing config, but ensure required fields exist.
    jq \
      --arg owner "$owner" \
      --arg repo "$repo_full" \
      --arg localPath "$local_path" \
      --argjson enabled "$enabled_value" \
      --argjson enableProjectSync "$enable_project_sync" \
      --argjson autoDeploy "$auto_deploy" \
      --argjson defaultEstimateHours "$default_estimate_hours" \
      --arg defaultPriority "$default_priority" \
      --arg defaultStatus "$default_status" \
      --arg defaultStartDate "$default_start_date" \
      --arg defaultEndDate "$default_end_date" \
      --argjson defaultLabels "$labels_json" \
      '.owner = ($owner)
        | .repo = ($repo)
        | .localPath = ($localPath)
        | .enableProjectSync = $enableProjectSync
        | (.gitissuer //= {})
        | .gitissuer.enabled = $enabled
        | .gitissuer.autoDeploy = $autoDeploy
        | (.defaults //= {})
        | .defaults.defaultEstimateHours = $defaultEstimateHours
        | .defaults.defaultPriority = $defaultPriority
        | .defaults.defaultStatus = $defaultStatus
        | .defaults.defaultStartDate = $defaultStartDate
        | .defaults.defaultEndDate = $defaultEndDate
        | .defaults.defaultLabels = $defaultLabels
      ' \
      "$cfg_path" >"$tmp"
  else
    # Minimal skeleton config.
    jq -n \
      --arg owner "$owner" \
      --arg repo "$repo_full" \
      --arg localPath "$local_path" \
      --argjson enabled "$enabled_value" \
      --argjson enableProjectSync "$enable_project_sync" \
      --argjson autoDeploy "$auto_deploy" \
      --argjson defaultEstimateHours "$default_estimate_hours" \
      --arg defaultPriority "$default_priority" \
      --arg defaultStatus "$default_status" \
      --arg defaultStartDate "$default_start_date" \
      --arg defaultEndDate "$default_end_date" \
      --argjson defaultLabels "$labels_json" \
      '{
        owner: $owner,
        repo: $repo,
        localPath: $localPath,
        enableProjectSync: $enableProjectSync,
        gitissuer: { enabled: $enabled, autoDeploy: $autoDeploy },
        defaults: {
          defaultEstimateHours: $defaultEstimateHours,
          defaultPriority: $defaultPriority,
          defaultStatus: $defaultStatus,
          defaultStartDate: $defaultStartDate,
          defaultEndDate: $defaultEndDate,
          defaultLabels: $defaultLabels
        }
      }' >"$tmp"
  fi

  mkdir -p "$(dirname "$cfg_path")"
  mv "$tmp" "$cfg_path"
  echo "[OK] Wrote config: $cfg_path"
}

open_in_editor_or_print() {
  local file_path="$1"
  if [[ -n "${EDITOR-}" ]]; then
    "$EDITOR" "$file_path"
    return 0
  fi
  if command -v nano >/dev/null 2>&1 && is_interactive; then
    nano "$file_path"
    return 0
  fi
  if command -v vi >/dev/null 2>&1 && is_interactive; then
    vi "$file_path"
    return 0
  fi
  echo "[INFO] EDITOR is not set; open this file in your editor:" >&2
  echo "$file_path"
}

labels_csv_to_json() {
  local csv="$1"
  if command -v python3 >/dev/null 2>&1; then
    LABELS_CSV="$csv" python3 - <<'PY'
import json
import os
csv = os.environ.get('LABELS_CSV','')
labels = [x.strip() for x in csv.split(',') if x.strip()]
if not labels:
  labels = ['plan']
print(json.dumps(labels))
PY
    return 0
  fi
  printf '%s' "$csv" | jq -R 'split(",") | map(gsub("^\\s+|\\s+$"; "")) | map(select(length>0)) | if length==0 then ["plan"] else . end'
}

rename_config_for_repo_full() {
  local old_repo_full="$1"
  local new_repo_full="$2"
  local force="${3:-false}"

  local src
  src="$(resolve_config_path_from_repo_full "$old_repo_full" || true)"
  if [[ -z "$src" || ! -f "$src" ]]; then
    echo "[ERROR] Config not found for: $old_repo_full" >&2
    exit 2
  fi

  local dest
  dest="$(config_filename_for_repo_full "$new_repo_full")"
  if [[ -f "$dest" && "$force" != "true" ]]; then
    echo "[ERROR] Target config already exists: $dest" >&2
    echo "[HINT] Re-run with --force to overwrite." >&2
    exit 2
  fi

  mkdir -p "$(dirname "$dest")"
  mv -f "$src" "$dest"
  echo "[OK] Renamed config file: $src -> $dest"
}

rename_config_file_to_repo_full() {
  local src="$1"
  local new_repo_full="$2"
  local force="${3:-false}"

  if [[ -z "$src" || ! -f "$src" ]]; then
    echo "[ERROR] Config file not found: $src" >&2
    exit 2
  fi

  local dest
  dest="$(config_filename_for_repo_full "$new_repo_full")"
  if [[ -f "$dest" && "$force" != "true" ]]; then
    echo "[ERROR] Target config already exists: $dest" >&2
    echo "[HINT] Re-run with --force to overwrite." >&2
    exit 2
  fi

  mkdir -p "$(dirname "$dest")"
  mv -f "$src" "$dest"
  echo "[OK] Renamed config file: $src -> $dest"
}

parse_repo_from_args_for_config() {
  # config commands should default to current repo, else fall back to selection.
  # They also accept --select/--all and --include-disabled.
  mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
  local mode="${parsed[0]}"
  local repo_full="${parsed[1]}"
  local include_disabled="${parsed[2]}"
  local passthrough=("${parsed[@]:3}")

  printf '%s\n' "$mode"
  printf '%s\n' "$repo_full"
  printf '%s\n' "$include_disabled"
  if (( ${#passthrough[@]} > 0 )); then
    printf '%s\n' "${passthrough[@]}"
  fi
}

targets_for_mode() {
  local mode="$1"
  local repo_full="$2"
  local include_disabled="$3"

  local -a targets=()
  case "$mode" in
    repo)
      targets+=("$repo_full")
      ;;
    all)
      if [[ "$include_disabled" == "true" ]]; then
        mapfile -t targets < <(list_known_repos | cut -d'|' -f1)
      else
        mapfile -t targets < <(list_enabled_repo_slugs)
      fi
      ;;
    select)
      if [[ "$include_disabled" == "true" ]]; then
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      else
        mapfile -t targets < <(prompt_select_repo_slugs)
      fi
      ;;
    infer)
      if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        targets+=("$(infer_repo_full_from_cwd)")
      else
        if [[ "$include_disabled" == "true" ]]; then
          mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
        else
          mapfile -t targets < <(prompt_select_repo_slugs)
        fi
      fi
      ;;
  esac

  if (( ${#targets[@]} > 0 )) && [[ "${targets[0]}" == "__CANCEL__" ]]; then
    return 1
  fi

  local t
  for t in "${targets[@]}"; do
    printf '%s\n' "$t"
  done
}

prompt_select_repo_slugs() {
  # Usage: prompt_select_repo_slugs [--include-disabled]
  local include_disabled="false"
  if [[ "${1-}" == "--include-disabled" ]]; then
    include_disabled="true"
  fi

  mapfile -t entries < <(list_known_repos)
  if (( ${#entries[@]} == 0 )); then
    echo "[ERROR] No repos found in $CONFIGS_DIR" >&2
    echo "[HINT] Add configs under sync-helper/configs/*.json with a .repo field." >&2
    exit 2
  fi

  if [[ "$include_disabled" != "true" ]]; then
    local -a filtered=()
    local line
    for line in "${entries[@]}"; do
      IFS='|' read -r _repo _cfg enabled _local_path <<<"$line"
      if [[ "$enabled" == "true" ]]; then
        filtered+=("$line")
      fi
    done
    entries=("${filtered[@]}")

    if (( ${#entries[@]} == 0 )); then
      echo "[ERROR] No enabled repos found in $CONFIGS_DIR" >&2
      echo "[HINT] Use 'gitissuer enable --all' or 'gitissuer enable --select' to enable repos." >&2
      exit 2
    fi
  fi

  local current_repo=""
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    current_repo="$(infer_repo_full_from_cwd 2>/dev/null || true)"
  fi

  local current_enabled="true"
  if [[ -n "$current_repo" ]]; then
    current_enabled="$(is_repo_enabled_in_config "$current_repo")"
  fi

  echo "Select repos:" >&2
  local i=1
  local line
  for line in "${entries[@]}"; do
    IFS='|' read -r repo _cfg enabled local_path <<<"$line"
    local path_hint=""
    if [[ -n "$local_path" ]]; then
      path_hint="$local_path"
    else
      path_hint="(no localPath)"
    fi
    echo "  [$i] $repo (enabled=$enabled, path=$path_hint)" >&2
    ((i++))
  done
  echo "  [a] all" >&2
  if [[ -n "$current_repo" && ( "$include_disabled" == "true" || "$current_enabled" == "true" ) ]]; then
    echo "  [c] current ($current_repo)" >&2
  fi
  echo "  [q] quit" >&2

  local answer
  read -r -p "Selection (e.g. 1,3,5 or a): " answer
  answer="$(printf '%s' "$answer" | tr -d '[:space:]')"
  if [[ -z "$answer" ]]; then
    echo "[ERROR] Empty selection" >&2
    exit 2
  fi

  case "${answer,,}" in
    q)
      printf '%s\n' "__CANCEL__"
      return 0
      ;;
    a)
      local line
      for line in "${entries[@]}"; do
        IFS='|' read -r repo _cfg _enabled _local_path <<<"$line"
        printf '%s\n' "$repo"
      done
      return 0
      ;;
    c)
      if [[ -z "$current_repo" ]]; then
        echo "[ERROR] Not inside a git repo; cannot use 'c'" >&2
        exit 2
      fi
      printf '%s\n' "$current_repo"
      return 0
      ;;
  esac

  # Parse comma-separated indexes: 1,3,5
  local -a picks=()
  local token
  IFS=',' read -r -a picks <<<"$answer"
  local -a out=()
  for token in "${picks[@]}"; do
    if [[ ! "$token" =~ ^[0-9]+$ ]]; then
      echo "[ERROR] Invalid selection token: $token" >&2
      exit 2
    fi
    local idx=$((token - 1))
    if (( idx < 0 || idx >= ${#entries[@]} )); then
      echo "[ERROR] Selection out of range: $token" >&2
      exit 2
    fi
    IFS='|' read -r repo _cfg _enabled _local_path <<<"${entries[$idx]}"
    out+=("$repo")
  done

  # De-duplicate while preserving order
  local seen="|"
  local r
  for r in "${out[@]}"; do
    if [[ "$seen" != *"|$r|"* ]]; then
      printf '%s\n' "$r"
      seen+="$r|"
    fi
  done
}

infer_git_root_from_cwd() {
  require_cmd git
  git rev-parse --show-toplevel 2>/dev/null || true
}

infer_repo_full_from_git_remote() {
  local repo_root="$1"
  require_cmd git

  # Prefer upstream when present to avoid fork-origin mismatches.
  local candidate_url=""
  candidate_url="$(git -C "$repo_root" remote get-url upstream 2>/dev/null || true)"
  if [[ -z "$candidate_url" ]]; then
    candidate_url="$(git -C "$repo_root" remote get-url origin 2>/dev/null || true)"
  fi
  if [[ -z "$candidate_url" ]]; then
    return 1
  fi

  # Support git@github.com:owner/repo(.git) and https://github.com/owner/repo(.git)
  if [[ "$candidate_url" =~ github\.com[:/]+([^/]+)/([^/]+)$ ]]; then
    local owner="${BASH_REMATCH[1]}"
    local repo_raw="${BASH_REMATCH[2]}"
    repo_raw="${repo_raw%.git}"
    printf '%s/%s' "$owner" "$repo_raw"
    return 0
  fi

  return 1
}

infer_repo_full_from_configs_by_path() {
  local repo_root="$1"
  require_cmd jq

  if [[ ! -d "$CONFIGS_DIR" ]]; then
    return 1
  fi

  local repo_root_real
  repo_root_real="$(cd "$repo_root" && pwd)"

  local cfg
  shopt -s nullglob
  for cfg in "$CONFIGS_DIR"/*.json; do
    local local_path
    local_path="$(jq -r '.localPath // empty' "$cfg" 2>/dev/null || true)"
    [[ -z "$local_path" ]] && continue

    local abs
    if [[ "$local_path" = /* ]]; then
      abs="$local_path"
    else
      abs="$ROOT/$local_path"
    fi

    if [[ -d "$abs" ]]; then
      local abs_real
      abs_real="$(cd "$abs" && pwd)"
      if [[ "$abs_real" == "$repo_root_real" ]]; then
        local r
        r="$(jq -r '.repo // empty' "$cfg" 2>/dev/null || true)"
        if [[ -n "$r" ]]; then
          printf '%s' "$r"
          return 0
        fi
      fi
    fi
  done

  return 1
}

infer_repo_full_from_cwd() {
  local repo_root
  repo_root="$(infer_git_root_from_cwd)"
  if [[ -z "$repo_root" ]]; then
    echo "[ERROR] Not inside a git repository and --repo was not provided." >&2
    exit 2
  fi

  local repo_full
  # Prefer sync-helper configs (source of truth) over git remotes.
  # This avoids mismatches when the local origin points to a fork.
  repo_full="$(infer_repo_full_from_configs_by_path "$repo_root" 2>/dev/null || true)"
  if [[ -n "$repo_full" ]]; then
    printf '%s' "$repo_full"
    return 0
  fi

  repo_full="$(infer_repo_full_from_git_remote "$repo_root" 2>/dev/null || true)"
  if [[ -n "$repo_full" ]]; then
    printf '%s' "$repo_full"
    return 0
  fi

  echo "[ERROR] Could not infer --repo from cwd. Ensure origin remote points to github.com or a matching sync-helper config exists." >&2
  exit 2
}

config_repo_path() {
  local config_path="$1"
  local local_path
  local_path="$(jq -r '.localPath // empty' "$config_path" 2>/dev/null || true)"
  if [[ -z "$local_path" ]]; then
    return 1
  fi
  if [[ "$local_path" = /* ]]; then
    printf '%s' "$local_path"
    return 0
  fi
  printf '%s' "$ROOT/$local_path"
}

resolve_repo_path_from_repo_arg() {
  local repo_arg="$1"

  # If it's already a local path, use as-is.
  if [[ -d "$repo_arg" ]]; then
    printf '%s' "$repo_arg"
    return 0
  fi

  # If it looks like owner/name, try to resolve via configs.
  if [[ "$repo_arg" == */* ]]; then
    local want_lc
    want_lc="$(printf '%s' "$repo_arg" | tr '[:upper:]' '[:lower:]')"
    local cfg
    shopt -s nullglob
    for cfg in "$CONFIGS_DIR"/*.json; do
      local r
      r="$(jq -r '.repo // empty' "$cfg" 2>/dev/null || true)"
      if [[ -n "$r" ]]; then
        local r_lc
        r_lc="$(printf '%s' "$r" | tr '[:upper:]' '[:lower:]')"
        if [[ "$r_lc" == "$want_lc" ]]; then
          local path
          path="$(config_repo_path "$cfg" || true)"
          if [[ -n "$path" ]]; then
            printf '%s' "$path"
            return 0
          fi
        fi
      fi
    done
  fi

  # Fall back to the raw argument so callers get a consistent error.
  printf '%s' "$repo_arg"
  return 0
}

resolve_config_path_from_repo_full() {
  local repo_full="$1"
  require_cmd jq

  if [[ ! -d "$CONFIGS_DIR" ]]; then
    echo "";
    return 1
  fi

  local want_lc
  want_lc="$(printf '%s' "$repo_full" | tr '[:upper:]' '[:lower:]')"

  local cfg
  shopt -s nullglob
  for cfg in "$CONFIGS_DIR"/*.json; do
    local r
    r="$(jq -r '.repo // empty' "$cfg" 2>/dev/null || true)"
    [[ -z "$r" ]] && continue
    local r_lc
    r_lc="$(printf '%s' "$r" | tr '[:upper:]' '[:lower:]')"
    if [[ "$r_lc" == "$want_lc" ]]; then
      printf '%s' "$cfg"
      return 0
    fi
  done

  echo "";
  return 1
}

is_repo_enabled_in_config() {
  local repo_full="$1"
  require_cmd jq

  local cfg
  cfg="$(resolve_config_path_from_repo_full "$repo_full" || true)"
  if [[ -z "$cfg" || ! -f "$cfg" ]]; then
    # If there's no config, default to enabled.
    echo "true"
    return 0
  fi

  jq -r 'if .gitissuer.enabled == null then true else .gitissuer.enabled end' "$cfg" 2>/dev/null || echo "true"
}

is_repo_watch_enabled_in_config() {
  local repo_full="$1"
  require_cmd jq

  local cfg
  cfg="$(resolve_config_path_from_repo_full "$repo_full" || true)"
  if [[ -z "$cfg" || ! -f "$cfg" ]]; then
    # If there's no config, default to not watched.
    echo "false"
    return 0
  fi

  jq -r 'if .gitissuer.watch.enabled == null then false else .gitissuer.watch.enabled end' "$cfg" 2>/dev/null || echo "false"
}

set_repo_watch_flag() {
  local repo_full="$1"
  local enabled_value="$2" # true|false
  require_cmd jq

  local cfg
  cfg="$(resolve_config_path_from_repo_full "$repo_full" || true)"
  if [[ -z "$cfg" || ! -f "$cfg" ]]; then
    echo "[ERROR] Could not find config for repo: $repo_full" >&2
    echo "[HINT] Expected a file in $CONFIGS_DIR with .repo == '$repo_full'" >&2
    exit 2
  fi

  local tmp
  tmp="${cfg}.tmp-${$}"
  jq --argjson v "$enabled_value" '(.gitissuer //= {}) | (.gitissuer.watch //= {}) | .gitissuer.watch.enabled = $v' "$cfg" >"$tmp"
  mv "$tmp" "$cfg"
  echo "[OK] Updated $cfg: gitissuer.watch.enabled=$enabled_value"
}

set_repo_enabled_flag() {
  local repo_full="$1"
  local enabled_value="$2" # true|false
  require_cmd jq

  local cfg
  cfg="$(resolve_config_path_from_repo_full "$repo_full" || true)"
  if [[ -z "$cfg" || ! -f "$cfg" ]]; then
    echo "[ERROR] Could not find config for repo: $repo_full" >&2
    echo "[HINT] Expected a file in $CONFIGS_DIR with .repo == '$repo_full'" >&2
    exit 2
  fi

  local tmp
  tmp="${cfg}.tmp-${$}"
  jq --argjson v "$enabled_value" '.gitissuer.enabled = $v' "$cfg" >"$tmp"
  mv "$tmp" "$cfg"
  echo "[OK] Updated $cfg: gitissuer.enabled=$enabled_value"
}

set_repo_parent_issue_number() {
  require_cmd jq
  local repo_full="$1"
  local parent_number="$2"

  if [[ -z "$parent_number" || ! "$parent_number" =~ ^[0-9]+$ ]]; then
    echo "[ERROR] --number must be a positive integer" >&2
    exit 2
  fi

  local cfg
  cfg="$(find_config_for_repo_full "$repo_full")"
  if [[ -z "$cfg" || ! -f "$cfg" ]]; then
    echo "[ERROR] Could not find config for repo: $repo_full" >&2
    echo "[HINT] Expected a file in $CONFIGS_DIR with .repo == '$repo_full'" >&2
    exit 2
  fi

  local tmp
  tmp="${cfg}.tmp-${$}"
  jq --argjson v "$parent_number" '.gitissuer.hierarchy.parentIssueNumber = $v' "$cfg" >"$tmp"
  mv "$tmp" "$cfg"
  echo "[OK] Updated $cfg: gitissuer.hierarchy.parentIssueNumber=$parent_number"
}

clear_repo_parent_issue_number() {
  require_cmd jq
  local repo_full="$1"

  local cfg
  cfg="$(find_config_for_repo_full "$repo_full")"
  if [[ -z "$cfg" || ! -f "$cfg" ]]; then
    echo "[ERROR] Could not find config for repo: $repo_full" >&2
    echo "[HINT] Expected a file in $CONFIGS_DIR with .repo == '$repo_full'" >&2
    exit 2
  fi

  local tmp
  tmp="${cfg}.tmp-${$}"
  jq 'if .gitissuer == null then . else (.gitissuer.hierarchy.parentIssueNumber = null) end' "$cfg" >"$tmp"
  mv "$tmp" "$cfg"
  echo "[OK] Updated $cfg: gitissuer.hierarchy.parentIssueNumber cleared"
}

get_repo_parent_issue_number() {
  require_cmd jq
  local repo_full="$1"
  local cfg
  cfg="$(find_config_for_repo_full "$repo_full")"
  if [[ -z "$cfg" || ! -f "$cfg" ]]; then
    return 0
  fi
  jq -r '.gitissuer.hierarchy.parentIssueNumber // empty' "$cfg" 2>/dev/null || true
}

extract_repo_flag_or_infer() {
  local repo_full=""
  local want_select="false"
  local want_all="false"
  local include_disabled="false"
  local out_args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --repo)
        repo_full="$2"
        shift 2
        ;;
      --select)
        want_select="true"
        shift
        ;;
      --include-disabled)
        include_disabled="true"
        shift
        ;;
      --all)
        want_all="true"
        shift
        ;;
      *)
        out_args+=("$1")
        shift
        ;;
    esac
  done

  # Print targeting mode header:
  # line 1: mode (repo|select|all|infer)
  # line 2: repo_full (only for mode=repo)
  # line 3: include_disabled (true|false)
  if [[ -n "$repo_full" ]]; then
    printf '%s\n' "repo"
    printf '%s\n' "$repo_full"
  elif [[ "$want_all" == "true" ]]; then
    printf '%s\n' "all"
    printf '%s\n' ""
  elif [[ "$want_select" == "true" ]]; then
    printf '%s\n' "select"
    printf '%s\n' ""
  else
    printf '%s\n' "infer"
    printf '%s\n' ""
  fi

  printf '%s\n' "$include_disabled"

  if (( ${#out_args[@]} > 0 )); then
    printf '%s\n' "${out_args[@]}"
  fi
}

run_for_targets() {
  local subcmd="$1"
  shift

  mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
  local mode="${parsed[0]}"
  local repo_full="${parsed[1]}"
  local include_disabled="${parsed[2]}"
  local passthrough=("${parsed[@]:3}")

  local -a targets=()
  case "$mode" in
    repo)
      targets+=("$repo_full")
      ;;
    all)
      mapfile -t targets < <(list_enabled_repo_slugs)
      ;;
    select)
      if [[ "$include_disabled" == "true" ]]; then
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      else
        mapfile -t targets < <(prompt_select_repo_slugs)
      fi
      ;;
    infer)
      if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        targets+=("$(infer_repo_full_from_cwd)")
      else
        if [[ "$include_disabled" == "true" ]]; then
          mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
        else
          mapfile -t targets < <(prompt_select_repo_slugs)
        fi
      fi
      ;;
    *)
      echo "[ERROR] Unknown targeting mode: $mode" >&2
      exit 2
      ;;
  esac

  if (( ${#targets[@]} > 0 )) && [[ "${targets[0]}" == "__CANCEL__" ]]; then
    exit 0
  fi

  if (( ${#targets[@]} == 0 )); then
    echo "[ERROR] No target repos selected." >&2
    exit 2
  fi

  local rc=0
  local t
  for t in "${targets[@]}"; do
    local enabled
    enabled="$(is_repo_enabled_in_config "$t")"
    if [[ "$enabled" != "true" ]]; then
      if handle_disabled_repo_or_exit "$t" "$subcmd"; then
        :
      else
        continue
      fi
    fi
    echo "[INFO] Running $subcmd for $t" >&2

    # Zero-config fallback for the current repo only:
    # If no --config was provided and sync-helper config is missing, generate and use a repo-local config.
    local -a effective_passthrough=("${passthrough[@]}")
    if ! passthrough_has_flag --config "${passthrough[@]}"; then
      local cfg_guess
      cfg_guess="$(config_path_for_repo_full "$t" 2>/dev/null || true)"
      if [[ -z "$cfg_guess" || ! -f "$cfg_guess" ]]; then
        if [[ "$mode" == "infer" ]] && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          local local_cfg
          local_cfg="$(ensure_repo_local_config_for_current_repo "$t" 2>/dev/null || true)"
          if [[ -n "$local_cfg" && -f "$local_cfg" ]]; then
            effective_passthrough+=(--config "$local_cfg")
          fi
        fi
      fi
    fi

    /bin/bash "$ROOT/scripts/gitissuer.sh" "$subcmd" --repo "$t" "${effective_passthrough[@]}" || rc=$?
  done

  exit $rc
}

cmd_doctor() {
  require_cmd git
  echo "gitissuer resolved path: $(command -v gitissuer 2>/dev/null || echo "(not found in PATH)")"
  echo "gitissuer script path: $0"
  echo "gitissuer root: $ROOT"
  echo "configs dir: $CONFIGS_DIR"

  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    local repo_root
    repo_root="$(infer_git_root_from_cwd)"
    echo "cwd git root: $repo_root"

    local repo_full
    repo_full="$(infer_repo_full_from_cwd 2>/dev/null || true)"
    echo "cwd inferred repo: ${repo_full:-"(unable to infer)"}"

    if [[ -n "$repo_full" ]]; then
      local cfg
      cfg="$(config_path_for_repo_full "$repo_full" 2>/dev/null || true)"
      if [[ -n "$cfg" && -f "$cfg" ]]; then
        echo "sync-helper config: $cfg"
      else
        local local_cfg="$repo_root/.gitissuer/gitissuer.sync.json"
        if [[ -f "$local_cfg" ]]; then
          echo "repo-local config: $local_cfg"
        else
          echo "config: (missing)"
          echo "HINT: Run in this repo: gitissuer config create --repo $repo_full --local-path \"$repo_root\"" >&2
          echo "HINT: Or rely on zero-config: gitissuer prepare (will auto-create .gitissuer/gitissuer.sync.json)" >&2
        fi
      fi
    fi
  else
    echo "cwd git root: (not a git repo)"
  fi

  # Detect legacy hardcoded install patterns.
  if [[ "$ROOT" == "/opt/GitIssue-Manager"* ]]; then
    echo "[WARN] This looks like a legacy /opt install. Prefer an npm-linked install to this checkout." >&2
    echo "[HINT] From the GitIssue-Manager repo: npm link" >&2
  fi
}

cmd_install() {
  require_cmd npm
  (cd "$ROOT" && npm link --ignore-scripts)
  echo "[OK] Installed global gitissuer from: $ROOT"

  # If a legacy root-owned wrapper exists, PATH may still resolve to /usr/local/bin/gitissuer.
  if [[ -f "/usr/local/bin/gitissuer" ]]; then
    if head -n 20 /usr/local/bin/gitissuer 2>/dev/null | grep -q 'ROOT="/opt/GitIssue-Manager"'; then
      local npm_prefix
      local npm_bin
      npm_prefix="$(npm prefix -g 2>/dev/null || true)"
      npm_bin=""
      if [[ -n "$npm_prefix" ]]; then
        npm_bin="$npm_prefix/bin"
      fi
      echo "[WARN] Detected legacy wrapper: /usr/local/bin/gitissuer (hardcoded to /opt/GitIssue-Manager)" >&2
      echo "[WARN] It is owned by root; it will override the npm-linked binary in many PATH setups." >&2
      echo "[FIX] If you have sudo, replace it with the npm-linked shim:" >&2
      if [[ -n "$npm_bin" ]]; then
        echo "      sudo rm -f /usr/local/bin/gitissuer" >&2
        echo "      sudo ln -sf \"$npm_bin/gitissuer\" /usr/local/bin/gitissuer" >&2
      else
        echo "      sudo rm -f /usr/local/bin/gitissuer" >&2
        echo "      # then open a new shell and re-run: command -v gitissuer" >&2
      fi
    fi
  fi

  echo "[HINT] Verify with: command -v gitissuer && gitissuer doctor"
}

cmd_uninstall() {
  require_cmd npm
  # Package name is gitissue-manager; npm link creates a global link for it.
  npm unlink -g gitissue-manager >/dev/null 2>&1 || true
  echo "[OK] Unlinked global gitissue-manager (gitissuer)"
}

cmd_prepare() {
  run_for_targets prepare "$@"
}

cmd_rekey() {
  run_for_targets rekey "$@"
}

cmd_sync() {
  run_for_targets sync "$@"
}

cmd_deploy() {
  run_for_targets deploy "$@"
}

cmd_registry_update() {
  run_for_targets registry:update "$@"
}

cmd_apply() {
  run_for_targets apply "$@"
}

cmd_e2e_run() {
  run_for_targets e2e:run "$@"
}

cmd_link_hierarchy() {
  run_for_targets link:hierarchy "$@"
}

cmd_enable() {
  mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
  local mode="${parsed[0]}"
  local repo_full="${parsed[1]}"
  local include_disabled="${parsed[2]}"

  local -a targets=()
  case "$mode" in
    repo) targets+=("$repo_full") ;;
    all) mapfile -t targets < <(list_known_repos | cut -d'|' -f1) ;;
    select)
      if [[ "$include_disabled" == "true" ]]; then
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      else
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      fi
      ;;
    infer)
      if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        targets+=("$(infer_repo_full_from_cwd)")
      else
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      fi
      ;;
  esac

  if (( ${#targets[@]} > 0 )) && [[ "${targets[0]}" == "__CANCEL__" ]]; then
    exit 0
  fi

  local t
  for t in "${targets[@]}"; do
    set_repo_enabled_flag "$t" true
  done
}

cmd_disable() {
  mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
  local mode="${parsed[0]}"
  local repo_full="${parsed[1]}"
  local include_disabled="${parsed[2]}"

  local -a targets=()
  case "$mode" in
    repo) targets+=("$repo_full") ;;
    all) mapfile -t targets < <(list_known_repos | cut -d'|' -f1) ;;
    select)
      if [[ "$include_disabled" == "true" ]]; then
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      else
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      fi
      ;;
    infer)
      if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        targets+=("$(infer_repo_full_from_cwd)")
      else
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      fi
      ;;
  esac

  if (( ${#targets[@]} > 0 )) && [[ "${targets[0]}" == "__CANCEL__" ]]; then
    exit 0
  fi

  local t
  for t in "${targets[@]}"; do
    set_repo_enabled_flag "$t" false
  done
}

cmd_generate() {
  local repo_path=""
  local want_select="false"
  local want_all="false"
  local include_disabled="false"

  generate_for_repo_arg() {
    local arg="$1"

    # If user passed a repo slug (owner/name), enforce gitissuer.enabled when a config exists.
    if [[ ! -d "$arg" && "$arg" == */* ]]; then
      local enabled
      enabled="$(is_repo_enabled_in_config "$arg")"
      if [[ "$enabled" != "true" ]]; then
        if handle_disabled_repo_or_exit "$arg" "generate"; then
          :
        else
          return 0
        fi
      fi
    fi

    local resolved
    resolved="$(resolve_repo_path_from_repo_arg "$arg")"
    if [[ ! -d "$resolved" ]]; then
      echo "[WARN] Could not resolve repo path for: $arg" >&2
      return 0
    fi

    generate_for_repo "$resolved"
  }

  while [[ $# -gt 0 ]]; do
    case "$1" in
      updates) shift ;; # optional keyword
      --repo) repo_path="$2"; shift 2 ;;
      --select) want_select="true"; shift ;;
      --include-disabled) include_disabled="true"; shift ;;
      --all) want_all="true"; shift ;;
      -h|--help) usage; exit 0 ;;
      *) echo "[ERROR] Unknown arg: $1"; usage; exit 1 ;;
    esac
  done

  if [[ -n "$repo_path" ]]; then
    generate_for_repo_arg "$repo_path"
    return 0
  fi

  if [[ "$want_all" == "true" ]]; then
    mapfile -t slugs < <(list_enabled_repo_slugs)
    local s
    for s in "${slugs[@]}"; do
      generate_for_repo_arg "$s"
    done
    return 0
  fi

  if [[ "$want_select" == "true" ]]; then
    if [[ "$include_disabled" == "true" ]]; then
      mapfile -t slugs < <(prompt_select_repo_slugs --include-disabled)
    else
      mapfile -t slugs < <(prompt_select_repo_slugs)
    fi
    if (( ${#slugs[@]} > 0 )) && [[ "${slugs[0]}" == "__CANCEL__" ]]; then
      return 0
    fi
    local s
    for s in "${slugs[@]}"; do
      generate_for_repo_arg "$s"
    done
    return 0
  fi

  # Default behavior: operate on the current repo when --repo is not provided.
  local repo_root
  repo_root="$(infer_git_root_from_cwd)"
  if [[ -z "$repo_root" ]]; then
    echo "[ERROR] Not inside a git repository and --repo was not provided." >&2
    exit 2
  fi

  # Respect gitissuer.enabled for the current repo when a config exists.
  local repo_full
  repo_full="$(infer_repo_full_from_cwd)"
  local enabled
  enabled="$(is_repo_enabled_in_config "$repo_full")"
  if [[ "$enabled" != "true" ]]; then
    if handle_disabled_repo_or_exit "$repo_full" "generate"; then
      :
    else
      return 0
    fi
  fi

  generate_for_repo "$repo_root"
  return 0
}

cmd_config() {
  local sub="${1-}"
  shift || true

  case "$sub" in
    list)
      local include_disabled="false"
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --include-disabled) include_disabled="true"; shift ;;
          -h|--help) usage; exit 0 ;;
          *) echo "[ERROR] Unknown arg: $1"; usage; exit 1 ;;
        esac
      done

      if [[ "$include_disabled" == "true" ]]; then
        list_known_repos | awk -F'|' '{ printf "%s\t(enabled=%s)\t%s\n", $1, $3, $4 }'
      else
        list_known_repos | awk -F'|' '$3 == "true" { printf "%s\t(enabled=%s)\t%s\n", $1, $3, $4 }'
      fi
      ;;

    path)
      mapfile -t parsed < <(parse_repo_from_args_for_config "$@")
      local mode="${parsed[0]}"
      local repo_full="${parsed[1]}"
      local include_disabled="${parsed[2]}"

      mapfile -t targets < <(targets_for_mode "$mode" "$repo_full" "$include_disabled" || true)
      if (( ${#targets[@]} == 0 )); then
        exit 0
      fi
      local t
      for t in "${targets[@]}"; do
        echo "$(config_path_for_repo_full "$t")"
      done
      ;;

    show)
      mapfile -t parsed < <(parse_repo_from_args_for_config "$@")
      local mode="${parsed[0]}"
      local repo_full="${parsed[1]}"
      local include_disabled="${parsed[2]}"

      mapfile -t targets < <(targets_for_mode "$mode" "$repo_full" "$include_disabled" || true)
      if (( ${#targets[@]} == 0 )); then
        exit 0
      fi
      local t
      for t in "${targets[@]}"; do
        local p
        p="$(config_path_for_repo_full "$t")"
        if [[ ! -f "$p" ]]; then
          echo "[WARN] Missing config for $t: $p" >&2
          continue
        fi
        echo "===== $t ====="
        cat "$p"
        echo ""
      done
      ;;

    create)
      local repo_full=""
      local local_path=""
      local want_select="false"
      local include_disabled="true" # config mgmt should be able to target disabled

      local repo_was_inferred="false"

      local enable_project_sync=""
      local auto_deploy=""
      local default_estimate_hours=""
      local default_priority=""
      local default_status=""
      local default_start_date=""
      local default_end_date=""
      local default_labels_csv=""

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --repo) repo_full="$2"; shift 2 ;;
          --local-path) local_path="$2"; shift 2 ;;
          --enable-project-sync) enable_project_sync="true"; shift ;;
          --disable-project-sync) enable_project_sync="false"; shift ;;
          --auto-deploy) auto_deploy="true"; shift ;;
          --no-auto-deploy) auto_deploy="false"; shift ;;
          --default-estimate-hours) default_estimate_hours="$2"; shift 2 ;;
          --default-priority) default_priority="$2"; shift 2 ;;
          --default-status) default_status="$2"; shift 2 ;;
          --default-start-date) default_start_date="$2"; shift 2 ;;
          --default-end-date) default_end_date="$2"; shift 2 ;;
          --default-labels) default_labels_csv="$2"; shift 2 ;;
          --select) want_select="true"; shift ;;
          --all) echo "[ERROR] Refusing config create with --all (too risky). Use --select or --repo." >&2; exit 2 ;;
          --include-disabled) include_disabled="true"; shift ;;
          -h|--help) usage; exit 0 ;;
          *) echo "[ERROR] Unknown arg: $1"; usage; exit 1 ;;
        esac
      done

      if [[ -z "$repo_full" ]]; then
        if [[ "$want_select" == "true" ]]; then
          mapfile -t picked < <(prompt_select_repo_slugs --include-disabled)
          if (( ${#picked[@]} > 0 )) && [[ "${picked[0]}" == "__CANCEL__" ]]; then
            exit 0
          fi
          repo_full="${picked[0]}"
        else
          # Default to current repo if possible; else prompt selection.
          if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
            repo_full="$(infer_repo_full_from_cwd)"
            repo_was_inferred="true"
          else
            mapfile -t picked < <(prompt_select_repo_slugs --include-disabled)
            if (( ${#picked[@]} > 0 )) && [[ "${picked[0]}" == "__CANCEL__" ]]; then
              exit 0
            fi
            repo_full="${picked[0]}"
          fi
        fi
      fi

      if [[ -z "$local_path" ]]; then
        # Only auto-derive localPath when we're running inside the same repo.
        if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          local current
          current="$(infer_repo_full_from_cwd 2>/dev/null || true)"
          if [[ -n "$current" && "$current" == "$repo_full" ]]; then
            export GITISSUER_ROOT="$ROOT"
            export GITISSUER_REPO_ROOT="$(infer_git_root_from_cwd)"
            local_path="$(default_local_path_for_repo_full "$repo_full" || true)"
          fi
        fi
      fi

      # Interactive prompts for missing values.
      if is_interactive; then
        if [[ "$repo_was_inferred" == "true" ]]; then
          repo_full="$(prompt_string "GitHub repo (owner/name)" "$repo_full")"
        fi

        local cfg_path
        cfg_path="$(config_path_for_repo_full "$repo_full")"

        local current_abs
        current_abs=""
        if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          current_abs="$(infer_git_root_from_cwd)"
        fi

        if [[ -z "$local_path" ]]; then
            echo "[INFO] localPath should be an absolute path." >&2
            local_path="$(prompt_string "localPath" "${current_abs:-$(pwd)}")"
        fi

        local_path="$(abs_path "$local_path")"
        if [[ ! -d "$local_path" ]]; then
          echo "[WARN] localPath does not exist: $local_path" >&2
        fi

        local existing_enable_project_sync="false"
        local existing_auto_deploy="false"
        local existing_default_estimate_hours="1"
        local existing_default_priority="NORMAL"
        local existing_default_status="TODO"
        local existing_default_start_date="$(today_yyyy_mm_dd)"
        local existing_default_end_date="TBD"
        local existing_default_labels_csv="plan"

        if [[ -f "$cfg_path" ]]; then
          existing_enable_project_sync="$(jq -r 'if .enableProjectSync == null then false else .enableProjectSync end' "$cfg_path" 2>/dev/null || echo false)"
          existing_auto_deploy="$(jq -r 'if .gitissuer.autoDeploy == null then false else .gitissuer.autoDeploy end' "$cfg_path" 2>/dev/null || echo false)"
          existing_default_estimate_hours="$(jq -r '.defaults.defaultEstimateHours // 1' "$cfg_path" 2>/dev/null || echo 1)"
          existing_default_priority="$(jq -r '.defaults.defaultPriority // "NORMAL"' "$cfg_path" 2>/dev/null || echo NORMAL)"
          existing_default_status="$(jq -r '.defaults.defaultStatus // "TODO"' "$cfg_path" 2>/dev/null || echo TODO)"
          existing_default_start_date="$(jq -r '.defaults.defaultStartDate // "TBD"' "$cfg_path" 2>/dev/null || echo TBD)"
          existing_default_end_date="$(jq -r '.defaults.defaultEndDate // "TBD"' "$cfg_path" 2>/dev/null || echo TBD)"
          existing_default_labels_csv="$(jq -r '.defaults.defaultLabels // ["plan"] | join(",")' "$cfg_path" 2>/dev/null || echo plan)"
        fi

        if [[ -z "$enable_project_sync" ]]; then
          enable_project_sync="$(prompt_bool "Enable ProjectV2 sync?" "$existing_enable_project_sync")"
        fi
        if [[ -z "$auto_deploy" ]]; then
          auto_deploy="$(prompt_bool "Enable autoDeploy?" "$existing_auto_deploy")"
        fi

        if [[ -z "$default_estimate_hours" ]]; then
          default_estimate_hours="$(prompt_string "Default estimate hours" "$existing_default_estimate_hours")"
        fi
        if [[ -z "$default_priority" ]]; then
          default_priority="$(prompt_string "Default priority" "$existing_default_priority")"
        fi
        if [[ -z "$default_status" ]]; then
          default_status="$(prompt_string "Default status" "$existing_default_status")"
        fi
        if [[ -z "$default_start_date" ]]; then
          echo "[HINT] Date format: YYYY-MM-DD (e.g. 2026-01-23)" >&2
          default_start_date="$(prompt_string "Default start date" "$existing_default_start_date")"
        fi
        if [[ -z "$default_end_date" ]]; then
          echo "[HINT] Date format: YYYY-MM-DD or TBD" >&2
          default_end_date="$(prompt_string "Default end date" "$existing_default_end_date")"
        fi
        if [[ -z "$default_labels_csv" ]]; then
          default_labels_csv="$(prompt_string "Default labels (comma-separated)" "$existing_default_labels_csv")"
        fi
      fi

      # Non-interactive fallbacks.
      [[ -z "$enable_project_sync" ]] && enable_project_sync="false"
      [[ -z "$auto_deploy" ]] && auto_deploy="false"
      [[ -z "$default_estimate_hours" ]] && default_estimate_hours="1"
      [[ -z "$default_priority" ]] && default_priority="NORMAL"
      [[ -z "$default_status" ]] && default_status="Backlog"
      [[ -z "$default_start_date" ]] && default_start_date="$(today_yyyy_mm_dd)"
      [[ -z "$default_end_date" ]] && default_end_date="TBD"
      [[ -z "$default_labels_csv" ]] && default_labels_csv="plan"

      create_or_update_config "$repo_full" "$local_path" true \
        "$enable_project_sync" \
        "$auto_deploy" \
        "$default_estimate_hours" \
        "$default_priority" \
        "$default_status" \
        "$default_start_date" \
        "$default_end_date" \
        "$default_labels_csv"
      ;;

    set)
      require_cmd jq

      mapfile -t parsed < <(parse_repo_from_args_for_config --include-disabled "$@")
      local mode="${parsed[0]}"
      local repo_full="${parsed[1]}"
      local include_disabled="${parsed[2]}"
      local rest=("${parsed[@]:3}")

      local new_repo_full=""
      local local_path=""
      local enable_project_sync=""
      local enabled_value=""
      local watch_enabled=""
      local auto_deploy=""
      local parent_issue_number=""

      local default_estimate_hours=""
      local default_priority=""
      local default_status=""
      local default_start_date=""
      local default_end_date=""
      local default_labels_csv=""

      local force="false"

      local i=0
      while [[ $i -lt ${#rest[@]} ]]; do
        case "${rest[$i]}" in
          --set-repo)
            new_repo_full="${rest[$((i+1))]}"; i=$((i+2))
            ;;
          --local-path)
            local_path="${rest[$((i+1))]}"; i=$((i+2))
            ;;
          --enable-project-sync)
            enable_project_sync="true"; i=$((i+1))
            ;;
          --disable-project-sync)
            enable_project_sync="false"; i=$((i+1))
            ;;
          --enabled)
            enabled_value="true"; i=$((i+1))
            ;;
          --disabled)
            enabled_value="false"; i=$((i+1))
            ;;
          --watch-enabled)
            watch_enabled="true"; i=$((i+1))
            ;;
          --watch-disabled)
            watch_enabled="false"; i=$((i+1))
            ;;
          --auto-deploy)
            auto_deploy="true"; i=$((i+1))
            ;;
          --no-auto-deploy)
            auto_deploy="false"; i=$((i+1))
            ;;
          --parent-number)
            parent_issue_number="${rest[$((i+1))]}"; i=$((i+2))
            ;;
          --clear-parent)
            parent_issue_number="__CLEAR__"; i=$((i+1))
            ;;
          --default-estimate-hours)
            default_estimate_hours="${rest[$((i+1))]}"; i=$((i+2))
            ;;
          --default-priority)
            default_priority="${rest[$((i+1))]}"; i=$((i+2))
            ;;
          --default-status)
            default_status="${rest[$((i+1))]}"; i=$((i+2))
            ;;
          --default-start-date)
            default_start_date="${rest[$((i+1))]}"; i=$((i+2))
            ;;
          --default-end-date)
            default_end_date="${rest[$((i+1))]}"; i=$((i+2))
            ;;
          --default-labels)
            default_labels_csv="${rest[$((i+1))]}"; i=$((i+2))
            ;;
          --force)
            force="true"; i=$((i+1))
            ;;
          -h|--help)
            usage; exit 0
            ;;
          *)
            echo "[ERROR] Unknown arg: ${rest[$i]}" >&2
            usage
            exit 1
            ;;
        esac
      done

      mapfile -t targets < <(targets_for_mode "$mode" "$repo_full" "$include_disabled" || true)
      if (( ${#targets[@]} == 0 )); then
        exit 0
      fi
      if (( ${#targets[@]} > 1 )); then
        echo "[ERROR] config set supports a single target. Use --repo or select exactly one." >&2
        exit 2
      fi

      local t="${targets[0]}"
      local cfg
      cfg="$(resolve_config_path_from_repo_full "$t" || true)"
      if [[ -z "$cfg" || ! -f "$cfg" ]]; then
        echo "[ERROR] Missing config for $t" >&2
        echo "[HINT] Create it first: gitissuer config create --repo $t --local-path <path>" >&2
        exit 2
      fi

      local tmp
      tmp="${cfg}.tmp-${$}"

      local effective_repo_full="$t"
      if [[ -n "$new_repo_full" ]]; then
        effective_repo_full="$new_repo_full"
      fi
      local effective_owner="${effective_repo_full%%/*}"

      local effective_local_path=""
      if [[ -n "$local_path" ]]; then
        effective_local_path="$(abs_path "$local_path")"
      fi

      local labels_json=""
      if [[ -n "$default_labels_csv" ]]; then
        labels_json="$(labels_csv_to_json "$default_labels_csv")"
      fi

      jq \
        --arg repo "$effective_repo_full" \
        --arg owner "$effective_owner" \
        --arg localPath "$effective_local_path" \
        --argjson hasLocalPath "$( [[ -n "$effective_local_path" ]] && echo true || echo false )" \
        --argjson enableProjectSync "${enable_project_sync:-null}" \
        --argjson hasEnableProjectSync "$( [[ -n "$enable_project_sync" ]] && echo true || echo false )" \
        --argjson enabled "${enabled_value:-null}" \
        --argjson hasEnabled "$( [[ -n "$enabled_value" ]] && echo true || echo false )" \
        --argjson watchEnabled "${watch_enabled:-null}" \
        --argjson hasWatchEnabled "$( [[ -n "$watch_enabled" ]] && echo true || echo false )" \
        --argjson autoDeploy "${auto_deploy:-null}" \
        --argjson hasAutoDeploy "$( [[ -n "$auto_deploy" ]] && echo true || echo false )" \
        --arg parentNumber "${parent_issue_number:-}" \
        --argjson hasParentNumber "$( [[ -n "$parent_issue_number" ]] && echo true || echo false )" \
        --argjson defaultEstimateHours "${default_estimate_hours:-null}" \
        --argjson hasDefaultEstimateHours "$( [[ -n "$default_estimate_hours" ]] && echo true || echo false )" \
        --arg defaultPriority "${default_priority:-}" \
        --argjson hasDefaultPriority "$( [[ -n "$default_priority" ]] && echo true || echo false )" \
        --arg defaultStatus "${default_status:-}" \
        --argjson hasDefaultStatus "$( [[ -n "$default_status" ]] && echo true || echo false )" \
        --arg defaultStartDate "${default_start_date:-}" \
        --argjson hasDefaultStartDate "$( [[ -n "$default_start_date" ]] && echo true || echo false )" \
        --arg defaultEndDate "${default_end_date:-}" \
        --argjson hasDefaultEndDate "$( [[ -n "$default_end_date" ]] && echo true || echo false )" \
        --argjson defaultLabels "${labels_json:-null}" \
        --argjson hasDefaultLabels "$( [[ -n "$labels_json" ]] && echo true || echo false )" \
        '.
        | .repo = $repo
        | .owner = $owner
        | (if $hasLocalPath then .localPath = $localPath else . end)
        | (if $hasEnableProjectSync then .enableProjectSync = $enableProjectSync else . end)
        | (.gitissuer //= {})
        | (if $hasEnabled then .gitissuer.enabled = $enabled else . end)
        | (if $hasAutoDeploy then .gitissuer.autoDeploy = $autoDeploy else . end)
        | (.gitissuer.watch //= {})
        | (if $hasWatchEnabled then .gitissuer.watch.enabled = $watchEnabled else . end)
        | (if $hasParentNumber then
            if $parentNumber == "__CLEAR__" then
              (.gitissuer.hierarchy.parentIssueNumber = null)
            else
              (.gitissuer.hierarchy.parentIssueNumber = ($parentNumber|tonumber))
            end
          else . end)
        | (.defaults //= {})
        | (if $hasDefaultEstimateHours then .defaults.defaultEstimateHours = $defaultEstimateHours else . end)
        | (if $hasDefaultPriority then .defaults.defaultPriority = $defaultPriority else . end)
        | (if $hasDefaultStatus then .defaults.defaultStatus = $defaultStatus else . end)
        | (if $hasDefaultStartDate then .defaults.defaultStartDate = $defaultStartDate else . end)
        | (if $hasDefaultEndDate then .defaults.defaultEndDate = $defaultEndDate else . end)
        | (if $hasDefaultLabels then .defaults.defaultLabels = $defaultLabels else . end)
        ' \
        "$cfg" >"$tmp"

      mv "$tmp" "$cfg"
      echo "[OK] Updated config: $cfg"

      if [[ -n "$new_repo_full" ]]; then
        rename_config_file_to_repo_full "$cfg" "$new_repo_full" "$force"
      fi
      ;;

    delete|rm|remove)
      require_cmd jq

      mapfile -t parsed < <(parse_repo_from_args_for_config --include-disabled "$@")
      local mode="${parsed[0]}"
      local repo_full="${parsed[1]}"
      local include_disabled="${parsed[2]}"

      local rest=("${parsed[@]:3}")
      local confirm="false"
      local force="false"
      local j=0
      while [[ $j -lt ${#rest[@]} ]]; do
        case "${rest[$j]}" in
          --confirm) confirm="true"; j=$((j+1)) ;;
          --force) force="true"; j=$((j+1)) ;;
          -h|--help) usage; exit 0 ;;
          *)
            echo "[ERROR] Unknown arg: ${rest[$j]}" >&2
            usage
            exit 1
            ;;
        esac
      done

      mapfile -t targets < <(targets_for_mode "$mode" "$repo_full" "$include_disabled" || true)
      if (( ${#targets[@]} == 0 )); then
        exit 0
      fi

      if [[ "$confirm" != "true" && "$force" != "true" ]]; then
        if is_interactive; then
          echo "About to delete ${#targets[@]} config(s):" >&2
          local t
          for t in "${targets[@]}"; do
            echo "  - $t" >&2
          done
          local ans
          read -r -p "Type 'delete' to confirm: " ans
          if [[ "$ans" != "delete" ]]; then
            echo "[INFO] Cancelled." >&2
            exit 0
          fi
        else
          echo "[ERROR] Refusing to delete configs without --confirm in non-interactive mode." >&2
          exit 2
        fi
      fi

      local t
      for t in "${targets[@]}"; do
        local cfg
        cfg="$(resolve_config_path_from_repo_full "$t" || true)"
        if [[ -z "$cfg" || ! -f "$cfg" ]]; then
          echo "[WARN] Config not found for $t" >&2
          continue
        fi
        rm -f "$cfg"
        echo "[OK] Deleted config: $cfg"
      done
      ;;

    dedupe|dedup|duplicates)
      require_cmd jq

      local include_disabled="false"
      local by="both" # repo|path|both
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --include-disabled) include_disabled="true"; shift ;;
          --by) by="$2"; shift 2 ;;
          -h|--help) usage; exit 0 ;;
          *) echo "[ERROR] Unknown arg: $1" >&2; usage; exit 1 ;;
        esac
      done

      if [[ ! -d "$CONFIGS_DIR" ]]; then
        echo "[ERROR] Configs dir not found: $CONFIGS_DIR" >&2
        exit 2
      fi

      # Build a TSV inventory:
      # repo<TAB>enabled<TAB>watch<TAB>localPath<TAB>canonicalLocalPath<TAB>file
      local inventory
      inventory="$(
        shopt -s nullglob
        local cfg
        for cfg in "$CONFIGS_DIR"/*.json; do
          local repo
          repo="$(jq -r '.repo // empty' "$cfg" 2>/dev/null || true)"
          [[ -z "$repo" ]] && continue
          local enabled
          enabled="$(jq -r 'if .gitissuer.enabled == null then true else .gitissuer.enabled end' "$cfg" 2>/dev/null || echo true)"
          local watch
          watch="$(jq -r 'if .gitissuer.watch.enabled == null then false else .gitissuer.watch.enabled end' "$cfg" 2>/dev/null || echo false)"
          local local_path
          local_path="$(jq -r '.localPath // empty' "$cfg" 2>/dev/null || true)"
          if [[ "$include_disabled" != "true" && "$enabled" != "true" ]]; then
            continue
          fi
          local canonical
          canonical="$(canonical_dir_or_abs "$local_path")"
          printf '%s\t%s\t%s\t%s\t%s\t%s\n' "$repo" "$enabled" "$watch" "$local_path" "$canonical" "$cfg"
        done
      )"

      if [[ -z "$inventory" ]]; then
        echo "[INFO] No configs found." >&2
        exit 0
      fi

      local found="false"

      if [[ "$by" == "repo" || "$by" == "both" ]]; then
        # Duplicate repo slugs (case-insensitive)
        local dup_repos
        dup_repos="$(
          printf '%s\n' "$inventory" \
            | awk -F'\t' '{ key=tolower($1); count[key]++; raw[key]=$1 } END { for (k in count) if (count[k] > 1) print raw[k] }' \
            | sort
        )"

        if [[ -n "$dup_repos" ]]; then
          found="true"
          echo "[DUPLICATE] repo (multiple config files share the same .repo):" >&2
          local r
          while IFS= read -r r; do
            [[ -z "$r" ]] && continue
            echo "  - $r" >&2
            printf '%s\n' "$inventory" | awk -F'\t' -v want="$(printf '%s' "$r" | tr '[:upper:]' '[:lower:]')" '{ if (tolower($1)==want) printf "      file=%s enabled=%s watch=%s localPath=%s\n", $6, $2, $3, $4 }'
          done <<<"$dup_repos"
          echo "" >&2
        fi
      fi

      if [[ "$by" == "path" || "$by" == "both" ]]; then
        # Duplicate canonicalLocalPath (case-insensitive). Skip empty paths.
        local dup_paths
        dup_paths="$(
          printf '%s\n' "$inventory" \
            | awk -F'\t' '$5 != "" { key=tolower($5); count[key]++; raw[key]=$5 } END { for (k in count) if (count[k] > 1) print raw[k] }' \
            | sort
        )"

        if [[ -n "$dup_paths" ]]; then
          found="true"
          echo "[DUPLICATE] localPath (multiple repos point to the same directory):" >&2
          local p
          while IFS= read -r p; do
            [[ -z "$p" ]] && continue
            echo "  - $p" >&2
            printf '%s\n' "$inventory" | awk -F'\t' -v want="$(printf '%s' "$p" | tr '[:upper:]' '[:lower:]')" '{ if (tolower($5)==want) printf "      repo=%s enabled=%s watch=%s file=%s\n", $1, $2, $3, $6 }'
          done <<<"$dup_paths"
          echo "" >&2
        fi
      fi

      if [[ "$found" != "true" ]]; then
        echo "[OK] No duplicates detected." >&2
        exit 0
      fi

      echo "[HINT] Delete an unwanted config with: gitissuer config delete --repo <owner/name> --confirm" >&2
      echo "[HINT] Change a repo slug with: gitissuer config set --repo <old> --set-repo <new>" >&2
      ;;

    edit)
      mapfile -t parsed < <(parse_repo_from_args_for_config --include-disabled "$@")
      local mode="${parsed[0]}"
      local repo_full="${parsed[1]}"
      local include_disabled="true"

      mapfile -t targets < <(targets_for_mode "$mode" "$repo_full" "$include_disabled" || true)
      if (( ${#targets[@]} == 0 )); then
        exit 0
      fi
      if (( ${#targets[@]} > 1 )); then
        echo "[ERROR] config edit supports a single target. Use --repo or select exactly one." >&2
        exit 2
      fi
      local t="${targets[0]}"
      local p
      p="$(config_path_for_repo_full "$t")"
      if [[ ! -f "$p" ]]; then
        echo "[INFO] Config does not exist yet; creating minimal config: $p" >&2
        echo "[HINT] You can pass --local-path when creating if needed." >&2
        echo "[ERROR] Missing config for $t. Run: gitissuer config create --repo $t --local-path <path>" >&2
        exit 2
      fi
      open_in_editor_or_print "$p"
      ;;

    ""|help|-h|--help)
      usage
      ;;

    *)
      echo "[ERROR] Unknown config subcommand: $sub" >&2
      usage
      exit 1
      ;;
  esac
}

cmd_check() {
  local sub="${1-}"
  shift || true

  case "$sub" in
    update|updates)
      require_cmd gh
      require_cmd jq

      local limit=20
      local since=""

      # Use standard targeting: --repo/--select/--all + optional --include-disabled
      mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
      local mode="${parsed[0]}"
      local repo_full="${parsed[1]}"
      local include_disabled="${parsed[2]}"
      local rest=("${parsed[@]:3}")

      local i=0
      while [[ $i -lt ${#rest[@]} ]]; do
        case "${rest[$i]}" in
          --limit)
            limit="${rest[$((i+1))]}"; i=$((i+2))
            ;;
          --since)
            since="${rest[$((i+1))]}"; i=$((i+2))
            ;;
          -h|--help)
            usage; exit 0
            ;;
          *)
            echo "[ERROR] Unknown arg: ${rest[$i]}" >&2
            usage
            exit 1
            ;;
        esac
      done

      mapfile -t targets < <(targets_for_mode "$mode" "$repo_full" "$include_disabled" || true)
      if (( ${#targets[@]} == 0 )); then
        exit 0
      fi

      local t
      for t in "${targets[@]}"; do
        local enabled
        enabled="$(is_repo_enabled_in_config "$t")"
        if [[ "$enabled" != "true" ]]; then
          if handle_disabled_repo_or_exit "$t" "check update"; then
            :
          else
            continue
          fi
        fi

        local owner="${t%%/*}"
        local name="${t##*/}"

        echo "===== $t (recent updates) ====="
        # Use REST to sort by updated; filter out PRs.
        local json
        if ! json="$(
          gh api -X GET "/repos/$owner/$name/issues" \
            -f state=all \
            -f sort=updated \
            -f direction=desc \
            -f per_page="$limit"
        )"; then
          echo "[ERROR] Failed to fetch issues for $t via 'gh api'." >&2
          echo "[HINT] Ensure you're authenticated: gh auth status" >&2
          echo "" # keep output formatting stable
          continue
        fi

        if [[ -n "$since" ]]; then
          jq -r --arg since "$since" '
            map(select(.pull_request|not))
            | map(select(.updated_at >= $since))
            | .[]
            | "#\(.number)\t\(.state)\t\(.updated_at)\t\(.title)"' <<<"$json"
        else
          jq -r '
            map(select(.pull_request|not))
            | .[]
            | "#\(.number)\t\(.state)\t\(.updated_at)\t\(.title)"' <<<"$json"
        fi
        echo ""
      done
      ;;

    ""|help|-h|--help)
      usage
      ;;

    *)
      echo "[ERROR] Unknown check subcommand: $sub" >&2
      usage
      exit 1
      ;;
  esac
}

cmd_issues() {
  local sub="${1-}"
  shift || true

  case "$sub" in
    list)
      require_cmd gh
      require_cmd jq

      local state="open" # open|closed|all
      local limit=30
      local show_parents="false"
      local parents_only="false"
      local show_project="false"

      mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
      local mode="${parsed[0]}"
      local repo_full="${parsed[1]}"
      local include_disabled="${parsed[2]}"
      local rest=("${parsed[@]:3}")

      local i=0
      while [[ $i -lt ${#rest[@]} ]]; do
        case "${rest[$i]}" in
          --state)
            state="${rest[$((i+1))]}"; i=$((i+2))
            ;;
          --limit)
            limit="${rest[$((i+1))]}"; i=$((i+2))
            ;;
          --show-parents)
            show_parents="true"; i=$((i+1))
            ;;
          --parents-only)
            parents_only="true"; i=$((i+1))
            ;;
          --show-project)
            show_project="true"; i=$((i+1))
            ;;
          -h|--help)
            usage; exit 0
            ;;
          *)
            echo "[ERROR] Unknown arg: ${rest[$i]}" >&2
            usage
            exit 1
            ;;
        esac
      done

      case "$state" in
        open|closed|all) : ;;
        *)
          echo "[ERROR] --state must be one of: open|closed|all" >&2
          exit 2
          ;;
      esac

      mapfile -t targets < <(targets_for_mode "$mode" "$repo_full" "$include_disabled" || true)
      if (( ${#targets[@]} == 0 )); then
        exit 0
      fi

      local t
      for t in "${targets[@]}"; do
        local enabled
        enabled="$(is_repo_enabled_in_config "$t")"
        if [[ "$enabled" != "true" ]]; then
          if handle_disabled_repo_or_exit "$t" "issues list"; then
            :
          else
            continue
          fi
        fi

        local owner="${t%%/*}"
        local name="${t##*/}"

        local cfg
        cfg="$(resolve_config_path_from_repo_full "$t" || true)"

        local project_sync_enabled="false"
        local project_node_id=""
        local project_url=""

        if [[ -n "$cfg" && -f "$cfg" ]]; then
          project_sync_enabled="$(jq -r 'if .enableProjectSync == null then false else .enableProjectSync end' "$cfg" 2>/dev/null || echo false)"
          project_node_id="$(jq -r '.project.projectNodeId // empty' "$cfg" 2>/dev/null || true)"
          project_url="$(jq -r '.project.url // empty' "$cfg" 2>/dev/null || true)"
        fi

        echo "===== $t (issues, state=$state, limit=$limit) ====="
        if [[ "$show_project" == "true" ]]; then
          if [[ "$project_sync_enabled" != "true" ]]; then
            echo "[INFO] Project sync is disabled for this repo (enableProjectSync=false)." >&2
            echo "[HINT] Enable it with: gitissuer config set --repo $t --enable-project-sync" >&2
          elif [[ -z "$project_node_id" ]]; then
            echo "[WARN] enableProjectSync=true but project.projectNodeId is missing." >&2
            if [[ -n "$project_url" ]]; then
              echo "[HINT] Config project.url is: $project_url" >&2
            fi
            echo "[HINT] Recreate or set project fields in the repo config." >&2
          else
            echo "[INFO] Project: ${project_url:-$project_node_id}" >&2
          fi
        fi

        local query
        if [[ "$state" == "open" ]]; then
          query='query($owner:String!,$name:String!,$first:Int!){repository(owner:$owner,name:$name){issues(first:$first,states:[OPEN],orderBy:{field:UPDATED_AT,direction:DESC}){nodes{number title state updatedAt url parent{number title} projectItems(first:20){nodes{project{id number title}}}}}}}'
        elif [[ "$state" == "closed" ]]; then
          query='query($owner:String!,$name:String!,$first:Int!){repository(owner:$owner,name:$name){issues(first:$first,states:[CLOSED],orderBy:{field:UPDATED_AT,direction:DESC}){nodes{number title state updatedAt url parent{number title} projectItems(first:20){nodes{project{id number title}}}}}}}'
        else
          query='query($owner:String!,$name:String!,$first:Int!){repository(owner:$owner,name:$name){issues(first:$first,orderBy:{field:UPDATED_AT,direction:DESC}){nodes{number title state updatedAt url parent{number title} projectItems(first:20){nodes{project{id number title}}}}}}}'
        fi

        local json
        if ! json="$(gh api graphql -f query="$query" -F owner="$owner" -F name="$name" -F first="$limit")"; then
          echo "[ERROR] Failed to query issues for $t via GraphQL." >&2
          echo "[HINT] Check auth: gh auth status" >&2
          echo ""
          continue
        fi

        jq -r \
          --argjson showParents "$( [[ "$show_parents" == "true" ]] && echo true || echo false )" \
          --argjson parentsOnly "$( [[ "$parents_only" == "true" ]] && echo true || echo false )" \
          --arg projectId "$project_node_id" \
          --argjson showProject "$( [[ "$show_project" == "true" ]] && echo true || echo false )" \
          '
          .data.repository.issues.nodes
          | map(select(. != null))
          | (if $parentsOnly then map(select(.parent != null)) else . end)
          | .[]
          | {
              number,
              state,
              updatedAt,
              title,
              url,
              parentNumber: (.parent.number // null),
              parentTitle: (.parent.title // null),
              inProject: (
                if ($showProject and ($projectId|length) > 0)
                then any(.projectItems.nodes[]?; .project.id == $projectId)
                else null
                end
              )
            }
          | "#\(.number)\t\(.state)\t\(.updatedAt)\t" +
            (if $showProject then (if .inProject == null then "n/a" elif .inProject then "inProject" else "notInProject" end) + "\t" else "" end) +
            (if $showParents then (if .parentNumber == null then "-" else ("#" + (.parentNumber|tostring)) end) + "\t" else "" end) +
            .title
          ' <<<"$json"

        if [[ "$show_project" == "true" && "$project_sync_enabled" == "true" ]]; then
          echo "[HINT] If issues show 'notInProject', run: gitissuer deploy --repo $t --confirm" >&2
        fi

        echo ""
      done
      ;;

    ""|help|-h|--help)
      usage
      ;;

    *)
      echo "[ERROR] Unknown issues subcommand: $sub" >&2
      usage
      exit 1
      ;;
  esac
}

cmd_watch() {
  local sub="${1-}"
  shift || true

  case "$sub" in
    list)
      local include_disabled="false"
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --include-disabled) include_disabled="true"; shift ;;
          -h|--help) usage; exit 0 ;;
          *) echo "[ERROR] Unknown arg: $1"; usage; exit 1 ;;
        esac
      done

      local line
      while IFS='|' read -r repo _cfg enabled local_path; do
        if [[ -z "$repo" ]]; then
          continue
        fi
        if [[ "$include_disabled" != "true" && "$enabled" != "true" ]]; then
          continue
        fi
        local watch
        watch="$(is_repo_watch_enabled_in_config "$repo")"
        printf '%s\t(enabled=%s, watch=%s)\t%s\n' "$repo" "$enabled" "$watch" "$local_path"
      done < <(list_known_repos)
      ;;

    enable|activate)
      mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
      local mode="${parsed[0]}"
      local repo_full="${parsed[1]}"
      local include_disabled="${parsed[2]}"

      mapfile -t targets < <(targets_for_mode "$mode" "$repo_full" "$include_disabled" || true)
      if (( ${#targets[@]} == 0 )); then
        exit 0
      fi
      local t
      for t in "${targets[@]}"; do
        local enabled
        enabled="$(is_repo_enabled_in_config "$t")"
        if [[ "$enabled" != "true" ]]; then
          if handle_disabled_repo_or_exit "$t" "watch enable"; then
            :
          else
            continue
          fi
        fi
        set_repo_watch_flag "$t" true
      done
      ;;

    disable|deactivate)
      mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
      local mode="${parsed[0]}"
      local repo_full="${parsed[1]}"
      local include_disabled="${parsed[2]}"

      mapfile -t targets < <(targets_for_mode "$mode" "$repo_full" "$include_disabled" || true)
      if (( ${#targets[@]} == 0 )); then
        exit 0
      fi
      local t
      for t in "${targets[@]}"; do
        set_repo_watch_flag "$t" false
      done
      ;;

    ""|help|-h|--help)
      usage
      ;;

    *)
      echo "[ERROR] Unknown watch subcommand: $sub" >&2
      usage
      exit 1
      ;;
  esac
}

cmd_parent() {
  local sub="${1-}"
  shift || true

  case "$sub" in
    show)
      local repo_full=""
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --repo) repo_full="$2"; shift 2 ;;
          -h|--help) usage; exit 0 ;;
          *) echo "[ERROR] Unknown arg: $1" >&2; usage; exit 1 ;;
        esac
      done

      if [[ -z "$repo_full" ]]; then
        if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          repo_full="$(infer_repo_full_from_cwd)"
        else
          echo "[ERROR] --repo is required (or run inside the target git repo)." >&2
          exit 2
        fi
      fi

      local n
      n="$(get_repo_parent_issue_number "$repo_full")"
      if [[ -z "$n" ]]; then
        echo "$repo_full	parentIssueNumber=(unset)"
      else
        echo "$repo_full	parentIssueNumber=$n"
      fi
      ;;

    set)
      local repo_full=""
      local number=""
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --repo) repo_full="$2"; shift 2 ;;
          --number) number="$2"; shift 2 ;;
          -h|--help) usage; exit 0 ;;
          *) echo "[ERROR] Unknown arg: $1" >&2; usage; exit 1 ;;
        esac
      done

      if [[ -z "$repo_full" ]]; then
        if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          repo_full="$(infer_repo_full_from_cwd)"
        else
          echo "[ERROR] --repo is required (or run inside the target git repo)." >&2
          exit 2
        fi
      fi

      if [[ -z "$number" ]]; then
        echo "[ERROR] --number <n> is required" >&2
        exit 2
      fi

      set_repo_parent_issue_number "$repo_full" "$number"
      ;;

    clear)
      local repo_full=""
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --repo) repo_full="$2"; shift 2 ;;
          -h|--help) usage; exit 0 ;;
          *) echo "[ERROR] Unknown arg: $1" >&2; usage; exit 1 ;;
        esac
      done

      if [[ -z "$repo_full" ]]; then
        if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          repo_full="$(infer_repo_full_from_cwd)"
        else
          echo "[ERROR] --repo is required (or run inside the target git repo)." >&2
          exit 2
        fi
      fi

      clear_repo_parent_issue_number "$repo_full"
      ;;

    ""|help|-h|--help)
      usage
      ;;

    *)
      echo "[ERROR] Unknown parent subcommand: $sub" >&2
      usage
      exit 1
      ;;
  esac
}

main() {
  local cmd_raw="${1-}"
  shift || true

  # Normalize common command aliases (people tend to omit ':' or use '-'/'_').
  local cmd
  cmd="$(printf '%s' "$cmd_raw" | tr '[:upper:]' '[:lower:]')"
  case "$cmd" in
    registryupdate|registry-update|registry_update) cmd="registry:update" ;;
    e2erun|e2e-run|e2e_run) cmd="e2e:run" ;;
    linkhierarchy|link-hierarchy|link_hierarchy|link:hierarchy) cmd="link:hierarchy" ;;
  esac

  case "$cmd" in
    doctor) cmd_doctor "$@" ;;
    install) cmd_install "$@" ;;
    uninstall) cmd_uninstall "$@" ;;
    generate) cmd_generate "$@" ;;
    prepare) cmd_prepare "$@" ;;
    rekey) cmd_rekey "$@" ;;
    sync) cmd_sync "$@" ;;
    deploy) cmd_deploy "$@" ;;
    registry:update) cmd_registry_update "$@" ;;
    apply) cmd_apply "$@" ;;
    e2e:run) cmd_e2e_run "$@" ;;
    link:hierarchy) cmd_link_hierarchy "$@" ;;
    issues) cmd_issues "$@" ;;
    enable|activate) cmd_enable "$@" ;;
    disable|deactivate) cmd_disable "$@" ;;
    config) cmd_config "$@" ;;
    check) cmd_check "$@" ;;
    watch) cmd_watch "$@" ;;
    parent) cmd_parent "$@" ;;
    ""|help|-h|--help) usage; exit 0 ;;
    *) echo "[ERROR] Unknown command: $cmd"; usage; exit 1 ;;
  esac
}

main "$@"
