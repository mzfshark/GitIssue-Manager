#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
CONFIGS_DIR="$ROOT/sync-helper/configs"

usage() {
  cat <<EOF
Usage: gitissuer <command> [options]

Target selection (all commands):
  --repo <owner/name>   Run against a specific repo
  --select              Interactive prompt (supports multi-select: 1,3,5 and 'a' for all)
  --include-disabled     With --select, also show disabled repos in the prompt
  --all                 Run for all enabled repos in sync-helper/configs (gitissuer.enabled=true)

Commands:
  generate [updates] [--repo <path|owner/name>]        Generate ISSUE_UPDATES.md from git log (defaults to current repo)
  prepare [--repo <owner/name>] [--config <path>]      Generate engine-input.json (defaults to current repo)
  deploy [--repo <owner/name>] [--config <path>] --confirm
                                                       Execute GitHub writes (issues/project sync)
  registry:update [--repo <owner/name>] [--config <path>]
                                                       Update per-repo registry from engine input/output
  apply [--repo <owner/name>] [--config <path>] [--file <ISSUE_UPDATES.md>] [--dry-run|--confirm]
                                                       Apply bounded ISSUE_UPDATES actions using the registry
  e2e:run [--repo <owner/name>] [--config <path>] [--dry-run|--confirm] [--non-interactive]
                                                       Run E2E orchestrator (dry-run by default)
  enable [--repo <owner/name>]                          Enable gitissuer automation for repo config
  disable [--repo <owner/name>]                         Disable gitissuer automation for repo config
  config <list|create|edit|show|path>                  Create/edit per-repo configs in sync-helper/configs
  check update [--repo <owner/name>] [--limit N] [--since <ISO-8601>]  List recently-updated issues in a repo (read-only)
  watch <enable|disable|list>                          Manage gitissuer.watch.enabled per repo (controls systemd watcher targets)

Examples:
  gitissuer generate
  gitissuer generate updates --repo /opt/aragon-app
  gitissuer prepare --repo Axodus/AragonOSX
  gitissuer deploy --repo Axodus/AragonOSX --confirm
  gitissuer registry:update --repo Axodus/AragonOSX
  gitissuer apply --repo Axodus/AragonOSX --dry-run
  gitissuer apply --repo Axodus/AragonOSX --confirm
  gitissuer enable --repo Axodus/AragonOSX
  gitissuer disable --repo Axodus/AragonOSX
  gitissuer config list --include-disabled
  gitissuer config create --repo Axodus/new-repo --local-path ../new-repo
  gitissuer config edit --repo Axodus/AragonOSX
  gitissuer check update --repo Axodus/AragonOSX --limit 20 --since 2026-01-01T00:00:00Z
  gitissuer watch enable --repo Axodus/AragonOSX
  gitissuer watch disable --repo Axodus/AragonOSX
  gitissuer watch list --include-disabled
EOF
}

ensure_dirs() {
  local repo_path="$1"
  mkdir -p "$repo_path/.gitissuer/updates"
}

read_last_generate() {
  local repo_path="$1"
  local state_file="$repo_path/.gitissuer/last-generate.json"
  if [[ -f "$state_file" ]]; then
    jq -r '.last_generate // "1970-01-01T00:00:00Z"' "$state_file"
  else
    echo "1970-01-01T00:00:00Z"
  fi
}

write_last_generate() {
  local repo_path="$1"
  local ts="$2"
  local state_file="$repo_path/.gitissuer/last-generate.json"
  printf '{"last_generate":"%s"}\n' "$ts" >"$state_file"
}

generate_for_repo() {
  local repo_path="$1"
  local repo_name
  repo_name="$(basename "$repo_path")"

  if [[ ! -d "$repo_path/.git" ]]; then
    echo "[WARN] Not a git repo: $repo_path"
    return 0
  fi

  ensure_dirs "$repo_path"

  local last_generate
  last_generate="$(read_last_generate "$repo_path")"

  local commits
  commits="$(git -C "$repo_path" --no-pager log --since="$last_generate" --pretty=format:'- %ad %h %s' --date=iso || true)"

  if [[ -z "$commits" ]]; then
    echo "[INFO] No commits since $last_generate in $repo_name"
    return 0
  fi

  local ts
  ts="$(date -u +%Y%m%dT%H%M%SZ)"

  local updates_file
  updates_file="$repo_path/.gitissuer/updates/${repo_name}_generated_${ts}.md"

  {
    echo "# ISSUE UPDATES"
    echo ""
    echo "Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
    echo ""
    echo "$commits"
  } >"$updates_file"

  cp "$updates_file" "$repo_path/ISSUE_UPDATES.md"

  write_last_generate "$repo_path" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

  echo "[OK] Generated $updates_file"
}

require_cmd() {
  local cmd="$1"
  if ! command -v "$cmd" >/dev/null 2>&1; then
    echo "[ERROR] Missing dependency: $cmd" >&2
    exit 1
  fi
}

list_known_repos() {
  require_cmd jq
  if [[ ! -d "$CONFIGS_DIR" ]]; then
    return 0
  fi

  local cfg
  shopt -s nullglob
  for cfg in "$CONFIGS_DIR"/*.json; do
    local repo
    repo="$(jq -r '.repo // empty' "$cfg" 2>/dev/null || true)"
    [[ -z "$repo" ]] && continue
    local enabled
    enabled="$(jq -r 'if .gitissuer.enabled == null then true else .gitissuer.enabled end' "$cfg" 2>/dev/null || echo true)"
    local local_path
    local_path="$(jq -r '.localPath // empty' "$cfg" 2>/dev/null || true)"
    printf '%s|%s|%s|%s\n' "$repo" "$cfg" "$enabled" "$local_path"
  done
}

list_enabled_repo_slugs() {
  # Output only repos where gitissuer.enabled == true
  list_known_repos | awk -F'|' '$3 == "true" { print $1 }'
}

config_filename_for_repo_full() {
  local repo_full="$1"
  local owner="${repo_full%%/*}"
  local name="${repo_full##*/}"
  printf '%s/%s-%s.json' "$CONFIGS_DIR" "$owner" "$name"
}

config_path_for_repo_full() {
  local repo_full="$1"
  local guessed
  guessed="$(config_filename_for_repo_full "$repo_full")"
  if [[ -f "$guessed" ]]; then
    printf '%s' "$guessed"
    return 0
  fi

  local cfg
  cfg="$(resolve_config_path_from_repo_full "$repo_full" || true)"
  if [[ -n "$cfg" && -f "$cfg" ]]; then
    printf '%s' "$cfg"
    return 0
  fi

  printf '%s' "$guessed"
  return 0
}

default_local_path_for_repo_full() {
  # If running inside the target repo, use a relative path from GitIssue-Manager root.
  local repo_root
  repo_root="$(infer_git_root_from_cwd)"
  if [[ -z "$repo_root" ]]; then
    echo ""
    return 0
  fi

  # Try to compute a relative path using Python if available; else fall back to absolute.
  if command -v python3 >/dev/null 2>&1; then
    python3 - <<'PY'
import os
import sys
root = os.environ.get('GITISSUER_ROOT')
repo = os.environ.get('GITISSUER_REPO_ROOT')
if not root or not repo:
  print('')
  sys.exit(0)
print(os.path.relpath(repo, root))
PY
    return 0
  fi

  echo "$repo_root"
}

create_or_update_config() {
  local repo_full="$1"
  local local_path="$2"
  local enabled_value="${3:-true}"

  require_cmd jq

  if [[ -z "$local_path" ]]; then
    echo "[ERROR] --local-path is required for config create" >&2
    exit 2
  fi

  local cfg_path
  cfg_path="$(config_path_for_repo_full "$repo_full")"

  local owner="${repo_full%%/*}"

  local tmp
  tmp="${cfg_path}.tmp-${$}"

  if [[ -f "$cfg_path" ]]; then
    # Preserve existing config, but ensure required fields exist.
    jq \
      --arg owner "$owner" \
      --arg repo "$repo_full" \
      --arg localPath "$local_path" \
      --argjson enabled "$enabled_value" \
      '.owner = ($owner) | .repo = ($repo) | .localPath = ($localPath) | (.gitissuer //= {}) | .gitissuer.enabled = $enabled' \
      "$cfg_path" >"$tmp"
  else
    # Minimal skeleton config.
    jq -n \
      --arg owner "$owner" \
      --arg repo "$repo_full" \
      --arg localPath "$local_path" \
      --argjson enabled "$enabled_value" \
      '{
        owner: $owner,
        repo: $repo,
        localPath: $localPath,
        enableProjectSync: false,
        gitissuer: { enabled: $enabled, autoDeploy: false },
        defaults: {
          defaultEstimateHours: 1,
          defaultPriority: "NORMAL",
          defaultStatus: "TODO",
          defaultStartDate: "TBD",
          defaultEndDate: "TBD",
          defaultLabels: ["plan"]
        }
      }' >"$tmp"
  fi

  mkdir -p "$(dirname "$cfg_path")"
  mv "$tmp" "$cfg_path"
  echo "[OK] Wrote config: $cfg_path"
}

open_in_editor_or_print() {
  local file_path="$1"
  if [[ -n "${EDITOR-}" ]]; then
    "$EDITOR" "$file_path"
    return 0
  fi
  echo "[INFO] EDITOR is not set; open this file in your editor:" >&2
  echo "$file_path"
}

parse_repo_from_args_for_config() {
  # config commands should default to current repo, else fall back to selection.
  # They also accept --select/--all and --include-disabled.
  mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
  local mode="${parsed[0]}"
  local repo_full="${parsed[1]}"
  local include_disabled="${parsed[2]}"
  local passthrough=("${parsed[@]:3}")

  printf '%s\n' "$mode"
  printf '%s\n' "$repo_full"
  printf '%s\n' "$include_disabled"
  if (( ${#passthrough[@]} > 0 )); then
    printf '%s\n' "${passthrough[@]}"
  fi
}

targets_for_mode() {
  local mode="$1"
  local repo_full="$2"
  local include_disabled="$3"

  local -a targets=()
  case "$mode" in
    repo)
      targets+=("$repo_full")
      ;;
    all)
      if [[ "$include_disabled" == "true" ]]; then
        mapfile -t targets < <(list_known_repos | cut -d'|' -f1)
      else
        mapfile -t targets < <(list_enabled_repo_slugs)
      fi
      ;;
    select)
      if [[ "$include_disabled" == "true" ]]; then
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      else
        mapfile -t targets < <(prompt_select_repo_slugs)
      fi
      ;;
    infer)
      if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        targets+=("$(infer_repo_full_from_cwd)")
      else
        if [[ "$include_disabled" == "true" ]]; then
          mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
        else
          mapfile -t targets < <(prompt_select_repo_slugs)
        fi
      fi
      ;;
  esac

  if (( ${#targets[@]} > 0 )) && [[ "${targets[0]}" == "__CANCEL__" ]]; then
    return 1
  fi

  local t
  for t in "${targets[@]}"; do
    printf '%s\n' "$t"
  done
}

prompt_select_repo_slugs() {
  # Usage: prompt_select_repo_slugs [--include-disabled]
  local include_disabled="false"
  if [[ "${1-}" == "--include-disabled" ]]; then
    include_disabled="true"
  fi

  mapfile -t entries < <(list_known_repos)
  if (( ${#entries[@]} == 0 )); then
    echo "[ERROR] No repos found in $CONFIGS_DIR" >&2
    echo "[HINT] Add configs under sync-helper/configs/*.json with a .repo field." >&2
    exit 2
  fi

  if [[ "$include_disabled" != "true" ]]; then
    local -a filtered=()
    local line
    for line in "${entries[@]}"; do
      IFS='|' read -r _repo _cfg enabled _local_path <<<"$line"
      if [[ "$enabled" == "true" ]]; then
        filtered+=("$line")
      fi
    done
    entries=("${filtered[@]}")

    if (( ${#entries[@]} == 0 )); then
      echo "[ERROR] No enabled repos found in $CONFIGS_DIR" >&2
      echo "[HINT] Use 'gitissuer enable --all' or 'gitissuer enable --select' to enable repos." >&2
      exit 2
    fi
  fi

  local current_repo=""
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    current_repo="$(infer_repo_full_from_cwd 2>/dev/null || true)"
  fi

  local current_enabled="true"
  if [[ -n "$current_repo" ]]; then
    current_enabled="$(is_repo_enabled_in_config "$current_repo")"
  fi

  echo "Select repos:" >&2
  local i=1
  local line
  for line in "${entries[@]}"; do
    IFS='|' read -r repo _cfg enabled local_path <<<"$line"
    local path_hint=""
    if [[ -n "$local_path" ]]; then
      path_hint="$local_path"
    else
      path_hint="(no localPath)"
    fi
    echo "  [$i] $repo (enabled=$enabled, path=$path_hint)" >&2
    ((i++))
  done
  echo "  [a] all" >&2
  if [[ -n "$current_repo" && ( "$include_disabled" == "true" || "$current_enabled" == "true" ) ]]; then
    echo "  [c] current ($current_repo)" >&2
  fi
  echo "  [q] quit" >&2

  local answer
  read -r -p "Selection (e.g. 1,3,5 or a): " answer
  answer="$(printf '%s' "$answer" | tr -d '[:space:]')"
  if [[ -z "$answer" ]]; then
    echo "[ERROR] Empty selection" >&2
    exit 2
  fi

  case "${answer,,}" in
    q)
      printf '%s\n' "__CANCEL__"
      return 0
      ;;
    a)
      local line
      for line in "${entries[@]}"; do
        IFS='|' read -r repo _cfg _enabled _local_path <<<"$line"
        printf '%s\n' "$repo"
      done
      return 0
      ;;
    c)
      if [[ -z "$current_repo" ]]; then
        echo "[ERROR] Not inside a git repo; cannot use 'c'" >&2
        exit 2
      fi
      printf '%s\n' "$current_repo"
      return 0
      ;;
  esac

  # Parse comma-separated indexes: 1,3,5
  local -a picks=()
  local token
  IFS=',' read -r -a picks <<<"$answer"
  local -a out=()
  for token in "${picks[@]}"; do
    if [[ ! "$token" =~ ^[0-9]+$ ]]; then
      echo "[ERROR] Invalid selection token: $token" >&2
      exit 2
    fi
    local idx=$((token - 1))
    if (( idx < 0 || idx >= ${#entries[@]} )); then
      echo "[ERROR] Selection out of range: $token" >&2
      exit 2
    fi
    IFS='|' read -r repo _cfg _enabled _local_path <<<"${entries[$idx]}"
    out+=("$repo")
  done

  # De-duplicate while preserving order
  local seen="|"
  local r
  for r in "${out[@]}"; do
    if [[ "$seen" != *"|$r|"* ]]; then
      printf '%s\n' "$r"
      seen+="$r|"
    fi
  done
}

infer_git_root_from_cwd() {
  require_cmd git
  git rev-parse --show-toplevel 2>/dev/null || true
}

infer_repo_full_from_git_remote() {
  local repo_root="$1"
  require_cmd git

  local remote_url
  remote_url="$(git -C "$repo_root" remote get-url origin 2>/dev/null || true)"
  if [[ -z "$remote_url" ]]; then
    return 1
  fi

  # Support git@github.com:owner/repo(.git) and https://github.com/owner/repo(.git)
  if [[ "$remote_url" =~ github\.com[:/]+([^/]+)/([^/]+)$ ]]; then
    local owner="${BASH_REMATCH[1]}"
    local repo_raw="${BASH_REMATCH[2]}"
    repo_raw="${repo_raw%.git}"
    printf '%s/%s' "$owner" "$repo_raw"
    return 0
  fi

  return 1
}

infer_repo_full_from_configs_by_path() {
  local repo_root="$1"
  require_cmd jq

  if [[ ! -d "$CONFIGS_DIR" ]]; then
    return 1
  fi

  local repo_root_real
  repo_root_real="$(cd "$repo_root" && pwd)"

  local cfg
  shopt -s nullglob
  for cfg in "$CONFIGS_DIR"/*.json; do
    local local_path
    local_path="$(jq -r '.localPath // empty' "$cfg" 2>/dev/null || true)"
    [[ -z "$local_path" ]] && continue

    local abs
    if [[ "$local_path" = /* ]]; then
      abs="$local_path"
    else
      abs="$ROOT/$local_path"
    fi

    if [[ -d "$abs" ]]; then
      local abs_real
      abs_real="$(cd "$abs" && pwd)"
      if [[ "$abs_real" == "$repo_root_real" ]]; then
        local r
        r="$(jq -r '.repo // empty' "$cfg" 2>/dev/null || true)"
        if [[ -n "$r" ]]; then
          printf '%s' "$r"
          return 0
        fi
      fi
    fi
  done

  return 1
}

infer_repo_full_from_cwd() {
  local repo_root
  repo_root="$(infer_git_root_from_cwd)"
  if [[ -z "$repo_root" ]]; then
    echo "[ERROR] Not inside a git repository and --repo was not provided." >&2
    exit 2
  fi

  local repo_full
  # Prefer sync-helper configs (source of truth) over git remotes.
  # This avoids mismatches when the local origin points to a fork.
  repo_full="$(infer_repo_full_from_configs_by_path "$repo_root" 2>/dev/null || true)"
  if [[ -n "$repo_full" ]]; then
    printf '%s' "$repo_full"
    return 0
  fi

  repo_full="$(infer_repo_full_from_git_remote "$repo_root" 2>/dev/null || true)"
  if [[ -n "$repo_full" ]]; then
    printf '%s' "$repo_full"
    return 0
  fi

  echo "[ERROR] Could not infer --repo from cwd. Ensure origin remote points to github.com or a matching sync-helper config exists." >&2
  exit 2
}

config_repo_path() {
  local config_path="$1"
  local local_path
  local_path="$(jq -r '.localPath // empty' "$config_path" 2>/dev/null || true)"
  if [[ -z "$local_path" ]]; then
    return 1
  fi
  if [[ "$local_path" = /* ]]; then
    printf '%s' "$local_path"
    return 0
  fi
  printf '%s' "$ROOT/$local_path"
}

resolve_repo_path_from_repo_arg() {
  local repo_arg="$1"

  # If it's already a local path, use as-is.
  if [[ -d "$repo_arg" ]]; then
    printf '%s' "$repo_arg"
    return 0
  fi

  # If it looks like owner/name, try to resolve via configs.
  if [[ "$repo_arg" == */* ]]; then
    local want_lc
    want_lc="$(printf '%s' "$repo_arg" | tr '[:upper:]' '[:lower:]')"
    local cfg
    shopt -s nullglob
    for cfg in "$CONFIGS_DIR"/*.json; do
      local r
      r="$(jq -r '.repo // empty' "$cfg" 2>/dev/null || true)"
      if [[ -n "$r" ]]; then
        local r_lc
        r_lc="$(printf '%s' "$r" | tr '[:upper:]' '[:lower:]')"
        if [[ "$r_lc" == "$want_lc" ]]; then
          local path
          path="$(config_repo_path "$cfg" || true)"
          if [[ -n "$path" ]]; then
            printf '%s' "$path"
            return 0
          fi
        fi
      fi
    done
  fi

  # Fall back to the raw argument so callers get a consistent error.
  printf '%s' "$repo_arg"
  return 0
}

resolve_config_path_from_repo_full() {
  local repo_full="$1"
  require_cmd jq

  if [[ ! -d "$CONFIGS_DIR" ]]; then
    echo "";
    return 1
  fi

  local want_lc
  want_lc="$(printf '%s' "$repo_full" | tr '[:upper:]' '[:lower:]')"

  local cfg
  shopt -s nullglob
  for cfg in "$CONFIGS_DIR"/*.json; do
    local r
    r="$(jq -r '.repo // empty' "$cfg" 2>/dev/null || true)"
    [[ -z "$r" ]] && continue
    local r_lc
    r_lc="$(printf '%s' "$r" | tr '[:upper:]' '[:lower:]')"
    if [[ "$r_lc" == "$want_lc" ]]; then
      printf '%s' "$cfg"
      return 0
    fi
  done

  echo "";
  return 1
}

is_repo_enabled_in_config() {
  local repo_full="$1"
  require_cmd jq

  local cfg
  cfg="$(resolve_config_path_from_repo_full "$repo_full" || true)"
  if [[ -z "$cfg" || ! -f "$cfg" ]]; then
    # If there's no config, default to enabled.
    echo "true"
    return 0
  fi

  jq -r 'if .gitissuer.enabled == null then true else .gitissuer.enabled end' "$cfg" 2>/dev/null || echo "true"
}

is_repo_watch_enabled_in_config() {
  local repo_full="$1"
  require_cmd jq

  local cfg
  cfg="$(resolve_config_path_from_repo_full "$repo_full" || true)"
  if [[ -z "$cfg" || ! -f "$cfg" ]]; then
    # If there's no config, default to not watched.
    echo "false"
    return 0
  fi

  jq -r 'if .gitissuer.watch.enabled == null then false else .gitissuer.watch.enabled end' "$cfg" 2>/dev/null || echo "false"
}

set_repo_watch_flag() {
  local repo_full="$1"
  local enabled_value="$2" # true|false
  require_cmd jq

  local cfg
  cfg="$(resolve_config_path_from_repo_full "$repo_full" || true)"
  if [[ -z "$cfg" || ! -f "$cfg" ]]; then
    echo "[ERROR] Could not find config for repo: $repo_full" >&2
    echo "[HINT] Expected a file in $CONFIGS_DIR with .repo == '$repo_full'" >&2
    exit 2
  fi

  local tmp
  tmp="${cfg}.tmp-${$}"
  jq --argjson v "$enabled_value" '(.gitissuer //= {}) | (.gitissuer.watch //= {}) | .gitissuer.watch.enabled = $v' "$cfg" >"$tmp"
  mv "$tmp" "$cfg"
  echo "[OK] Updated $cfg: gitissuer.watch.enabled=$enabled_value"
}

set_repo_enabled_flag() {
  local repo_full="$1"
  local enabled_value="$2" # true|false
  require_cmd jq

  local cfg
  cfg="$(resolve_config_path_from_repo_full "$repo_full" || true)"
  if [[ -z "$cfg" || ! -f "$cfg" ]]; then
    echo "[ERROR] Could not find config for repo: $repo_full" >&2
    echo "[HINT] Expected a file in $CONFIGS_DIR with .repo == '$repo_full'" >&2
    exit 2
  fi

  local tmp
  tmp="${cfg}.tmp-${$}"
  jq --argjson v "$enabled_value" '.gitissuer.enabled = $v' "$cfg" >"$tmp"
  mv "$tmp" "$cfg"
  echo "[OK] Updated $cfg: gitissuer.enabled=$enabled_value"
}

extract_repo_flag_or_infer() {
  local repo_full=""
  local want_select="false"
  local want_all="false"
  local include_disabled="false"
  local out_args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --repo)
        repo_full="$2"
        shift 2
        ;;
      --select)
        want_select="true"
        shift
        ;;
      --include-disabled)
        include_disabled="true"
        shift
        ;;
      --all)
        want_all="true"
        shift
        ;;
      *)
        out_args+=("$1")
        shift
        ;;
    esac
  done

  # Print targeting mode header:
  # line 1: mode (repo|select|all|infer)
  # line 2: repo_full (only for mode=repo)
  # line 3: include_disabled (true|false)
  if [[ -n "$repo_full" ]]; then
    printf '%s\n' "repo"
    printf '%s\n' "$repo_full"
  elif [[ "$want_all" == "true" ]]; then
    printf '%s\n' "all"
    printf '%s\n' ""
  elif [[ "$want_select" == "true" ]]; then
    printf '%s\n' "select"
    printf '%s\n' ""
  else
    printf '%s\n' "infer"
    printf '%s\n' ""
  fi

  printf '%s\n' "$include_disabled"

  if (( ${#out_args[@]} > 0 )); then
    printf '%s\n' "${out_args[@]}"
  fi
}

run_for_targets() {
  local subcmd="$1"
  shift

  mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
  local mode="${parsed[0]}"
  local repo_full="${parsed[1]}"
  local include_disabled="${parsed[2]}"
  local passthrough=("${parsed[@]:3}")

  local -a targets=()
  case "$mode" in
    repo)
      targets+=("$repo_full")
      ;;
    all)
      mapfile -t targets < <(list_enabled_repo_slugs)
      ;;
    select)
      if [[ "$include_disabled" == "true" ]]; then
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      else
        mapfile -t targets < <(prompt_select_repo_slugs)
      fi
      ;;
    infer)
      if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        targets+=("$(infer_repo_full_from_cwd)")
      else
        if [[ "$include_disabled" == "true" ]]; then
          mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
        else
          mapfile -t targets < <(prompt_select_repo_slugs)
        fi
      fi
      ;;
    *)
      echo "[ERROR] Unknown targeting mode: $mode" >&2
      exit 2
      ;;
  esac

  if (( ${#targets[@]} > 0 )) && [[ "${targets[0]}" == "__CANCEL__" ]]; then
    exit 0
  fi

  if (( ${#targets[@]} == 0 )); then
    echo "[ERROR] No target repos selected." >&2
    exit 2
  fi

  local rc=0
  local t
  for t in "${targets[@]}"; do
    local enabled
    enabled="$(is_repo_enabled_in_config "$t")"
    if [[ "$enabled" != "true" ]]; then
      echo "[INFO] Skipping disabled repo: $t" >&2
      continue
    fi
    echo "[INFO] Running $subcmd for $t" >&2
    /bin/bash "$ROOT/scripts/gitissuer.sh" "$subcmd" --repo "$t" "${passthrough[@]}" || rc=$?
  done

  exit $rc
}

cmd_prepare() {
  run_for_targets prepare "$@"
}

cmd_deploy() {
  run_for_targets deploy "$@"
}

cmd_registry_update() {
  run_for_targets registry:update "$@"
}

cmd_apply() {
  run_for_targets apply "$@"
}

cmd_e2e_run() {
  run_for_targets e2e:run "$@"
}

cmd_enable() {
  mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
  local mode="${parsed[0]}"
  local repo_full="${parsed[1]}"
  local include_disabled="${parsed[2]}"

  local -a targets=()
  case "$mode" in
    repo) targets+=("$repo_full") ;;
    all) mapfile -t targets < <(list_known_repos | cut -d'|' -f1) ;;
    select)
      if [[ "$include_disabled" == "true" ]]; then
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      else
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      fi
      ;;
    infer)
      if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        targets+=("$(infer_repo_full_from_cwd)")
      else
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      fi
      ;;
  esac

  if (( ${#targets[@]} > 0 )) && [[ "${targets[0]}" == "__CANCEL__" ]]; then
    exit 0
  fi

  local t
  for t in "${targets[@]}"; do
    set_repo_enabled_flag "$t" true
  done
}

cmd_disable() {
  mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
  local mode="${parsed[0]}"
  local repo_full="${parsed[1]}"
  local include_disabled="${parsed[2]}"

  local -a targets=()
  case "$mode" in
    repo) targets+=("$repo_full") ;;
    all) mapfile -t targets < <(list_known_repos | cut -d'|' -f1) ;;
    select)
      if [[ "$include_disabled" == "true" ]]; then
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      else
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      fi
      ;;
    infer)
      if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        targets+=("$(infer_repo_full_from_cwd)")
      else
        mapfile -t targets < <(prompt_select_repo_slugs --include-disabled)
      fi
      ;;
  esac

  if (( ${#targets[@]} > 0 )) && [[ "${targets[0]}" == "__CANCEL__" ]]; then
    exit 0
  fi

  local t
  for t in "${targets[@]}"; do
    set_repo_enabled_flag "$t" false
  done
}

cmd_generate() {
  local repo_path=""
  local want_select="false"
  local want_all="false"
  local include_disabled="false"

  generate_for_repo_arg() {
    local arg="$1"

    # If user passed a repo slug (owner/name), enforce gitissuer.enabled when a config exists.
    if [[ ! -d "$arg" && "$arg" == */* ]]; then
      local enabled
      enabled="$(is_repo_enabled_in_config "$arg")"
      if [[ "$enabled" != "true" ]]; then
        echo "[INFO] Skipping generate because gitissuer.enabled=false for $arg"
        return 0
      fi
    fi

    local resolved
    resolved="$(resolve_repo_path_from_repo_arg "$arg")"
    if [[ ! -d "$resolved" ]]; then
      echo "[WARN] Could not resolve repo path for: $arg" >&2
      return 0
    fi

    generate_for_repo "$resolved"
  }

  while [[ $# -gt 0 ]]; do
    case "$1" in
      updates) shift ;; # optional keyword
      --repo) repo_path="$2"; shift 2 ;;
      --select) want_select="true"; shift ;;
      --include-disabled) include_disabled="true"; shift ;;
      --all) want_all="true"; shift ;;
      -h|--help) usage; exit 0 ;;
      *) echo "[ERROR] Unknown arg: $1"; usage; exit 1 ;;
    esac
  done

  if [[ -n "$repo_path" ]]; then
    generate_for_repo_arg "$repo_path"
    return 0
  fi

  if [[ "$want_all" == "true" ]]; then
    mapfile -t slugs < <(list_enabled_repo_slugs)
    local s
    for s in "${slugs[@]}"; do
      generate_for_repo_arg "$s"
    done
    return 0
  fi

  if [[ "$want_select" == "true" ]]; then
    if [[ "$include_disabled" == "true" ]]; then
      mapfile -t slugs < <(prompt_select_repo_slugs --include-disabled)
    else
      mapfile -t slugs < <(prompt_select_repo_slugs)
    fi
    if (( ${#slugs[@]} > 0 )) && [[ "${slugs[0]}" == "__CANCEL__" ]]; then
      return 0
    fi
    local s
    for s in "${slugs[@]}"; do
      generate_for_repo_arg "$s"
    done
    return 0
  fi

  # Default behavior: operate on the current repo when --repo is not provided.
  local repo_root
  repo_root="$(infer_git_root_from_cwd)"
  if [[ -z "$repo_root" ]]; then
    echo "[ERROR] Not inside a git repository and --repo was not provided." >&2
    exit 2
  fi

  # Respect gitissuer.enabled for the current repo when a config exists.
  local repo_full
  repo_full="$(infer_repo_full_from_cwd)"
  local enabled
  enabled="$(is_repo_enabled_in_config "$repo_full")"
  if [[ "$enabled" != "true" ]]; then
    echo "[INFO] Skipping generate because gitissuer.enabled=false for $repo_full"
    return 0
  fi

  generate_for_repo "$repo_root"
  return 0
}

cmd_config() {
  local sub="${1-}"
  shift || true

  case "$sub" in
    list)
      local include_disabled="false"
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --include-disabled) include_disabled="true"; shift ;;
          -h|--help) usage; exit 0 ;;
          *) echo "[ERROR] Unknown arg: $1"; usage; exit 1 ;;
        esac
      done

      if [[ "$include_disabled" == "true" ]]; then
        list_known_repos | awk -F'|' '{ printf "%s\t(enabled=%s)\t%s\n", $1, $3, $4 }'
      else
        list_known_repos | awk -F'|' '$3 == "true" { printf "%s\t(enabled=%s)\t%s\n", $1, $3, $4 }'
      fi
      ;;

    path)
      mapfile -t parsed < <(parse_repo_from_args_for_config "$@")
      local mode="${parsed[0]}"
      local repo_full="${parsed[1]}"
      local include_disabled="${parsed[2]}"

      mapfile -t targets < <(targets_for_mode "$mode" "$repo_full" "$include_disabled" || true)
      if (( ${#targets[@]} == 0 )); then
        exit 0
      fi
      local t
      for t in "${targets[@]}"; do
        echo "$(config_path_for_repo_full "$t")"
      done
      ;;

    show)
      mapfile -t parsed < <(parse_repo_from_args_for_config "$@")
      local mode="${parsed[0]}"
      local repo_full="${parsed[1]}"
      local include_disabled="${parsed[2]}"

      mapfile -t targets < <(targets_for_mode "$mode" "$repo_full" "$include_disabled" || true)
      if (( ${#targets[@]} == 0 )); then
        exit 0
      fi
      local t
      for t in "${targets[@]}"; do
        local p
        p="$(config_path_for_repo_full "$t")"
        if [[ ! -f "$p" ]]; then
          echo "[WARN] Missing config for $t: $p" >&2
          continue
        fi
        echo "===== $t ====="
        cat "$p"
        echo ""
      done
      ;;

    create)
      local repo_full=""
      local local_path=""
      local want_select="false"
      local include_disabled="true" # config mgmt should be able to target disabled

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --repo) repo_full="$2"; shift 2 ;;
          --local-path) local_path="$2"; shift 2 ;;
          --select) want_select="true"; shift ;;
          --all) echo "[ERROR] Refusing config create with --all (too risky). Use --select or --repo." >&2; exit 2 ;;
          --include-disabled) include_disabled="true"; shift ;;
          -h|--help) usage; exit 0 ;;
          *) echo "[ERROR] Unknown arg: $1"; usage; exit 1 ;;
        esac
      done

      if [[ -z "$repo_full" ]]; then
        if [[ "$want_select" == "true" ]]; then
          mapfile -t picked < <(prompt_select_repo_slugs --include-disabled)
          if (( ${#picked[@]} > 0 )) && [[ "${picked[0]}" == "__CANCEL__" ]]; then
            exit 0
          fi
          repo_full="${picked[0]}"
        else
          # Default to current repo if possible; else prompt selection.
          if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
            repo_full="$(infer_repo_full_from_cwd)"
          else
            mapfile -t picked < <(prompt_select_repo_slugs --include-disabled)
            if (( ${#picked[@]} > 0 )) && [[ "${picked[0]}" == "__CANCEL__" ]]; then
              exit 0
            fi
            repo_full="${picked[0]}"
          fi
        fi
      fi

      if [[ -z "$local_path" ]]; then
        # Only auto-derive localPath when we're running inside the same repo.
        if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          local current
          current="$(infer_repo_full_from_cwd 2>/dev/null || true)"
          if [[ -n "$current" && "$current" == "$repo_full" ]]; then
            export GITISSUER_ROOT="$ROOT"
            export GITISSUER_REPO_ROOT="$(infer_git_root_from_cwd)"
            local_path="$(default_local_path_for_repo_full "$repo_full" || true)"
          fi
        fi
      fi

      create_or_update_config "$repo_full" "$local_path" true
      ;;

    edit)
      mapfile -t parsed < <(parse_repo_from_args_for_config --include-disabled "$@")
      local mode="${parsed[0]}"
      local repo_full="${parsed[1]}"
      local include_disabled="true"

      mapfile -t targets < <(targets_for_mode "$mode" "$repo_full" "$include_disabled" || true)
      if (( ${#targets[@]} == 0 )); then
        exit 0
      fi
      if (( ${#targets[@]} > 1 )); then
        echo "[ERROR] config edit supports a single target. Use --repo or select exactly one." >&2
        exit 2
      fi
      local t="${targets[0]}"
      local p
      p="$(config_path_for_repo_full "$t")"
      if [[ ! -f "$p" ]]; then
        echo "[INFO] Config does not exist yet; creating minimal config: $p" >&2
        echo "[HINT] You can pass --local-path when creating if needed." >&2
        echo "[ERROR] Missing config for $t. Run: gitissuer config create --repo $t --local-path <path>" >&2
        exit 2
      fi
      open_in_editor_or_print "$p"
      ;;

    ""|help|-h|--help)
      usage
      ;;

    *)
      echo "[ERROR] Unknown config subcommand: $sub" >&2
      usage
      exit 1
      ;;
  esac
}

cmd_check() {
  local sub="${1-}"
  shift || true

  case "$sub" in
    update|updates)
      require_cmd gh
      require_cmd jq

      local limit=20
      local since=""

      # Use standard targeting: --repo/--select/--all + optional --include-disabled
      mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
      local mode="${parsed[0]}"
      local repo_full="${parsed[1]}"
      local include_disabled="${parsed[2]}"
      local rest=("${parsed[@]:3}")

      local i=0
      while [[ $i -lt ${#rest[@]} ]]; do
        case "${rest[$i]}" in
          --limit)
            limit="${rest[$((i+1))]}"; i=$((i+2))
            ;;
          --since)
            since="${rest[$((i+1))]}"; i=$((i+2))
            ;;
          -h|--help)
            usage; exit 0
            ;;
          *)
            echo "[ERROR] Unknown arg: ${rest[$i]}" >&2
            usage
            exit 1
            ;;
        esac
      done

      mapfile -t targets < <(targets_for_mode "$mode" "$repo_full" "$include_disabled" || true)
      if (( ${#targets[@]} == 0 )); then
        exit 0
      fi

      local t
      for t in "${targets[@]}"; do
        local enabled
        enabled="$(is_repo_enabled_in_config "$t")"
        if [[ "$enabled" != "true" ]]; then
          echo "[INFO] Skipping disabled repo: $t" >&2
          continue
        fi

        local owner="${t%%/*}"
        local name="${t##*/}"

        echo "===== $t (recent updates) ====="
        # Use REST to sort by updated; filter out PRs.
        local json
        if ! json="$(
          gh api -X GET "/repos/$owner/$name/issues" \
            -f state=all \
            -f sort=updated \
            -f direction=desc \
            -f per_page="$limit"
        )"; then
          echo "[ERROR] Failed to fetch issues for $t via 'gh api'." >&2
          echo "[HINT] Ensure you're authenticated: gh auth status" >&2
          echo "" # keep output formatting stable
          continue
        fi

        if [[ -n "$since" ]]; then
          jq -r --arg since "$since" '
            map(select(.pull_request|not))
            | map(select(.updated_at >= $since))
            | .[]
            | "#\(.number)\t\(.state)\t\(.updated_at)\t\(.title)"' <<<"$json"
        else
          jq -r '
            map(select(.pull_request|not))
            | .[]
            | "#\(.number)\t\(.state)\t\(.updated_at)\t\(.title)"' <<<"$json"
        fi
        echo ""
      done
      ;;

    ""|help|-h|--help)
      usage
      ;;

    *)
      echo "[ERROR] Unknown check subcommand: $sub" >&2
      usage
      exit 1
      ;;
  esac
}

cmd_watch() {
  local sub="${1-}"
  shift || true

  case "$sub" in
    list)
      local include_disabled="false"
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --include-disabled) include_disabled="true"; shift ;;
          -h|--help) usage; exit 0 ;;
          *) echo "[ERROR] Unknown arg: $1"; usage; exit 1 ;;
        esac
      done

      local line
      while IFS='|' read -r repo _cfg enabled local_path; do
        if [[ -z "$repo" ]]; then
          continue
        fi
        if [[ "$include_disabled" != "true" && "$enabled" != "true" ]]; then
          continue
        fi
        local watch
        watch="$(is_repo_watch_enabled_in_config "$repo")"
        printf '%s\t(enabled=%s, watch=%s)\t%s\n' "$repo" "$enabled" "$watch" "$local_path"
      done < <(list_known_repos)
      ;;

    enable|activate)
      mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
      local mode="${parsed[0]}"
      local repo_full="${parsed[1]}"
      local include_disabled="${parsed[2]}"

      mapfile -t targets < <(targets_for_mode "$mode" "$repo_full" "$include_disabled" || true)
      if (( ${#targets[@]} == 0 )); then
        exit 0
      fi
      local t
      for t in "${targets[@]}"; do
        set_repo_watch_flag "$t" true
      done
      ;;

    disable|deactivate)
      mapfile -t parsed < <(extract_repo_flag_or_infer "$@")
      local mode="${parsed[0]}"
      local repo_full="${parsed[1]}"
      local include_disabled="${parsed[2]}"

      mapfile -t targets < <(targets_for_mode "$mode" "$repo_full" "$include_disabled" || true)
      if (( ${#targets[@]} == 0 )); then
        exit 0
      fi
      local t
      for t in "${targets[@]}"; do
        set_repo_watch_flag "$t" false
      done
      ;;

    ""|help|-h|--help)
      usage
      ;;

    *)
      echo "[ERROR] Unknown watch subcommand: $sub" >&2
      usage
      exit 1
      ;;
  esac
}

main() {
  local cmd_raw="${1-}"
  shift || true

  # Normalize common command aliases (people tend to omit ':' or use '-'/'_').
  local cmd
  cmd="$(printf '%s' "$cmd_raw" | tr '[:upper:]' '[:lower:]')"
  case "$cmd" in
    registryupdate|registry-update|registry_update) cmd="registry:update" ;;
    e2erun|e2e-run|e2e_run) cmd="e2e:run" ;;
  esac

  case "$cmd" in
    generate) cmd_generate "$@" ;;
    prepare) cmd_prepare "$@" ;;
    deploy) cmd_deploy "$@" ;;
    registry:update) cmd_registry_update "$@" ;;
    apply) cmd_apply "$@" ;;
    e2e:run) cmd_e2e_run "$@" ;;
    enable|activate) cmd_enable "$@" ;;
    disable|deactivate) cmd_disable "$@" ;;
    config) cmd_config "$@" ;;
    check) cmd_check "$@" ;;
    watch) cmd_watch "$@" ;;
    "") usage; exit 1 ;;
    *) echo "[ERROR] Unknown command: $cmd"; usage; exit 1 ;;
  esac
}

main "$@"
